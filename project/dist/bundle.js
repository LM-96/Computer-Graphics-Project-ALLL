/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/AntonioFranzeseApp.ts":
/*!**************************************!*\
  !*** ./src/ts/AntonioFranzeseApp.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst webgl_application_1 = __webpack_require__(/*! ./webgl/webgl-application */ \"./src/ts/webgl/webgl-application.ts\");\nconst log_1 = __webpack_require__(/*! ./log/log */ \"./src/ts/log/log.ts\");\nconst menu_controls_1 = __webpack_require__(/*! ./controls/menu-controls */ \"./src/ts/controls/menu-controls.ts\");\nconst user_inputs_1 = __webpack_require__(/*! ./controls/user-inputs */ \"./src/ts/controls/user-inputs.ts\");\nconst L = 3;\nlog_1.Log.enableLog();\nlet MyApp = class MyApp extends webgl_application_1.WebGLApplication {\n    constructor() {\n        super();\n    }\n    beforeStart() {\n        // Light Set up\n        let light = this.getMeshObjectDrawer().getSlManager();\n        light.setFar(200);\n        light.setProjHeight(200);\n        light.setProjWidth(200);\n        light.setLightPosition(20, 20, 100);\n        light.setLightTarget(20, 20, 0);\n        light.setShadows(true);\n        //Camera Set up\n        let camera = this.getCamera();\n        camera.setPosition(15, 0, 5);\n        this.getMeshObjectDrawer().zFar = 700;\n        camera.startFollowingObject(this.Furgoncino);\n        this.menu = new menu_controls_1.MenuControls(this);\n        this.menu.setup();\n        this.userInputs = new user_inputs_1.UserInputs(this);\n        this.userInputs.setTarget(this.Furgoncino);\n        this.userInputs.attachHandlers();\n    }\n    main(args) {\n        console.log(\"Hello world! [\" + this.applicationName + \"]\");\n        this.drawScene();\n    }\n};\n__decorate([\n    (0, webgl_application_1.WebGLMesh)(\"./assets/Consegna_fiori/Saviano2.obj\")\n], MyApp.prototype, \"Saviano\", void 0);\n__decorate([\n    (0, webgl_application_1.WebGLMesh)(\"./assets/Consegna_fiori/furgoncino.obj\"),\n    (0, webgl_application_1.ObjScale)(0.7, 0.7, 0.7),\n    (0, webgl_application_1.ObjPosition)(0, 0, 1)\n], MyApp.prototype, \"Furgoncino\", void 0);\nMyApp = __decorate([\n    (0, webgl_application_1.WebGL)(\"test-app\", \"my_Canvas\", {\n        main: [\"vertex-shader\", \"fragment-shader\"],\n        color: [\"color-vertex-shader\", \"color-fragment-shader\"]\n    })\n], MyApp);\n\n\n//# sourceURL=webpack:///./src/ts/AntonioFranzeseApp.ts?");

/***/ }),

/***/ "./src/ts/camera/camera-signals.ts":
/*!*****************************************!*\
  !*** ./src/ts/camera/camera-signals.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass CameraSignals {\n}\nexports[\"default\"] = CameraSignals;\nCameraSignals.CAMERA_TRANSLATION_SIGNAL_STRING_NAME = \"camera.translation\";\nCameraSignals.CAMERA_UP_SIGNAL_STRING_NAME = \"camera.up\";\nCameraSignals.CAMERA_TARGET_SIGNAL_STRING_NAME = \"camera.target\";\nCameraSignals.CAMERA_FOV_SIGNAL_STRING_NAME = \"camera.fov\";\nCameraSignals.CAMERA_DISTANCE_FROM_TARGET_SIGNAL_STRING_NAME = \"camera.distance-from-target\";\nCameraSignals.CAMERA_LOOKING_AT_OBJECT_SIGNAL_STRING_NAME = \"camera.looking-at-object\";\nCameraSignals.CAMERA_FOLLOW_OBJECT_TRANSLATION_SIGNAL_STRING_NAME = \"camera.follow-object-translation\";\nCameraSignals.CAMERA_TARGET_OBJECT_SIGNAL_STRING_NAME = \"camera.target-object\";\nCameraSignals.CAMERA_LOOKED_AT_OBJECT_SIGNAL_STRING_NAME = \"camera.looked-at-object\";\n\n\n//# sourceURL=webpack:///./src/ts/camera/camera-signals.ts?");

/***/ }),

/***/ "./src/ts/camera/flowed-camera.ts":
/*!****************************************!*\
  !*** ./src/ts/camera/flowed-camera.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FlowedCamera_position, _FlowedCamera_up, _FlowedCamera_target, _FlowedCamera_fov, _FlowedCamera_lookingAtObject, _FlowedCamera_followObjectTranslation, _FlowedCamera_targetObject, _FlowedCamera_lookingAtObjectReceipt, _FlowedCamera_positionFlow, _FlowedCamera_upFlow, _FlowedCamera_targetFlow, _FlowedCamera_fovFlow, _FlowedCamera_lookingAtObjectFlow, _FlowedCamera_followObjectTranslationFlow, _FlowedCamera_followedObjectFlow, _FlowedCamera_lookedAtObjectFlow, _FlowedCamera_performedTranslationBuilder, _FlowedCamera_lookAtObjectReceipt, _FlowedCamera_followObjectReceipt;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst number_trio_1 = __webpack_require__(/*! ../types/numbers/number-trio */ \"./src/ts/types/numbers/number-trio.ts\");\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst point_factory_1 = __webpack_require__(/*! ../geometry/point/point-factory */ \"./src/ts/geometry/point/point-factory.ts\");\nconst flow_1 = __webpack_require__(/*! ../signals/flow */ \"./src/ts/signals/flow.ts\");\nconst performed_translation_1 = __webpack_require__(/*! ../geometry/data/performed-translation */ \"./src/ts/geometry/data/performed-translation.ts\");\nconst performed_number_trio_change_1 = __webpack_require__(/*! ../types/data/performed-number-trio-change */ \"./src/ts/types/data/performed-number-trio-change.ts\");\nconst performed_object_set_1 = __webpack_require__(/*! ../types/data/performed-object-set */ \"./src/ts/types/data/performed-object-set.ts\");\nconst camera_signals_1 = __webpack_require__(/*! ./camera-signals */ \"./src/ts/camera/camera-signals.ts\");\nconst mesh_object_signals_1 = __webpack_require__(/*! ../obj/mesh-object-signals */ \"./src/ts/obj/mesh-object-signals.ts\");\nconst options_1 = __webpack_require__(/*! ../signals/options */ \"./src/ts/signals/options.ts\");\nclass FlowedCamera {\n    constructor() {\n        _FlowedCamera_position.set(this, void 0);\n        _FlowedCamera_up.set(this, void 0);\n        _FlowedCamera_target.set(this, void 0);\n        _FlowedCamera_fov.set(this, void 0);\n        _FlowedCamera_lookingAtObject.set(this, void 0);\n        _FlowedCamera_followObjectTranslation.set(this, void 0);\n        _FlowedCamera_targetObject.set(this, void 0);\n        _FlowedCamera_lookingAtObjectReceipt.set(this, void 0);\n        _FlowedCamera_positionFlow.set(this, void 0);\n        _FlowedCamera_upFlow.set(this, void 0);\n        _FlowedCamera_targetFlow.set(this, void 0);\n        _FlowedCamera_fovFlow.set(this, void 0);\n        _FlowedCamera_lookingAtObjectFlow.set(this, void 0);\n        _FlowedCamera_followObjectTranslationFlow.set(this, void 0);\n        _FlowedCamera_followedObjectFlow.set(this, void 0);\n        _FlowedCamera_lookedAtObjectFlow.set(this, void 0);\n        _FlowedCamera_performedTranslationBuilder.set(this, void 0);\n        _FlowedCamera_lookAtObjectReceipt.set(this, null);\n        _FlowedCamera_followObjectReceipt.set(this, null);\n        __classPrivateFieldSet(this, _FlowedCamera_position, (0, point_factory_1.mutablePoint3D)(1, 1, 1), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_up, (0, number_trio_1.numberTrio)(0, 0, 1), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_target, (0, point_factory_1.mutablePoint3D)(0, 0, 0), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_fov, (0, angle_1.degree)(60), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_lookingAtObject, false, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_followObjectTranslation, false, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_targetObject, null, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_positionFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_TRANSLATION_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_upFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_UP_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_targetFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_TARGET_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_fovFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_FOV_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_lookingAtObjectFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_LOOKING_AT_OBJECT_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_followObjectTranslationFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_FOLLOW_OBJECT_TRANSLATION_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_followedObjectFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_TARGET_OBJECT_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_lookedAtObjectFlow, flow_1.default.newSingleFlow(camera_signals_1.default.CAMERA_LOOKED_AT_OBJECT_SIGNAL_STRING_NAME), \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_performedTranslationBuilder, new performed_translation_1.PerformedTranslationBuilder(), \"f\");\n        __classPrivateFieldGet(this, _FlowedCamera_performedTranslationBuilder, \"f\").who = \"camera\";\n    }\n    lookAtObject(signal) {\n        this.setTarget(signal.data.to);\n    }\n    followObject(signal) {\n        let translationVector = signal.data.translationVector;\n        this.setPosition(__classPrivateFieldGet(this, _FlowedCamera_position, \"f\").getX() + translationVector.getFirst(), __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").getY() + translationVector.getSecond(), __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").getZ() + translationVector.getThird());\n    }\n    calculateCameraMatrix() {\n        return M4.lookAt(__classPrivateFieldGet(this, _FlowedCamera_position, \"f\").toArray(), __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").toArray(), __classPrivateFieldGet(this, _FlowedCamera_up, \"f\").toArray());\n    }\n    getCameraPositionSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_positionFlow, \"f\");\n    }\n    getCurrentDistanceFromTarget() {\n        return (0, number_trio_1.numberTrio)(__classPrivateFieldGet(this, _FlowedCamera_position, \"f\").getX() - __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getX(), __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").getY() - __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getY(), __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").getZ() - __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getZ());\n    }\n    getCurrentFov() {\n        return __classPrivateFieldGet(this, _FlowedCamera_fov, \"f\").clone();\n    }\n    getCurrentPosition() {\n        return __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").frozen(false);\n    }\n    getCurrentTarget() {\n        return __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").frozen(false);\n    }\n    getCurrentUp() {\n        return __classPrivateFieldGet(this, _FlowedCamera_up, \"f\").clone();\n    }\n    getFollowedObject() {\n        if (__classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\")) {\n            return __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\");\n        }\n        return null;\n    }\n    getFollowedObjectSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_followedObjectFlow, \"f\");\n    }\n    getFollowingObjectSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslationFlow, \"f\");\n    }\n    getFovSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_fovFlow, \"f\");\n    }\n    getLookedObject() {\n        if (__classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\")) {\n            return __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\");\n        }\n        return null;\n    }\n    getLookedObjectSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_lookedAtObjectFlow, \"f\");\n    }\n    getLookingAtObjectSubscriber() {\n        return undefined;\n    }\n    getTargetSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_targetFlow, \"f\");\n    }\n    getUpSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedCamera_upFlow, \"f\");\n    }\n    isFollowingObjectTranslation() {\n        return __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\");\n    }\n    isLookingAtObject() {\n        return __classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\");\n    }\n    setDistanceFromTarget(distanceFromTarget, y, z) {\n        if (typeof distanceFromTarget === \"number\") {\n            __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").set(__classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getX() + distanceFromTarget, __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getY() + y, __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getZ() + z);\n        }\n        else {\n            __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").set(__classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getX() + distanceFromTarget.getFirst(), __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getY() + distanceFromTarget.getSecond(), __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").getZ() + distanceFromTarget.getThird());\n        }\n    }\n    setFov(fov) {\n        let oldFov = __classPrivateFieldGet(this, _FlowedCamera_fov, \"f\").clone();\n        __classPrivateFieldSet(this, _FlowedCamera_fov, fov, \"f\");\n        __classPrivateFieldGet(this, _FlowedCamera_fovFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldFov, __classPrivateFieldGet(this, _FlowedCamera_fov, \"f\")));\n    }\n    setPosition(position, y, z) {\n        __classPrivateFieldGet(this, _FlowedCamera_performedTranslationBuilder, \"f\").clear();\n        __classPrivateFieldGet(this, _FlowedCamera_performedTranslationBuilder, \"f\").from = __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").clone();\n        if (typeof position === \"number\") {\n            __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").set(position, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").set(position.getX(), position.getY(), position.getZ());\n        }\n        __classPrivateFieldGet(this, _FlowedCamera_performedTranslationBuilder, \"f\").to = __classPrivateFieldGet(this, _FlowedCamera_position, \"f\").clone();\n        __classPrivateFieldGet(this, _FlowedCamera_positionFlow, \"f\").fire(this, __classPrivateFieldGet(this, _FlowedCamera_performedTranslationBuilder, \"f\").build());\n    }\n    setTarget(target, y, z) {\n        let oldTarget = __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").clone();\n        if (typeof target === \"number\") {\n            __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").set(target, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _FlowedCamera_target, \"f\").set(target.getX(), target.getY(), target.getZ());\n        }\n        __classPrivateFieldGet(this, _FlowedCamera_targetFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldTarget, __classPrivateFieldGet(this, _FlowedCamera_target, \"f\")));\n    }\n    setUp(up, y, z) {\n        let oldUp = __classPrivateFieldGet(this, _FlowedCamera_up, \"f\").clone();\n        if (typeof up === \"number\") {\n            __classPrivateFieldGet(this, _FlowedCamera_up, \"f\").setAll(up, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _FlowedCamera_up, \"f\").setAll(up.getFirst(), up.getSecond(), up.getThird());\n        }\n        __classPrivateFieldGet(this, _FlowedCamera_upFlow, \"f\").fire(this, new performed_number_trio_change_1.PerformedNumberTrioChange(oldUp, __classPrivateFieldGet(this, _FlowedCamera_up, \"f\")));\n    }\n    startFollowingObject(obj) {\n        if (__classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\")) {\n            this.stopFollowingObject();\n        }\n        let oldObject = __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_targetObject, obj, \"f\");\n        let oldFollowObjectTranslation = __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\");\n        if (!__classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\") || (__classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\") && __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\") !== oldObject)) {\n            this.startLookingAtObject(obj);\n        }\n        __classPrivateFieldSet(this, _FlowedCamera_followObjectTranslation, true, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_followObjectReceipt, mesh_object_signals_1.MeshObjectSignals\n            .getTranslationSubscriberOf(__classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\"))\n            .subscribe((0, options_1.handler)((signal) => { this.followObject(signal); })), \"f\");\n        __classPrivateFieldGet(this, _FlowedCamera_followedObjectFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldObject, __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\")));\n        __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslationFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldFollowObjectTranslation, __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\")));\n    }\n    startLookingAtObject(obj) {\n        if (__classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\")) {\n            this.stopLookingAtObject();\n        }\n        let oldObject = __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\");\n        let oldLookingAtObject = __classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_targetObject, obj, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_lookingAtObject, true, \"f\");\n        __classPrivateFieldSet(this, _FlowedCamera_lookAtObjectReceipt, mesh_object_signals_1.MeshObjectSignals\n            .getTranslationSubscriberOf(__classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\"))\n            .subscribe((0, options_1.handler)((signal) => { this.lookAtObject(signal); })), \"f\");\n        __classPrivateFieldGet(this, _FlowedCamera_lookedAtObjectFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldObject, __classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\")));\n        __classPrivateFieldGet(this, _FlowedCamera_lookingAtObjectFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldLookingAtObject, __classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\")));\n    }\n    stopFollowingObject() {\n        if (__classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\") == true) {\n            let oldFollowObjectTranslation = __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\");\n            mesh_object_signals_1.MeshObjectSignals\n                .getTranslationSubscriberOf(__classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\"))\n                .unsubscribe(__classPrivateFieldGet(this, _FlowedCamera_followObjectReceipt, \"f\"));\n            __classPrivateFieldSet(this, _FlowedCamera_followObjectReceipt, null, \"f\");\n            __classPrivateFieldSet(this, _FlowedCamera_followObjectTranslation, false, \"f\");\n            __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslationFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldFollowObjectTranslation, __classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\")));\n        }\n    }\n    stopLookingAtObject() {\n        if (__classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\")) {\n            if (__classPrivateFieldGet(this, _FlowedCamera_followObjectTranslation, \"f\")) {\n                this.stopFollowingObject();\n            }\n            mesh_object_signals_1.MeshObjectSignals\n                .getTranslationSubscriberOf(__classPrivateFieldGet(this, _FlowedCamera_targetObject, \"f\"))\n                .unsubscribe(__classPrivateFieldGet(this, _FlowedCamera_lookAtObjectReceipt, \"f\"));\n            __classPrivateFieldSet(this, _FlowedCamera_lookAtObjectReceipt, null, \"f\");\n            let oldLookingAtObject = __classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\");\n            __classPrivateFieldSet(this, _FlowedCamera_lookingAtObject, false, \"f\");\n            __classPrivateFieldGet(this, _FlowedCamera_lookingAtObjectFlow, \"f\").fire(this, new performed_object_set_1.PerformedObjectSet(oldLookingAtObject, __classPrivateFieldGet(this, _FlowedCamera_lookingAtObject, \"f\")));\n        }\n    }\n}\nexports[\"default\"] = FlowedCamera;\n_FlowedCamera_position = new WeakMap(), _FlowedCamera_up = new WeakMap(), _FlowedCamera_target = new WeakMap(), _FlowedCamera_fov = new WeakMap(), _FlowedCamera_lookingAtObject = new WeakMap(), _FlowedCamera_followObjectTranslation = new WeakMap(), _FlowedCamera_targetObject = new WeakMap(), _FlowedCamera_lookingAtObjectReceipt = new WeakMap(), _FlowedCamera_positionFlow = new WeakMap(), _FlowedCamera_upFlow = new WeakMap(), _FlowedCamera_targetFlow = new WeakMap(), _FlowedCamera_fovFlow = new WeakMap(), _FlowedCamera_lookingAtObjectFlow = new WeakMap(), _FlowedCamera_followObjectTranslationFlow = new WeakMap(), _FlowedCamera_followedObjectFlow = new WeakMap(), _FlowedCamera_lookedAtObjectFlow = new WeakMap(), _FlowedCamera_performedTranslationBuilder = new WeakMap(), _FlowedCamera_lookAtObjectReceipt = new WeakMap(), _FlowedCamera_followObjectReceipt = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/camera/flowed-camera.ts?");

/***/ }),

/***/ "./src/ts/controls/menu-controls.ts":
/*!******************************************!*\
  !*** ./src/ts/controls/menu-controls.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MenuControls_application, _MenuControls_activeObj, _MenuControls_targetObj, _MenuControls_widgets, _MenuControls_loadedObjs, _MenuControls_settings, _MenuControls_currentObjReceipt;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MenuControls = void 0;\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst camera_signals_1 = __webpack_require__(/*! ../camera/camera-signals */ \"./src/ts/camera/camera-signals.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nconst signals_decorator_1 = __webpack_require__(/*! ../signals/signals-decorator */ \"./src/ts/signals/signals-decorator.ts\");\nconst options_1 = __webpack_require__(/*! ../signals/options */ \"./src/ts/signals/options.ts\");\nconst pair_1 = __webpack_require__(/*! ../types/pair */ \"./src/ts/types/pair.ts\");\nlet MenuControls = class MenuControls {\n    constructor(application) {\n        _MenuControls_application.set(this, void 0);\n        _MenuControls_activeObj.set(this, void 0);\n        _MenuControls_targetObj.set(this, void 0);\n        _MenuControls_widgets.set(this, void 0);\n        _MenuControls_loadedObjs.set(this, void 0);\n        _MenuControls_settings.set(this, void 0);\n        _MenuControls_currentObjReceipt.set(this, void 0);\n        __classPrivateFieldSet(this, _MenuControls_application, application, \"f\");\n        __classPrivateFieldSet(this, _MenuControls_loadedObjs, application.getMeshObjectManager().getAll().map((obj) => obj.getName()), \"f\");\n        __classPrivateFieldSet(this, _MenuControls_currentObjReceipt, [], \"f\");\n        __classPrivateFieldSet(this, _MenuControls_settings, {\n            log: true,\n            target: undefined,\n            look_at: false,\n            follow: false,\n            cameraX: application.getCamera().getCurrentPosition().getX(),\n            cameraY: application.getCamera().getCurrentPosition().getY(),\n            cameraZ: application.getCamera().getCurrentPosition().getY(),\n            cameraUpX: application.getCamera().getCurrentUp().getFirst(),\n            cameraUpY: application.getCamera().getCurrentUp().getSecond(),\n            cameraUpZ: application.getCamera().getCurrentUp().getThird(),\n            posX: 0,\n            posY: 0,\n            posZ: 0.25,\n            scaleX: 1,\n            scaleY: 1,\n            scaleZ: 1,\n            psi: 0,\n            theta: 0,\n            phi: 0,\n            targetX: application.getCamera().getCurrentTarget().getX(),\n            targetY: application.getCamera().getCurrentTarget().getY(),\n            targetZ: application.getCamera().getCurrentTarget().getZ(),\n            frustum: application.getMeshObjectDrawer().getLightFrustum(),\n            shadows: application.getMeshObjectDrawer().getSlManager().getShadows(),\n            bias: application.getMeshObjectDrawer().getBias(),\n            lightPosX: application.getMeshObjectDrawer().getSlManager().getLightPosition().getX(),\n            lightPosY: application.getMeshObjectDrawer().getSlManager().getLightPosition().getY(),\n            lightPosZ: application.getMeshObjectDrawer().getSlManager().getLightPosition().getZ(),\n            lightTargX: application.getMeshObjectDrawer().getSlManager().getLightTarget().getX(),\n            lightTargY: application.getMeshObjectDrawer().getSlManager().getLightTarget().getY(),\n            lightTargZ: application.getMeshObjectDrawer().getSlManager().getLightTarget().getZ(),\n            lightFov: application.getMeshObjectDrawer().getSlManager().getFov().getValueIn(angle_1.AngleUnit.DEG),\n            lightNear: application.getMeshObjectDrawer().getSlManager().getNear(),\n            lightFar: application.getMeshObjectDrawer().getSlManager().getFar(),\n            spotlight: application.getMeshObjectDrawer().getSlManager().isSpotlight(),\n            lightWidth: application.getMeshObjectDrawer().getSlManager().getProjWidth(),\n            lightHeight: application.getMeshObjectDrawer().getSlManager().getProjHeight(),\n            lightUpX: application.getMeshObjectDrawer().getSlManager().getLightUp().getFirst(),\n            lightUpY: application.getMeshObjectDrawer().getSlManager().getLightUp().getSecond(),\n            lightUpZ: application.getMeshObjectDrawer().getSlManager().getLightUp().getThird(),\n            fov: application.getCamera().getCurrentFov().getValueIn(angle_1.AngleUnit.DEG),\n            zNear: application.getMeshObjectDrawer().zNear,\n            zFar: application.getMeshObjectDrawer().zFar,\n            currentobj: undefined,\n            hidden: false,\n            draw: false,\n        }, \"f\");\n        if (__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\").length > 0) {\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").currentobj = 0;\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").target = 0;\n            __classPrivateFieldSet(this, _MenuControls_targetObj, __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectManager().get(__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\")[0]), \"f\");\n            this.updateActiveObj(false);\n        }\n    }\n    subscribeCurrentObjSignals() {\n        log_1.Log.log(\"Subscribing to signals of \" + __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getName());\n        __classPrivateFieldGet(this, _MenuControls_currentObjReceipt, \"f\").push((0, pair_1.pairOf)(__classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getTranslationSubscriber(), __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getTranslationSubscriber().subscribe((0, options_1.handler)((signal) => {\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").posX = signal.data.to.getX();\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").posY = signal.data.to.getY();\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").posZ = signal.data.to.getZ();\n            this.updateUI();\n        }))));\n        __classPrivateFieldGet(this, _MenuControls_currentObjReceipt, \"f\").push((0, pair_1.pairOf)(__classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getScaleSubscriber(), __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getScaleSubscriber().subscribe((0, options_1.handler)((signal) => {\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").scaleX = signal.data.to.getFirst();\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").scaleY = signal.data.to.getSecond();\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").scaleZ = signal.data.to.getThird();\n            this.updateUI();\n        }))));\n        __classPrivateFieldGet(this, _MenuControls_currentObjReceipt, \"f\").push((0, pair_1.pairOf)(__classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPolarRotationSubscriber(), __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPolarRotationSubscriber().subscribe((0, options_1.handler)((signal) => {\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").phi = signal.data.to.getFirst().getValueIn(angle_1.AngleUnit.DEG);\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").theta = signal.data.to.getSecond().getValueIn(angle_1.AngleUnit.DEG);\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").phi = signal.data.to.getThird().getValueIn(angle_1.AngleUnit.DEG);\n            this.updateUI();\n        }))));\n        log_1.Log.log(\"Subscribed to signals of \" + __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getName() +\n            \", total subscriptions: \" + __classPrivateFieldGet(this, _MenuControls_currentObjReceipt, \"f\").length);\n    }\n    unsubscribeCurrentObjSignals() {\n        log_1.Log.log(\"Unsubscribing from signals of \" + __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getName());\n        __classPrivateFieldGet(this, _MenuControls_currentObjReceipt, \"f\").forEach((pair) => {\n            pair.getFirst().unsubscribe(pair.getSecond());\n        });\n        log_1.Log.log(\"Unsubscribed from signals of \" + __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getName() + \" completed\");\n        __classPrivateFieldSet(this, _MenuControls_currentObjReceipt, [], \"f\");\n    }\n    updateActiveObj(updateUI = true) {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        if (__classPrivateFieldGet(this, _MenuControls_activeObj, \"f\") != undefined) {\n            this.unsubscribeCurrentObjSignals();\n        }\n        __classPrivateFieldSet(this, _MenuControls_activeObj, __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectManager().get(__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\")[settings.currentobj]), \"f\");\n        settings.posX = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPosition().getX();\n        settings.posY = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPosition().getY();\n        settings.posZ = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPosition().getZ();\n        settings.scaleX = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getCurrentScale().getFirst();\n        settings.scaleY = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getCurrentScale().getSecond();\n        settings.scaleZ = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getCurrentScale().getThird();\n        settings.phi = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPolarRotation().getFirst().getValueIn(angle_1.AngleUnit.DEG);\n        settings.theta = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getPolarRotation().getSecond().getValueIn(angle_1.AngleUnit.DEG);\n        settings.hidden = __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").getHidden();\n        this.subscribeCurrentObjSignals();\n        if (updateUI) {\n            this.updateUI();\n        }\n    }\n    updateUI() {\n        WebGlLessonUI.updateUI(__classPrivateFieldGet(this, _MenuControls_widgets, \"f\"), __classPrivateFieldGet(this, _MenuControls_settings, \"f\"));\n    }\n    onCameraSetPositionEvent(signal) {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        settings.cameraX = signal.data.to.getX();\n        settings.cameraY = signal.data.to.getY();\n        settings.cameraZ = signal.data.to.getZ();\n        this.updateUI();\n    }\n    onCameraSetUpEvent(signal) {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        settings.cameraUpX = signal.data.newValue.getFirst();\n        settings.cameraUpY = signal.data.newValue.getSecond();\n        settings.cameraUpZ = signal.data.newValue.getThird();\n        this.updateUI();\n    }\n    onCameraTargetChanged(signal) {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        settings.targetX = signal.data.newValue.getX();\n        settings.targetY = signal.data.newValue.getY();\n        settings.targetZ = signal.data.newValue.getZ();\n        this.updateUI();\n    }\n    onCameraChange() {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().setPosition(settings.cameraX, settings.cameraY, settings.cameraZ);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onObjectPositionChange() {\n        if (__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\") != undefined) {\n            let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n            __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").setPosition(settings.posX, settings.posY, settings.posZ);\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n        }\n    }\n    onTargetPositionChange() {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().setTarget(settings.targetX, settings.targetY, settings.targetZ);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onFovChange() {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().setFov((0, angle_1.degree)(settings.fov));\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onActiveObjChange() {\n        this.updateActiveObj();\n    }\n    onObjectScaleChange() {\n        if (__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\") != undefined) {\n            let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n            __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").setScale(settings.scaleX, settings.scaleY, settings.scaleZ);\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n        }\n    }\n    onObjectPolarRotationChange() {\n        if (__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\") != undefined) {\n            let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n            __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").setPolarRotation((0, angle_1.degree)(settings.psi), (0, angle_1.degree)(settings.theta), (0, angle_1.degree)(settings.phi));\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n        }\n    }\n    onCameraUpChange() {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().setUp(settings.cameraUpX, settings.cameraUpY, settings.cameraUpZ);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLookAtObjectChange() {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        if (settings.look_at) {\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().startLookingAtObject(__classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectManager()\n                .get(__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\")[settings.target]));\n        }\n        else {\n            if (settings.follow) {\n                settings.follow = false;\n                this.updateUI();\n                this.onFollowObjectChange();\n            }\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().stopLookingAtObject();\n        }\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onFollowObjectChange() {\n        let settings = __classPrivateFieldGet(this, _MenuControls_settings, \"f\");\n        if (settings.follow) {\n            if (!settings.look_at) {\n                settings.look_at = true;\n                this.updateUI();\n                this.onLookAtObjectChange();\n            }\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().startFollowingObject(__classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectManager()\n                .get(__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\")[settings.target]));\n        }\n        else {\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getCamera().stopFollowingObject();\n        }\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onHiddenObjChange() {\n        __classPrivateFieldGet(this, _MenuControls_activeObj, \"f\").setHidden(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").hidden);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLogChanged() {\n        if (__classPrivateFieldGet(this, _MenuControls_settings, \"f\").log) {\n            log_1.Log.enableLog();\n        }\n        else {\n            log_1.Log.disableLog();\n        }\n    }\n    onTargetObjChange() {\n        if (__classPrivateFieldGet(this, _MenuControls_settings, \"f\").look_at || __classPrivateFieldGet(this, _MenuControls_settings, \"f\").follow) {\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").target = __classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\").indexOf(__classPrivateFieldGet(this, _MenuControls_targetObj, \"f\").getName());\n            this.updateUI();\n        }\n        else {\n            __classPrivateFieldSet(this, _MenuControls_targetObj, __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectManager()\n                .get(__classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\")[__classPrivateFieldGet(this, _MenuControls_settings, \"f\").target]), \"f\");\n        }\n    }\n    onDrawPressed() {\n        if (__classPrivateFieldGet(this, _MenuControls_settings, \"f\").draw) {\n            __classPrivateFieldGet(this, _MenuControls_settings, \"f\").draw = false;\n            __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n            this.updateUI();\n        }\n    }\n    onZNearChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().zNear = __classPrivateFieldGet(this, _MenuControls_settings, \"f\").zNear;\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onZFarChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().zFar = __classPrivateFieldGet(this, _MenuControls_settings, \"f\").zFar;\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onFrustumChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().setLightFrustum(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").frustum);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onShadowsChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setShadows(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").shadows);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightPositionChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setLightPosition(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightPosX, __classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightPosY, __classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightPosZ);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightTargetChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setLightTarget(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightTargX, __classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightTargY, __classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightTargZ);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightFovChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setFov((0, angle_1.degree)(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightFov));\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onSpotlightChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setSpotlight(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").spotlight);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightWidthChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setProjWidth(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightWidth);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightHeightChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setProjHeight(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightHeight);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightUpChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setLightUp(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightUpX, __classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightUpY, __classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightUpZ);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onBiasChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().setBias(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").bias);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightNearChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setNear(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightNear);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    onLightFarChange() {\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().getSlManager().setFar(__classPrivateFieldGet(this, _MenuControls_settings, \"f\").lightFar);\n        __classPrivateFieldGet(this, _MenuControls_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    setup() {\n        __classPrivateFieldSet(this, _MenuControls_widgets, WebGlLessonUI.setupUI(document.querySelector('#ui'), __classPrivateFieldGet(this, _MenuControls_settings, \"f\"), [\n            { type: 'checkbox', key: 'log', change: () => { this.onLogChanged(); } },\n            /* CAMERA ***************************************************************************** */\n            { type: 'option', key: 'target', change: () => { this.onTargetObjChange(); }, options: __classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\"), },\n            { type: 'checkbox', key: 'look_at', change: () => { this.onLookAtObjectChange(); }, },\n            { type: 'checkbox', key: 'follow', change: () => { this.onFollowObjectChange(); }, },\n            { type: 'slider', key: 'cameraX', change: () => { this.onCameraChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'cameraY', change: () => { this.onCameraChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'cameraZ', change: () => { this.onCameraChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'cameraUpX', change: () => { this.onCameraUpChange(); }, min: -1, max: 1, precision: 3, step: 0.001, },\n            { type: 'slider', key: 'cameraUpY', change: () => { this.onCameraUpChange(); }, min: -1, max: 1, precision: 3, step: 0.001, },\n            { type: 'slider', key: 'cameraUpZ', change: () => { this.onCameraUpChange(); }, min: -1, max: 1, precision: 3, step: 0.001, },\n            { type: 'slider', key: 'zNear', change: () => { this.onZNearChange(); }, min: -10, max: 10, precision: 2, step: 1, },\n            { type: 'slider', key: 'zFar', change: () => { this.onZFarChange(); }, min: -200, max: 200, precision: 1, step: 1, },\n            { type: 'slider', key: 'fov', change: () => { this.onFovChange(); }, min: 0, max: 180, },\n            { type: 'slider', key: 'targetX', change: () => { this.onTargetPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'targetY', change: () => { this.onTargetPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'targetZ', change: () => { this.onTargetPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            /* LIGHT ***************************************************************************** */\n            { type: 'checkbox', key: 'frustum', change: () => { this.onFrustumChange(); } },\n            { type: 'checkbox', key: 'shadows', change: () => { this.onShadowsChange(); } },\n            //{ type: 'slider',   key: 'bias',    change: () => { this.onBiasChange() }, min: 0, max: 10, precision: 3, step: 0.001, },\n            { type: 'slider', key: 'lightPosX', change: () => { this.onLightPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightPosY', change: () => { this.onLightPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightPosZ', change: () => { this.onLightPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightTargX', change: () => { this.onLightTargetChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightTargY', change: () => { this.onLightTargetChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightTargZ', change: () => { this.onLightTargetChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightFov', change: () => { this.onLightFovChange(); }, min: 0, max: 360, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightNear', change: () => { this.onLightNearChange(); }, min: 0, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightFar', change: () => { this.onLightFarChange(); }, min: 0, max: 1000, precision: 1, step: 1, },\n            { type: 'checkbox', key: 'spotlight', change: () => { this.onSpotlightChange(); } },\n            { type: 'slider', key: 'lightWidth', change: () => { this.onLightWidthChange(); }, min: 0, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'lightHeight', change: () => { this.onLightHeightChange(); }, min: 0, max: 100, precision: 1, step: 1, },\n            //{ type: 'slider',   key: 'lightUpX',    change: () => { this.onLightUpChange() }, min: -1, max: 1, precision: 3, step: 0.001, },\n            //{ type: 'slider',   key: 'lightUpY',    change: () => { this.onLightUpChange() }, min:   -1, max: 1, precision: 3, step: 0.001, },\n            //{ type: 'slider',   key: 'lightUpZ',    change: () => { this.onLightUpChange() }, min:   -1, max: 1, precision: 3, step: 0.001, },\n            /* OBJECT ***************************************************************************** */\n            { type: 'option', key: 'currentobj', change: () => { this.onActiveObjChange(); }, options: __classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\"), },\n            { type: 'checkbox', key: 'hidden', change: () => { this.onHiddenObjChange(); }, options: __classPrivateFieldGet(this, _MenuControls_loadedObjs, \"f\"), },\n            { type: 'slider', key: 'posX', change: () => { this.onObjectPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'posY', change: () => { this.onObjectPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'posZ', change: () => { this.onObjectPositionChange(); }, min: -100, max: 100, precision: 1, step: 1, },\n            { type: 'slider', key: 'scaleX', change: () => { this.onObjectScaleChange(); }, min: 0, max: 10, precision: 1, step: 1, },\n            { type: 'slider', key: 'scaleY', change: () => { this.onObjectScaleChange(); }, min: 0, max: 10, precision: 1, step: 1, },\n            { type: 'slider', key: 'scaleZ', change: () => { this.onObjectScaleChange(); }, min: 0, max: 10, precision: 1, step: 1, },\n            { type: 'slider', key: 'psi', change: () => { this.onObjectPolarRotationChange(); }, min: 0, max: 360 },\n            { type: 'slider', key: 'theta', change: () => { this.onObjectPolarRotationChange(); }, min: 0, max: 360 },\n            { type: 'slider', key: 'phi', change: () => { this.onObjectPolarRotationChange(); }, min: 0, max: 360 },\n            { type: 'checkbox', key: 'draw', change: () => { this.onDrawPressed(); } },\n        ]), \"f\");\n    }\n};\n_MenuControls_application = new WeakMap(), _MenuControls_activeObj = new WeakMap(), _MenuControls_targetObj = new WeakMap(), _MenuControls_widgets = new WeakMap(), _MenuControls_loadedObjs = new WeakMap(), _MenuControls_settings = new WeakMap(), _MenuControls_currentObjReceipt = new WeakMap();\n__decorate([\n    (0, signals_decorator_1.OnSignalMethod)(camera_signals_1.default.CAMERA_TRANSLATION_SIGNAL_STRING_NAME)\n], MenuControls.prototype, \"onCameraSetPositionEvent\", null);\n__decorate([\n    (0, signals_decorator_1.OnSignalMethod)(camera_signals_1.default.CAMERA_UP_SIGNAL_STRING_NAME)\n], MenuControls.prototype, \"onCameraSetUpEvent\", null);\n__decorate([\n    (0, signals_decorator_1.OnSignalMethod)(camera_signals_1.default.CAMERA_TARGET_SIGNAL_STRING_NAME)\n], MenuControls.prototype, \"onCameraTargetChanged\", null);\nMenuControls = __decorate([\n    signals_decorator_1.SignalListener\n], MenuControls);\nexports.MenuControls = MenuControls;\n\n\n//# sourceURL=webpack:///./src/ts/controls/menu-controls.ts?");

/***/ }),

/***/ "./src/ts/controls/user-input-controller.ts":
/*!**************************************************!*\
  !*** ./src/ts/controls/user-input-controller.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _UserInputController_instances, _UserInputController_translateTarget, _UserInputController_rotateTarget;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserInputController = void 0;\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nclass UserInputController {\n    constructor() {\n        _UserInputController_instances.add(this);\n        this.stepSize = 2;\n        this.step = 2;\n        this.controllerMode = 2;\n        this.cameraMode = 0;\n        this.controllerMode = 2;\n    }\n    //this.controllerMode = 1; //0 visuale in terza persona, //1 visuale dall'alto, //2 visuale in prima persona\n    setTarget(target) {\n        this.target = target;\n    }\n    setControllerMode(mode) {\n        this.controllerMode = mode;\n    }\n    setCameraMode(mode) {\n        this.cameraMode = mode;\n    }\n    move(move) {\n        this.commandActuator(move, this.controllerMode);\n    }\n    commandActuator(move, controllerMode) {\n        switch (controllerMode) {\n            case 0:\n                this.moveThirdPerson(move);\n                break;\n            case 1:\n                this.moveFromTop(move);\n                break; //Alto\n            case 2:\n                this.moveFirstPerson(move);\n                break;\n        }\n    }\n    moveFromTop(keyMove) {\n        switch (keyMove) {\n            case \"ArrowUp\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, 0, this.stepSize, 0);\n                break;\n            case \"ArrowDown\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, 0, -this.stepSize, 0);\n                break;\n            case \"ArrowLeft\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, -this.stepSize, 0, 0);\n                break;\n            case \"ArrowRight\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, this.stepSize, 0, 0);\n                break;\n        }\n    }\n    navigate(dForward, angle) {\n        let dy = dForward * Math.cos(angle.getValueIn(angle_1.AngleUnit.RAD));\n        let dx = dForward * -Math.sin(angle.getValueIn(angle_1.AngleUnit.RAD));\n        let dz = 0;\n        __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, dx, dy, dz);\n    }\n    moveFirstPerson(keyMove) {\n        switch (keyMove) {\n            case \"ArrowUp\":\n                this.navigate(-4, this.target.getPolarRotation().getThird());\n                break;\n            case \"ArrowDown\":\n                this.navigate(4, this.target.getPolarRotation().getThird());\n                break;\n            case \"ArrowLeft\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_rotateTarget).call(this, (0, angle_1.degree)(0), (0, angle_1.degree)(0), (0, angle_1.degree)(5));\n                break;\n            case \"ArrowRight\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_rotateTarget).call(this, (0, angle_1.degree)(0), (0, angle_1.degree)(0), (0, angle_1.degree)(-5));\n                break;\n        }\n    }\n    moveThirdPerson(keyMove) {\n        let phi = this.target.getPolarRotation().getThird().getValueIn(angle_1.AngleUnit.RAD);\n        switch (keyMove) {\n            case \"ArrowUp\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, -this.step * Math.sin(phi), this.step * Math.cos(phi), 0);\n                break;\n            case \"ArrowDown\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, this.step * Math.sin(phi), -this.step * Math.cos(phi), 0);\n                break;\n            case \"ArrowLeft\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, -this.step * Math.cos(phi), -this.step * Math.sin(phi), 0);\n                break;\n            case \"ArrowRight\":\n                __classPrivateFieldGet(this, _UserInputController_instances, \"m\", _UserInputController_translateTarget).call(this, this.step * Math.cos(phi), this.step * Math.sin(phi), 0);\n                break;\n        }\n    }\n}\nexports.UserInputController = UserInputController;\n_UserInputController_instances = new WeakSet(), _UserInputController_translateTarget = function _UserInputController_translateTarget(dx, dy, dz) {\n    let currentPos = this.target.getPosition();\n    this.target.setPosition(currentPos.getX() + dx, currentPos.getY() + dy, currentPos.getZ() + dz);\n}, _UserInputController_rotateTarget = function _UserInputController_rotateTarget(deltaPsi, deltaTheta, deltaPhi) {\n    let currentRotation = this.target.getPolarRotation();\n    this.target.setPolarRotation(currentRotation.getFirst().add(deltaPsi), currentRotation.getSecond().add(deltaTheta), currentRotation.getThird().add(deltaPhi));\n};\n\n\n//# sourceURL=webpack:///./src/ts/controls/user-input-controller.ts?");

/***/ }),

/***/ "./src/ts/controls/user-inputs.ts":
/*!****************************************!*\
  !*** ./src/ts/controls/user-inputs.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _UserInputs_application, _UserInputs_drag, _UserInputs_oldX, _UserInputs_oldY, _UserInputs_target, _UserInputs_controller;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserInputs = void 0;\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst user_input_controller_1 = __webpack_require__(/*! ./user-input-controller */ \"./src/ts/controls/user-input-controller.ts\");\nclass UserInputs {\n    constructor(application) {\n        _UserInputs_application.set(this, void 0);\n        _UserInputs_drag.set(this, false);\n        _UserInputs_oldX.set(this, 0);\n        _UserInputs_oldY.set(this, 0);\n        _UserInputs_target.set(this, void 0);\n        _UserInputs_controller.set(this, void 0);\n        __classPrivateFieldSet(this, _UserInputs_application, application, \"f\");\n        __classPrivateFieldSet(this, _UserInputs_controller, new user_input_controller_1.UserInputController(), \"f\");\n    }\n    mouseDown(e) {\n        __classPrivateFieldSet(this, _UserInputs_drag, true, \"f\");\n        if (e instanceof MouseEvent) {\n            __classPrivateFieldSet(this, _UserInputs_oldX, e.pageX, \"f\");\n            __classPrivateFieldSet(this, _UserInputs_oldY, e.pageY, \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _UserInputs_oldX, e.touches[0].clientX, \"f\");\n            __classPrivateFieldSet(this, _UserInputs_oldY, e.touches[0].clientY, \"f\");\n        }\n        e.preventDefault();\n        return false;\n    }\n    mouseUp1(e) {\n        __classPrivateFieldSet(this, _UserInputs_drag, false, \"f\");\n    }\n    mouseMove1(e) {\n        if (!__classPrivateFieldGet(this, _UserInputs_drag, \"f\"))\n            return false;\n        let dX;\n        let dY;\n        if (e instanceof MouseEvent) {\n            dX = (e.pageX - __classPrivateFieldGet(this, _UserInputs_oldX, \"f\")) * 2 * Math.PI / __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().width;\n            dY = (e.pageY - __classPrivateFieldGet(this, _UserInputs_oldY, \"f\")) * 2 * Math.PI / __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().height;\n            __classPrivateFieldSet(this, _UserInputs_oldX, e.pageX, \"f\");\n            __classPrivateFieldSet(this, _UserInputs_oldY, e.pageY, \"f\");\n        }\n        else if (e instanceof TouchEvent) {\n            dX = (e.touches[0].clientX - __classPrivateFieldGet(this, _UserInputs_oldX, \"f\")) * 2 * Math.PI / __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().width;\n            dY = (e.touches[0].clientY - __classPrivateFieldGet(this, _UserInputs_oldY, \"f\")) * 2 * Math.PI / __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().height;\n            __classPrivateFieldSet(this, _UserInputs_oldX, e.touches[0].clientX, \"f\");\n            __classPrivateFieldSet(this, _UserInputs_oldY, e.touches[0].clientY, \"f\");\n        }\n        let currentAngles = __classPrivateFieldGet(this, _UserInputs_target, \"f\").getPolarRotation();\n        __classPrivateFieldGet(this, _UserInputs_target, \"f\").setPolarRotation(currentAngles.getFirst(), currentAngles.getSecond(), currentAngles.getThird().add((0, angle_1.radians)(dX)));\n        currentAngles = __classPrivateFieldGet(this, _UserInputs_target, \"f\").getPolarRotation();\n        __classPrivateFieldGet(this, _UserInputs_controller, \"f\").navigate(dY, currentAngles.getThird());\n        //e.preventDefault();\n        __classPrivateFieldGet(this, _UserInputs_application, \"f\").getMeshObjectDrawer().drawScene();\n        log_1.Log.log(\"Angles || PSY:\" + currentAngles.getFirst().toString() + \", THETA:\" + currentAngles.getSecond().toString() +\n            \", PHI:\" + currentAngles.getThird().toString());\n    }\n    keydownMap(e) {\n        log_1.Log.log(\"Key pressed: \" + e.code);\n        switch (e.code) {\n            case \"ArrowDown\":\n                __classPrivateFieldGet(this, _UserInputs_controller, \"f\").move(e.code);\n                break; //Freccia Giù\n            case \"ArrowUp\":\n                __classPrivateFieldGet(this, _UserInputs_controller, \"f\").move(e.code);\n                break; //Freccia Su\n            case \"ArrowLeft\":\n                __classPrivateFieldGet(this, _UserInputs_controller, \"f\").move(e.code);\n                break; //Freccia Sx\n            case \"ArrowRight\":\n                __classPrivateFieldGet(this, _UserInputs_controller, \"f\").move(e.code);\n                break; //Ferccia Dx\n            // case 104 : trans(0,0,0.1); break;\t\t//NUmpad 8\n            // case 189:  trans(0,0,-0.1); break;\t\t//-\n            // case 96 : \tCAMERA_MANAGER.changeCameraView(0); break;        //NUMpad 0\n            // case 49 : \tCAMERA_MANAGER.changeCameraView(1); break;         \t//NUMpad 1\n            // case 50 : \tCAMERA_MANAGER.changeCameraView(2); break;      \t//NUMpad 2\n            // case 51 : \tCAMERA_MANAGER.changeCameraView(3); break;          //NumPad 3\n            // case 52 :\tCAMERA_MANAGER.changeCameraView(4); break;        \t//NumPad 4\n            // case 53 :\tCAMERA_MANAGER.changeCameraView(5); break;\t\t\t//NumPad 5\n            // case 54 :\tCAMERA_MANAGER.changeCameraView(0); break;\t\t\t//NumPad 6\n            // case 188: \tCAMERA_MANAGER.incrementCameraFov(-1); break;\t\t//,\n            // case 190:\tCAMERA_MANAGER.incrementCameraFov(1); break;\t\t//.\n        }\n        __classPrivateFieldGet(this, _UserInputs_application, \"f\").getMeshObjectDrawer().drawScene();\n    }\n    //\n    // const keydownMapLog = function(e) {\n    //     switch(e.keyCode) {\n    //         case 40 : log(\"Freccia Giù\"); break;      \t//Freccia Giù\n    //         case 38 : log(\"Freccia Su\"); break;       \t//Freccia Su\n    //         case 37 : log(\"Freccia Sx\"); break;       //Freccia Sx\n    //         case 39 : log(\"Freccia Dx\"); break;       \t//Ferccia Dx\n    //         case 104 : log(\"Tasto: 8\"); break;\t\t//NUmpad 8\n    //         case 189: console.log(settings); break;    //-\n    //         default: log(\"Tasto:\" + e.keyCode)\n    //     }\n    // }\n    attachHandler(handlerType, handlerFunc) {\n        switch (handlerType.toLowerCase()) {\n            case \"onmousedown\":\n                __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmousedown = handlerFunc;\n                break;\n            case \"onmouseup\":\n                __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmouseup = handlerFunc;\n                break;\n            case \"onmouseout\":\n                __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmouseout = handlerFunc;\n                break;\n            case \"onmousemove\":\n                __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmousemove = handlerFunc;\n                break;\n            case \"onkeydown\":\n                document.addEventListener('keydown', handlerFunc);\n                break;\n            case \"ontouchmove\":\n                document.addEventListener(\"ontouchmove\", handlerFunc);\n                break;\n            case \"ontouchstart\":\n                document.addEventListener(\"ontouchstart\", handlerFunc);\n                break;\n            case \"ontouchend\":\n                document.addEventListener(\"ontouchend\", handlerFunc);\n                break;\n        }\n        log_1.Log.log(\"Attached Handler: \" + handlerType.toLowerCase());\n    }\n    attachHandlers() {\n        __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmousedown = (ev) => { this.mouseDown(ev); };\n        __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmouseup = (ev) => { this.mouseUp1(ev); };\n        __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmouseout = (ev) => { this.mouseUp1(ev); };\n        __classPrivateFieldGet(this, _UserInputs_application, \"f\").getCanvas().onmousemove = (ev) => { this.mouseMove1(ev); };\n        document.addEventListener(\"touchstart\", (ev) => { this.mouseDown(ev); });\n        document.addEventListener(\"touchend\", (ev) => { this.mouseUp1(ev); });\n        document.addEventListener(\"touchmove\", (ev) => { this.mouseMove1(ev); });\n        document.addEventListener('keydown', (event) => { this.keydownMap(event); });\n    }\n    setTarget(target) {\n        console.log(\"user input set target\");\n        __classPrivateFieldSet(this, _UserInputs_target, target, \"f\");\n        __classPrivateFieldGet(this, _UserInputs_controller, \"f\").setTarget(target);\n    }\n}\nexports.UserInputs = UserInputs;\n_UserInputs_application = new WeakMap(), _UserInputs_drag = new WeakMap(), _UserInputs_oldX = new WeakMap(), _UserInputs_oldY = new WeakMap(), _UserInputs_target = new WeakMap(), _UserInputs_controller = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/controls/user-inputs.ts?");

/***/ }),

/***/ "./src/ts/geometry/angle/angle.ts":
/*!****************************************!*\
  !*** ./src/ts/geometry/angle/angle.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Angle_value, _Angle_unit;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.degree = exports.radians = exports.deg2Rad = exports.rad2Deg = exports.angle = exports.Angle = exports.AngleUnit = void 0;\nvar AngleUnit;\n(function (AngleUnit) {\n    AngleUnit[\"RAD\"] = \"rad\";\n    AngleUnit[\"DEG\"] = \"deg\";\n})(AngleUnit = exports.AngleUnit || (exports.AngleUnit = {}));\nclass Angle {\n    constructor(value, unit) {\n        _Angle_value.set(this, void 0);\n        _Angle_unit.set(this, void 0);\n        __classPrivateFieldSet(this, _Angle_value, value, \"f\");\n        __classPrivateFieldSet(this, _Angle_unit, unit, \"f\");\n    }\n    /**\n     * Returns the value of this angle\n     * @return {number} the value of this angle\n     */\n    getValue() {\n        return __classPrivateFieldGet(this, _Angle_value, \"f\");\n    }\n    /**\n     * Returns the value of this angle in the desired unit\n     * @param {AngleUnit} unit the desired unit of the value of this angle\n     * @return {number} the value of this angle\n     */\n    getValueIn(unit) {\n        if (__classPrivateFieldGet(this, _Angle_unit, \"f\") == unit)\n            return __classPrivateFieldGet(this, _Angle_value, \"f\");\n        return this.cloneAndConvert(unit).getValue();\n    }\n    /**\n     * Sets the value of this angle preserving the unit\n     * @param {number} value the value of the angle\n     */\n    setValue(value) {\n        __classPrivateFieldSet(this, _Angle_value, value, \"f\");\n    }\n    /**\n     * Gets the unit of this angle\n     * @return the unit of this angle\n     */\n    getUnit() {\n        return __classPrivateFieldGet(this, _Angle_unit, \"f\");\n    }\n    /**\n     * Converts this angle to the desired unit.\n     * **The conversion is internal** so this object will be updated\n     * with the desired unit and the value will be automatically converted.\n     *\n     * If it's needed a copy of this angle with the modified unit, please consider\n     * using `copyAndConvert()` instead.\n     * This method returns this angle\n     * @param {AngleUnit} unit the desired target unit\n     * @return {Angle} this angle\n     */\n    convert(unit) {\n        if (__classPrivateFieldGet(this, _Angle_unit, \"f\") != unit) {\n            if (__classPrivateFieldGet(this, _Angle_unit, \"f\") == AngleUnit.RAD && unit == AngleUnit.DEG) {\n                __classPrivateFieldSet(this, _Angle_value, rad2Deg(__classPrivateFieldGet(this, _Angle_value, \"f\")), \"f\");\n            }\n            else if (__classPrivateFieldGet(this, _Angle_unit, \"f\") == AngleUnit.DEG && unit == AngleUnit.RAD) {\n                __classPrivateFieldSet(this, _Angle_value, deg2Rad(__classPrivateFieldGet(this, _Angle_value, \"f\")), \"f\");\n            }\n            __classPrivateFieldSet(this, _Angle_unit, unit, \"f\");\n        }\n        return this;\n    }\n    clone() {\n        return new Angle(__classPrivateFieldGet(this, _Angle_value, \"f\"), __classPrivateFieldGet(this, _Angle_unit, \"f\"));\n    }\n    /**\n     * Clones this angle and convert it to the desired unit\n     * @param {AngleUnit} unit the desired unit of the angle\n     * @return {Angle} the clone converted to the desired unit\n     */\n    cloneAndConvert(unit) {\n        return this.clone().convert(unit);\n    }\n    /**\n     * Aligns this angle to unit of measurement of the other angle.\n     * This method basically converts this angle to unit of measure of the given one and\n     * returns this angle after the conversion\n     * @param {Angle} other the other angle\n     * @return {Angle} this angle after the alignment\n     */\n    alignWith(other) {\n        return this.convert(other.getUnit());\n    }\n    /**\n     * Checks if the `other` object is an `Angle` *equals* to this.\n     * The equality is checked considering also the `unit, so\n     * @param other\n     */\n    equals(other) {\n        if (other != undefined) {\n            if (other instanceof Angle) {\n                if (__classPrivateFieldGet(this, _Angle_unit, \"f\") !== __classPrivateFieldGet(other, _Angle_unit, \"f\")) {\n                    other = other.cloneAndConvert(__classPrivateFieldGet(this, _Angle_unit, \"f\"));\n                    return __classPrivateFieldGet(other, _Angle_unit, \"f\") == __classPrivateFieldGet(this, _Angle_unit, \"f\") && __classPrivateFieldGet(other, _Angle_value, \"f\") == __classPrivateFieldGet(this, _Angle_value, \"f\");\n                }\n            }\n        }\n        return false;\n    }\n    toString() {\n        return __classPrivateFieldGet(this, _Angle_value, \"f\") + \" \" + __classPrivateFieldGet(this, _Angle_unit, \"f\");\n    }\n    add(value, unit) {\n        if (typeof value == \"number\") {\n            if (unit == undefined) {\n                unit = __classPrivateFieldGet(this, _Angle_unit, \"f\");\n            }\n            value = new Angle(value, unit).convert(__classPrivateFieldGet(this, _Angle_unit, \"f\"));\n        }\n        else {\n            value = value.cloneAndConvert(__classPrivateFieldGet(this, _Angle_unit, \"f\"));\n        }\n        __classPrivateFieldSet(this, _Angle_value, __classPrivateFieldGet(this, _Angle_value, \"f\") + __classPrivateFieldGet(value, _Angle_value, \"f\"), \"f\");\n        return this;\n    }\n    subtract(value, unit) {\n        if (typeof value == \"number\") {\n            if (unit == undefined) {\n                unit = __classPrivateFieldGet(this, _Angle_unit, \"f\");\n            }\n            value = new Angle(value, unit).convert(__classPrivateFieldGet(this, _Angle_unit, \"f\"));\n        }\n        else {\n            value = value.cloneAndConvert(__classPrivateFieldGet(this, _Angle_unit, \"f\"));\n        }\n        __classPrivateFieldSet(this, _Angle_value, __classPrivateFieldGet(this, _Angle_value, \"f\") - __classPrivateFieldGet(value, _Angle_value, \"f\"), \"f\");\n        return this;\n    }\n    /**\n     * Multiply the internal value of this angle by the given `factor`.<br>\n     * **This method modify the internal value of this angle**, putting the result\n     * of the operation into the `value` of this angle.\n     * @param {number} factor the factor to be used for the multiplication\n     * @return {Angle} this angle after the multiplication\n     */\n    multiply(factor) {\n        __classPrivateFieldSet(this, _Angle_value, __classPrivateFieldGet(this, _Angle_value, \"f\") * factor, \"f\");\n        return this;\n    }\n    /**\n     * Divide the internal value of this angle by the given `factor`.<br>\n     * **This method modify the internal value of this angle**, putting the result\n     * of the operation into the `value` of this angle.\n     * @param {number} factor the factor to be used for the division\n     * @return {Angle} this angle after the division\n     */\n    divide(factor) {\n        __classPrivateFieldSet(this, _Angle_value, __classPrivateFieldGet(this, _Angle_value, \"f\") * factor, \"f\");\n        return this;\n    }\n}\nexports.Angle = Angle;\n_Angle_value = new WeakMap(), _Angle_unit = new WeakMap();\n/**\n * Creates and return a new angle given a value and a unit.\n * The default unit is *radians*\n * @param {number} value the value of the angle\n * @param {AngleUnit} unit the unit of measurement of the angle (*radians* ad default)\n * @return {Angle} the new angle\n */\nfunction angle(value, unit = AngleUnit.RAD) {\n    return new Angle(value, unit);\n}\nexports.angle = angle;\n/**\n * Converts an angle in radians to degree\n * @param {number} angle the value of the angle in radians\n * @return {number} the value of the angle in degree\n */\nfunction rad2Deg(angle) {\n    return (180 * angle) / Math.PI;\n}\nexports.rad2Deg = rad2Deg;\n/**\n * Converts an angle in degree to radians\n * @param {number} angle the value of the angle in degree\n * @return {number} the value of the angle in radians\n */\nfunction deg2Rad(angle) {\n    return (Math.PI * angle) / 180;\n}\nexports.deg2Rad = deg2Rad;\n/**\n * Creates and returns a new angle in *radians* with the given value\n * @param {number} value the value of the angle in *radians*\n * @return {Angle} the new angle in radians\n */\nfunction radians(value) {\n    return angle(value, AngleUnit.RAD);\n}\nexports.radians = radians;\n/**\n * Creates and returns a new angle in *degree* with the given value\n * @param {number} value the value of the angle in *degree*\n * @return {Angle} the new angle in radians\n */\nfunction degree(value) {\n    return angle(value, AngleUnit.DEG);\n}\nexports.degree = degree;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/angle/angle.ts?");

/***/ }),

/***/ "./src/ts/geometry/axis.ts":
/*!*********************************!*\
  !*** ./src/ts/geometry/axis.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Axis = void 0;\nvar Axis;\n(function (Axis) {\n    Axis[\"X\"] = \"X\";\n    Axis[\"Y\"] = \"Y\";\n    Axis[\"Z\"] = \"Z\";\n})(Axis = exports.Axis || (exports.Axis = {}));\n\n\n//# sourceURL=webpack:///./src/ts/geometry/axis.ts?");

/***/ }),

/***/ "./src/ts/geometry/data/performed-polar-rotation.ts":
/*!**********************************************************!*\
  !*** ./src/ts/geometry/data/performed-polar-rotation.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PerformedPolarRotationBuilder = exports.PerformedPolarRotation = void 0;\nconst triple_1 = __webpack_require__(/*! ../../types/triple */ \"./src/ts/types/triple.ts\");\nclass PerformedPolarRotation {\n    constructor(who, from, to, delta = null) {\n        this.who = who;\n        this.from = from;\n        this.to = to;\n        if (delta == undefined) {\n            this.delta = (0, triple_1.trioOf)(to.getFirst().clone().subtract(from.getFirst()), to.getSecond().clone().subtract(from.getSecond()), to.getThird().clone().subtract(from.getThird()));\n        }\n        else {\n            this.delta = delta;\n        }\n    }\n    /**\n     * Applies the given `block` to this object, then returns this object\n     * @param {(translation: PerformedPolarRotation) => void} block the function to apply to this object\n     * @return {PerformedPolarRotation} this object\n     */\n    apply(block) {\n        block(this);\n        return this;\n    }\n    /**\n     * Applies the given `block` to this object, then returns the result\n     * of the `block` invocation\n     * @param {(translation: PerformedPolarRotation) => R} block the function to apply to this object\n     * @return {R} the result of the `block` invocation\n     */\n    map(block) {\n        return block(this);\n    }\n}\nexports.PerformedPolarRotation = PerformedPolarRotation;\nclass PerformedPolarRotationBuilder {\n    constructor() {\n        this.who = undefined;\n        this.from = undefined;\n        this.to = undefined;\n        this.delta = undefined;\n    }\n    /**\n     * Builds a new `PerformedPolarRotation` object throwing an error if one of the required fields is missing\n     * @returns {PerformedPolarRotation} the built object\n     * @throws {Error} if one of the required fields is missing\n     */\n    build() {\n        if (this.who == undefined) {\n            throw new Error(\"The subject of the rotation is not defined\");\n        }\n        if (this.from == undefined) {\n            throw new Error(\"The initial rotation of the subject is not defined\");\n        }\n        if (this.to == undefined) {\n            throw new Error(\"The final rotation of the subject is not defined\");\n        }\n        return new PerformedPolarRotation(this.who, this.from, this.to, this.delta);\n    }\n    /**\n     * Clears the builder, setting all the fields to `undefined` except the `who` field\n     * @returns {PerformedPolarRotationBuilder} this builder\n     */\n    clear() {\n        this.from = undefined;\n        this.to = undefined;\n        this.delta = undefined;\n        return this;\n    }\n}\nexports.PerformedPolarRotationBuilder = PerformedPolarRotationBuilder;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/data/performed-polar-rotation.ts?");

/***/ }),

/***/ "./src/ts/geometry/data/performed-scale.ts":
/*!*************************************************!*\
  !*** ./src/ts/geometry/data/performed-scale.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PerformedScaleBuilder = void 0;\nconst number_trio_1 = __webpack_require__(/*! ../../types/numbers/number-trio */ \"./src/ts/types/numbers/number-trio.ts\");\nclass PerformedScale {\n    constructor(who, from, to, coefficients = null) {\n        this.who = who;\n        this.from = from;\n        this.to = to;\n        if (coefficients == undefined) {\n            this.coefficients = (0, number_trio_1.numberTrio)(to.getFirst() / from.getFirst(), to.getSecond() / from.getSecond(), to.getThird() / from.getThird());\n        }\n        else {\n            this.coefficients = coefficients;\n        }\n    }\n    /**\n     * Applies the given `block` to this object, then returns this object\n     * @param {(translation: PerformedScale) => void} block the function to apply to this object\n     * @return {PerformedScale} this object\n     */\n    apply(block) {\n        block(this);\n        return this;\n    }\n    /**\n     * Applies the given `block` to this object, then returns the result\n     * of the `block` invocation\n     * @param {(translation: PerformedTranslation) => R} block the function to apply to this object\n     * @return {R} the result of the `block` invocation\n     */\n    map(block) {\n        return block(this);\n    }\n}\nexports[\"default\"] = PerformedScale;\nclass PerformedScaleBuilder {\n    constructor() {\n        this.who = undefined;\n        this.from = undefined;\n        this.to = undefined;\n        this.coefficients = undefined;\n    }\n    /**\n     * Builds a new `PerformedScale` object throwing an error if one of the required fields is missing\n     * @returns {PerformedScale} the built `PerformedScale` object\n     * @throws {Error} if one of the required fields is missing\n     */\n    build() {\n        if (this.who == undefined) {\n            throw new Error(\"The subject of the scaling is not defined\");\n        }\n        if (this.from == undefined) {\n            throw new Error(\"The scale factors of the subject before the scaling are not defined\");\n        }\n        if (this.to == undefined) {\n            throw new Error(\"The scale factors of the subject after the scaling are not defined\");\n        }\n        return new PerformedScale(this.who, this.from, this.to, this.coefficients);\n    }\n    /**\n     * Clears the builder, setting all the fields to `undefined` except the `who` field\n     * @returns {PerformedScaleBuilder} this builder\n     */\n    clear() {\n        this.from = undefined;\n        this.to = undefined;\n        this.coefficients = undefined;\n        return this;\n    }\n}\nexports.PerformedScaleBuilder = PerformedScaleBuilder;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/data/performed-scale.ts?");

/***/ }),

/***/ "./src/ts/geometry/data/performed-translation.ts":
/*!*******************************************************!*\
  !*** ./src/ts/geometry/data/performed-translation.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PerformedTranslationBuilder = void 0;\nconst number_trio_1 = __webpack_require__(/*! ../../types/numbers/number-trio */ \"./src/ts/types/numbers/number-trio.ts\");\nclass PerformedTranslation {\n    constructor(who, from, to, translationVector = null) {\n        this.who = who;\n        this.from = from;\n        this.to = to;\n        if (translationVector == undefined) {\n            this.translationVector = (0, number_trio_1.numberTrio)(to.getX() - from.getX(), to.getY() - from.getY(), to.getZ() - from.getZ());\n        }\n        else {\n            this.translationVector = translationVector;\n        }\n    }\n    /**\n     * Applies the given `block` to this object, then returns this object\n     * @param {(translation: PerformedTranslation) => void} block the function to apply to this object\n     * @return {PerformedTranslation} this object\n     */\n    apply(block) {\n        block(this);\n        return this;\n    }\n    /**\n     * Applies the given `block` to this object, then returns the result\n     * of the `block` invocation\n     * @param {(translation: PerformedTranslation) => R} block the function to apply to this object\n     * @return {R} the result of the `block` invocation\n     */\n    map(block) {\n        return block(this);\n    }\n}\nexports[\"default\"] = PerformedTranslation;\nclass PerformedTranslationBuilder {\n    constructor() {\n        this.who = undefined;\n        this.from = undefined;\n        this.to = undefined;\n        this.translationVector = undefined;\n    }\n    /**\n     * Builds a new `PerformedTranslation` object throwing an error if one of the required fields is missing\n     * @returns {PerformedTranslation} the built object\n     * @throws {Error} if one of the required fields is missing\n     */\n    build() {\n        if (this.who == undefined) {\n            throw new Error(\"The subject of the translation is undefined\");\n        }\n        if (this.from == undefined) {\n            throw new Error(\"The initial position of the translation is undefined\");\n        }\n        if (this.to == undefined) {\n            throw new Error(\"The final position of the translation is undefined\");\n        }\n        return new PerformedTranslation(this.who, this.from, this.to, this.translationVector);\n    }\n    /**\n     * Clears the builder, resetting all the fields to their default value except the `who` field\n     * @return {PerformedTranslationBuilder} this builder\n     */\n    clear() {\n        this.from = undefined;\n        this.to = undefined;\n        this.translationVector = undefined;\n        return this;\n    }\n}\nexports.PerformedTranslationBuilder = PerformedTranslationBuilder;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/data/performed-translation.ts?");

/***/ }),

/***/ "./src/ts/geometry/limits/exceptions/position-out-of-limit-exception.ts":
/*!******************************************************************************!*\
  !*** ./src/ts/geometry/limits/exceptions/position-out-of-limit-exception.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PositionOutOfLimitException = void 0;\n/**\n * The exception for a position that is out of limits\n */\nclass PositionOutOfLimitException extends Error {\n    constructor(point) {\n        super(\"the position \" + point.toString() + \" is out of limit\");\n        this.position = point;\n        Object.setPrototypeOf(this, PositionOutOfLimitException.prototype);\n    }\n}\nexports.PositionOutOfLimitException = PositionOutOfLimitException;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/limits/exceptions/position-out-of-limit-exception.ts?");

/***/ }),

/***/ "./src/ts/geometry/limits/limits-checker.ts":
/*!**************************************************!*\
  !*** ./src/ts/geometry/limits/limits-checker.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LimitsChecker = void 0;\nconst position_out_of_limit_exception_1 = __webpack_require__(/*! ./exceptions/position-out-of-limit-exception */ \"./src/ts/geometry/limits/exceptions/position-out-of-limit-exception.ts\");\n/**\n * A component able to check if a *position* (represented by a 3D point) is valid inside\n * a limited geometrical domain\n */\nclass LimitsChecker {\n    /**\n     * Checks if the given `position` is in the limits returning a `boolean`.\n     * This method also **allows to throw an exception** instead of returning a result by setting\n     * the `throwError` parameter\n     * @param {Point3D} position the position to check for\n     * @param {boolean} throwError a flag that, if `true`, make this method throwing\n     * an error instead of returning the result\n     * @return {boolean} `true` if the position is valid (is inside the limit)\n     * @throws {PositionOutOfLimitException} if the position is not in the limits and `throwError` is set to `true`\n     */\n    checkOrThrow(position, throwError) {\n        let res = this.isInLimits(position);\n        if (throwError && !res)\n            throw new position_out_of_limit_exception_1.PositionOutOfLimitException(position);\n        return res;\n    }\n    /**\n     * Executes the given `block` with the given `position` if this is in the limits, then returns\n     * this checker. If the position is not in the limits, nothing is performed\n     * @param {Point3D} position the position\n     * @param {(position: Point3D) => void} block the function to be executed if the `position` is in the limits\n     * @return this limit checker\n     */\n    ifInLimits(position, block) {\n        if (this.isInLimits(position))\n            block(position);\n        return this;\n    }\n    /**\n     * Executes the given `block` with the given `position` if this is **not** in the limits, then returns\n     * this checker. If the position is in the limits, nothing is performed\n     * @param {Point3D} position the position\n     * @param {(position: Point3D) => void} block the function to be executed if the `position` is **out** of the limits\n     * @return this limit checker\n     */\n    ifOutOfLimits(position, block) {\n        if (this.isOutOfLimits(position))\n            block(position);\n        return this;\n    }\n    /**\n     * Applies the given `block` with `this` as argument, then return `this`\n     * @param {(limitChecker: LimitsChecker) => void} block the function to be executed\n     * @return `this` object\n     */\n    apply(block) {\n        block(this);\n        return this;\n    }\n    /**\n     * Calls the specified function `block` with this value as its argument and returns its result.\n     * @param {(limitChecked: LimitsChecker) => R} block the function to be executed with this object\n     * @return {R} the result of `block`\n     */\n    map(block) {\n        return block(this);\n    }\n}\nexports.LimitsChecker = LimitsChecker;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/limits/limits-checker.ts?");

/***/ }),

/***/ "./src/ts/geometry/limits/limits-checkers.ts":
/*!***************************************************!*\
  !*** ./src/ts/geometry/limits/limits-checkers.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LimitsCheckers = void 0;\nconst unlimited_limit_checker_1 = __webpack_require__(/*! ./unlimited-limit-checker */ \"./src/ts/geometry/limits/unlimited-limit-checker.ts\");\nconst linear_limit_checker_1 = __webpack_require__(/*! ./linear-limit-checker */ \"./src/ts/geometry/limits/linear-limit-checker.ts\");\nclass LimitsCheckers {\n    /**\n     * Creates and return a `LimitChecked` returns always 'true' when calling its 'isInLimits'.\n     * This means that this checker allows every position\n     * @return {LimitsChecker} the new created `LimitChecker`\n     */\n    static unlimited() {\n        return new unlimited_limit_checker_1.UnlimitedLimitChecker();\n    }\n    /**\n     * Creates a linear limit checker that is able to check if a position is inside\n     * a parallelepiped\n     * @param {number} xMin the minimum value of the x coordinate a position can have\n     * @param {number} xMax the maximum value of the x coordinate a position can have\n     * @param {number} yMin the minimum value of the y coordinate a position can have\n     * @param {number} yMax the maximum value of the y coordinate a position can have\n     * @param {number} zMin the minimum value of the z coordinate a position can have\n     * @param {number} zMax the maximum value of the z coordinate a position can have\n     * @return {LimitsChecker} the new created `LimitChecker`\n     */\n    static linear(xMin, xMax, yMin, yMax, zMin, zMax) {\n        return new linear_limit_checker_1.LinearLimitChecker(xMin, xMax, yMin, yMax, zMin, zMax);\n    }\n}\nexports.LimitsCheckers = LimitsCheckers;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/limits/limits-checkers.ts?");

/***/ }),

/***/ "./src/ts/geometry/limits/linear-limit-checker.ts":
/*!********************************************************!*\
  !*** ./src/ts/geometry/limits/linear-limit-checker.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LinearLimitChecker_xLimits, _LinearLimitChecker_yLimits, _LinearLimitChecker_zLimits;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinearLimitChecker = void 0;\nconst number_couple_1 = __webpack_require__(/*! ../../types/numbers/number-couple */ \"./src/ts/types/numbers/number-couple.ts\");\nconst limits_checker_1 = __webpack_require__(/*! ./limits-checker */ \"./src/ts/geometry/limits/limits-checker.ts\");\n/**\n * The `LimitChecker` implementation that is able to check if a position is inside\n * a parallelepiped\n */\nclass LinearLimitChecker extends limits_checker_1.LimitsChecker {\n    /**\n     * Creates a linear limit checker\n     * @param {number} xMin the minimum value of the x coordinate a position can have\n     * @param {number} xMax the maximum value of the x coordinate a position can have\n     * @param {number} yMin the minimum value of the y coordinate a position can have\n     * @param {number} yMax the maximum value of the y coordinate a position can have\n     * @param {number} zMin the minimum value of the z coordinate a position can have\n     * @param {number} zMax the maximum value of the z coordinate a position can have\n     */\n    constructor(xMin, xMax, yMin, yMax, zMin, zMax) {\n        super();\n        _LinearLimitChecker_xLimits.set(this, void 0);\n        _LinearLimitChecker_yLimits.set(this, void 0);\n        _LinearLimitChecker_zLimits.set(this, void 0);\n        __classPrivateFieldSet(this, _LinearLimitChecker_xLimits, (0, number_couple_1.numberCouple)(xMin, xMax), \"f\");\n        __classPrivateFieldSet(this, _LinearLimitChecker_yLimits, (0, number_couple_1.numberCouple)(yMin, yMax), \"f\");\n        __classPrivateFieldSet(this, _LinearLimitChecker_zLimits, (0, number_couple_1.numberCouple)(zMin, zMax), \"f\");\n    }\n    isInLimits(position) {\n        return __classPrivateFieldGet(this, _LinearLimitChecker_xLimits, \"f\").isBetween(position.getX()) && __classPrivateFieldGet(this, _LinearLimitChecker_yLimits, \"f\").isBetween(position.getY()) &&\n            __classPrivateFieldGet(this, _LinearLimitChecker_zLimits, \"f\").isBetween(position.getZ());\n    }\n    isOutOfLimits(position) {\n        return !this.isInLimits(position);\n    }\n}\nexports.LinearLimitChecker = LinearLimitChecker;\n_LinearLimitChecker_xLimits = new WeakMap(), _LinearLimitChecker_yLimits = new WeakMap(), _LinearLimitChecker_zLimits = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/geometry/limits/linear-limit-checker.ts?");

/***/ }),

/***/ "./src/ts/geometry/limits/unlimited-limit-checker.ts":
/*!***********************************************************!*\
  !*** ./src/ts/geometry/limits/unlimited-limit-checker.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnlimitedLimitChecker = void 0;\nconst limits_checker_1 = __webpack_require__(/*! ./limits-checker */ \"./src/ts/geometry/limits/limits-checker.ts\");\n/**\n * A `LimitChecker` that returns always 'true' when calling its 'isInLimits'.\n * So, this represents \"limits that are unlimited\", means that all positions are allowed\n */\nclass UnlimitedLimitChecker extends limits_checker_1.LimitsChecker {\n    isInLimits(position) {\n        return true;\n    }\n    isOutOfLimits(position) {\n        return false;\n    }\n}\nexports.UnlimitedLimitChecker = UnlimitedLimitChecker;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/limits/unlimited-limit-checker.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/abstract-matrix.ts":
/*!***************************************************!*\
  !*** ./src/ts/geometry/matrix/abstract-matrix.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbstractMatrix = void 0;\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst illegal_column_index_exception_1 = __webpack_require__(/*! ./exceptions/illegal-column-index-exception */ \"./src/ts/geometry/matrix/exceptions/illegal-column-index-exception.ts\");\nconst illegal_row_index_exception_1 = __webpack_require__(/*! ./exceptions/illegal-row-index-exception */ \"./src/ts/geometry/matrix/exceptions/illegal-row-index-exception.ts\");\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../../types/exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nconst pair_1 = __webpack_require__(/*! ../../types/pair */ \"./src/ts/types/pair.ts\");\nclass AbstractMatrix {\n    checkValidColumnIndex(columnIndex, throwError) {\n        if (throwError == undefined) {\n            throwError = false;\n        }\n        if (columnIndex < 0 || columnIndex >= this.columnSize()) {\n            if (throwError) {\n                throw new illegal_column_index_exception_1.IllegalColumnIndexException(columnIndex, this.columnSize() - 1);\n            }\n            return true;\n        }\n    }\n    checkValidIndexes(rowIndex, columnIndex, throwError) {\n        if (throwError == undefined) {\n            throwError = false;\n        }\n        if (this.checkValidRowIndex(rowIndex, throwError))\n            return this.checkValidColumnIndex(columnIndex, throwError);\n        return false;\n    }\n    checkValidRowIndex(rowIndex, throwError) {\n        if (throwError == undefined) {\n            throwError = false;\n        }\n        if (rowIndex < 0 || rowIndex >= this.rowSize()) {\n            if (throwError) {\n                throw new illegal_row_index_exception_1.IllegalRowIndexException(rowIndex, this.rowSize() - 1);\n            }\n            return true;\n        }\n    }\n    clone(rowIndexesToRemove, columnIndexesToRemove) {\n        if (rowIndexesToRemove == undefined) {\n            rowIndexesToRemove = [];\n        }\n        if (columnIndexesToRemove == undefined) {\n            columnIndexesToRemove = [];\n        }\n        let res;\n        if (rowIndexesToRemove.length == 0 && columnIndexesToRemove.length == 0) {\n            /* Normal Clone *************************************************** */\n            res = this.getFactory().createMatrix(this.rowSize(), this.columnSize());\n            for (let r = 0; r < this.rowSize(); r++) {\n                for (let c = 0; c < this.columnSize(); c++) {\n                    res.set(this.get(r, c), r, c);\n                }\n            }\n        }\n        else {\n            /* Clone with cuts ************************************************ */\n            res = this.getFactory().createMatrix(this.rowSize() - rowIndexesToRemove.length, this.columnSize() - columnIndexesToRemove.length);\n            let rR = 0;\n            let cR = 0;\n            for (let r = 0; r < this.rowSize(); r++) {\n                if (!rowIndexesToRemove.includes(r)) {\n                    cR = 0;\n                    for (let c = 0; r < this.columnSize(); c++) {\n                        if (!columnIndexesToRemove.includes(c)) {\n                            res.set(this.get(r, c), rR, cR);\n                            cR++;\n                        }\n                    }\n                    rR++;\n                }\n            }\n        }\n        return res;\n    }\n    elementSize() {\n        return this.rowSize() * this.columnSize();\n    }\n    equals(other) {\n        if (other != null) {\n            if (other instanceof AbstractMatrix) {\n                if (this.sameStructureOf(other)) {\n                    for (let row = 0; row < this.rowSize(); row++) {\n                        for (let col = 0; col < this.columnSize(); col++) {\n                            if (this.get(row, col) !== other.get(row, col)) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    flatten(flatType) {\n        if (flatType == undefined) {\n            flatType = matrix_1.FlatType.BY_ROWS;\n        }\n        let res = Array(this.elementSize());\n        switch (flatType) {\n            case matrix_1.FlatType.BY_ROWS: {\n                for (let r = 0; r < this.rowSize(); r++) {\n                    for (let c = 0; c < this.columnSize(); c++) {\n                        res[r * this.columnSize() + c] = this.get(r, c);\n                    }\n                }\n                break;\n            }\n            case matrix_1.FlatType.BY_COLUMNS: {\n                for (let r = 0; r < this.rowSize(); r++) {\n                    for (let c = 0; c < this.columnSize(); c++) {\n                        res[c * this.rowSize() + r] = this.get(r, c);\n                    }\n                }\n                break;\n            }\n        }\n        return res;\n    }\n    forEachColumn(block) {\n        for (let c = 0; c < this.columnSize(); c++) {\n            block(this.getColumn(c), c);\n        }\n    }\n    forEachElement(block) {\n        for (let r = 0; r < this.rowSize(); r++) {\n            for (let c = 0; c < this.columnSize(); c++) {\n                block(this.get(r, c), r, c);\n            }\n        }\n    }\n    forEachRow(block) {\n        for (let r = 0; r < this.rowSize(); r++) {\n            block(this.getRow(r), r);\n        }\n    }\n    getCofactor(rowIndex, columnIndex) {\n        this.checkValidIndexes(rowIndex, columnIndex, true);\n        return Math.pow(-1, rowIndex + columnIndex) * (this.getMinor(rowIndex, columnIndex).determinant());\n    }\n    getCofactorMatrix() {\n        let res = this.getFactory().createNumberMatrix(this.rowSize(), this.columnSize());\n        for (let r = 0; r < this.rowSize(); r++) {\n            for (let c = 0; c < this.columnSize(); c++) {\n                res.set(this.getCofactor(r, c), r, c);\n            }\n        }\n        return res;\n    }\n    getMinor(rowIndex, columnIndex) {\n        this.checkValidIndexes(rowIndex, columnIndex, true);\n        let data = (0, matrix_1.matrixData)(this.rowSize() - 1, this.columnSize() - 1);\n        let rR = 0;\n        let cR = 0;\n        for (let r = 0; r < this.rowSize(); r++) {\n            if (r != rowIndex) {\n                cR = 0;\n                for (let c = 0; c < this.columnSize(); c++) {\n                    if (c != columnIndex) {\n                        data[rR][cR] = this.get(r, c);\n                        cR++;\n                    }\n                }\n                rR++;\n            }\n        }\n        return this.getFactory().createMatrix(data);\n    }\n    isDiagonal() {\n        let element;\n        for (let r = 0; r < this.rowSize(); r++) {\n            for (let c = 0; c < this.columnSize(); c++) {\n                if (r != c) {\n                    element = this.get(r, c);\n                    if (element != null && element != 0)\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n    isInvertible() {\n        return this.isSquared() && this.determinant() != 0;\n    }\n    isLowerTriangular() {\n        let element;\n        for (let r = 0; r < this.rowSize(); r++) {\n            for (let c = 0; c < this.columnSize(); c++) {\n                if (r < c) {\n                    element = this.get(r, c);\n                    if (element != null && element != 0)\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n    isSquared() {\n        return this.rowSize() === this.columnSize();\n    }\n    isTriangular() {\n        return this.isUpperTriangular() || this.isLowerTriangular();\n    }\n    isUpperTriangular() {\n        let element;\n        for (let r = 0; r < this.rowSize(); r++) {\n            for (let c = 0; c < this.columnSize(); c++) {\n                if (r > c) {\n                    element = this.get(r, c);\n                    if (element != null && element != 0)\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n    mapColumnByColumn(mapper) {\n        let res = this.getFactory().createMatrix(this.rowSize(), this.columnSize());\n        for (let c = 0; c < res.columnSize(); c++) {\n            res.setColumn(mapper(this.getColumn(c), c), c);\n        }\n        return res;\n    }\n    mapElementByElement(mapper) {\n        let res = this.getFactory().createMatrix(this.rowSize(), this.columnSize());\n        for (let r = 0; r < res.rowSize(); r++) {\n            for (let c = 0; c < res.columnSize(); c++) {\n                res.set(mapper(this.get(r, c), r, c), r, c);\n            }\n        }\n        return res;\n    }\n    mapRowByRow(mapper) {\n        let res = this.getFactory().createMatrix(this.rowSize(), this.columnSize());\n        for (let r = 0; r < res.rowSize(); r++) {\n            res.setRow(mapper(this.getRow(r), r), r);\n        }\n        return res;\n    }\n    sameStructureOf(other) {\n        return this.rowSize() == other.rowSize() && this.columnSize() == other.columnSize();\n    }\n    size() {\n        return (0, pair_1.coupleOf)(this.rowSize(), this.columnSize());\n    }\n    subMatrix(topRow, leftColumn, bottomRow, rightColumn) {\n        if (bottomRow == undefined) {\n            bottomRow = this.rowSize() - 1;\n        }\n        if (rightColumn == undefined) {\n            rightColumn = this.columnSize() - 1;\n        }\n        // Check all >= 0\n        if (topRow < 0)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"top row [\" + topRow + \"] MUST be greater than 0\");\n        if (bottomRow < 0)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"bottom row [\" + bottomRow + \"] MUST be greater than 0\");\n        if (rightColumn < 0)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"right column [\" + rightColumn + \"] MUST be greater than 0\");\n        if (leftColumn < 0)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"left column [\" + leftColumn + \"] MUST be greater than 0\");\n        // Check coherence\n        if (bottomRow < topRow)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"bottom row [\" + bottomRow + \"] must be greater than top row [\" + topRow + \"]\");\n        if (rightColumn < leftColumn)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"right column [\" + rightColumn + \"] must be greater than left column [\" + leftColumn + \"]\");\n        //Check inside matrix\n        if (topRow >= this.rowSize())\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"top row [\" + topRow + \"] MUST NOT go outside the matrix\");\n        if (bottomRow >= this.rowSize())\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"bottom row [\" + bottomRow + \"] MUST NOT go outside the matrix\");\n        if (leftColumn >= this.columnSize())\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"left column [\" + leftColumn + \"] MUST NOT go outside the matrix\");\n        if (rightColumn >= this.columnSize())\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"left column [\" + rightColumn + \"] MUST NOT go outside the matrix\");\n        let res = this.getFactory().createMatrix(bottomRow - topRow + 1, rightColumn - leftColumn + 1);\n        for (let r = topRow; r <= bottomRow; r++) {\n            for (let c = leftColumn; c <= rightColumn; c++) {\n                this.set(this.get(r, c), r - topRow, c - leftColumn);\n            }\n        }\n        return res;\n    }\n    toArrayOfColumns() {\n        let res = new Array();\n        for (let c = 0; c < this.columnSize(); c++) {\n            res.push(this.getColumn(c));\n        }\n        return res;\n    }\n    toArrayOfRows() {\n        let res = new Array();\n        for (let r = 0; r < this.rowSize(); r++) {\n            res.push(this.getRow(r));\n        }\n        return res;\n    }\n    trace() {\n        if (!this.isSquared()) {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"this matrix is not squared [size: \" + this.size().toArray() + \"]\");\n        }\n        let res = 0;\n        for (let i = 0; i < this.rowSize(); i++)\n            res += this.get(i, i);\n        return res;\n    }\n    toString() {\n        return this.toArrayOfRows().toString();\n    }\n}\nexports.AbstractMatrix = AbstractMatrix;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/abstract-matrix.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/exceptions/illegal-column-index-exception.ts":
/*!*****************************************************************************!*\
  !*** ./src/ts/geometry/matrix/exceptions/illegal-column-index-exception.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IllegalColumnIndexException = void 0;\n/**\n * An exception that is thrown when has been request access to an invalid column\n */\nclass IllegalColumnIndexException extends Error {\n    constructor(triedColumnIndex, maxAllowedColumnIndex = null) {\n        let msg;\n        if (maxAllowedColumnIndex != null) {\n            msg = \"invalid index [\" + triedColumnIndex + \"] for column: the index MUST be between [0] and [\" +\n                maxAllowedColumnIndex + \"]\";\n        }\n        else {\n            msg = \"invalid index [\" + triedColumnIndex + \"]\";\n        }\n        super(msg);\n        Object.setPrototypeOf(this, IllegalColumnIndexException.prototype);\n    }\n}\nexports.IllegalColumnIndexException = IllegalColumnIndexException;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/exceptions/illegal-column-index-exception.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/exceptions/illegal-row-index-exception.ts":
/*!**************************************************************************!*\
  !*** ./src/ts/geometry/matrix/exceptions/illegal-row-index-exception.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IllegalRowIndexException = void 0;\n/**\n * An exception that is thrown when has been request access to an invalid row\n */\nclass IllegalRowIndexException extends Error {\n    constructor(triedRowIndex, maxAllowedRowIndex = null) {\n        let msg;\n        if (maxAllowedRowIndex != null) {\n            msg = \"invalid index [\" + triedRowIndex + \"] for row:  the index MUST be between [0] and [\" +\n                maxAllowedRowIndex + \"]\";\n        }\n        else {\n            msg = \"invalid index [\" + triedRowIndex + \"]\";\n        }\n        super(msg);\n        Object.setPrototypeOf(this, IllegalRowIndexException.prototype);\n    }\n}\nexports.IllegalRowIndexException = IllegalRowIndexException;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/exceptions/illegal-row-index-exception.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/exceptions/invalid-column-exception.ts":
/*!***********************************************************************!*\
  !*** ./src/ts/geometry/matrix/exceptions/invalid-column-exception.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidColumnException = void 0;\nclass InvalidColumnException extends Error {\n    constructor(column, reason) {\n        super(\"invalid column {\" + column + \"}: \" + reason);\n        Object.setPrototypeOf(this, InvalidColumnException.prototype);\n    }\n}\nexports.InvalidColumnException = InvalidColumnException;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/exceptions/invalid-column-exception.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/exceptions/invalid-row-exception.ts":
/*!********************************************************************!*\
  !*** ./src/ts/geometry/matrix/exceptions/invalid-row-exception.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidRowException = void 0;\nclass InvalidRowException extends Error {\n    constructor(row, reason) {\n        super(\"invalid row {\" + row + \"}: \" + reason);\n        Object.setPrototypeOf(this, InvalidRowException.prototype);\n    }\n}\nexports.InvalidRowException = InvalidRowException;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/exceptions/invalid-row-exception.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/exceptions/not-invertible-matrix-exception.ts":
/*!******************************************************************************!*\
  !*** ./src/ts/geometry/matrix/exceptions/not-invertible-matrix-exception.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotInvertibleMatrixException = exports.NotInvertibleReason = void 0;\n/**\n * The reason why is not possible to invert a matrix\n */\nvar NotInvertibleReason;\n(function (NotInvertibleReason) {\n    NotInvertibleReason[NotInvertibleReason[\"NOT_SQUARED\"] = 0] = \"NOT_SQUARED\";\n    NotInvertibleReason[NotInvertibleReason[\"ZERO_DETERMINANT\"] = 1] = \"ZERO_DETERMINANT\";\n})(NotInvertibleReason = exports.NotInvertibleReason || (exports.NotInvertibleReason = {}));\n/**\n * An exception that is thrown when a matrix is not invertible\n */\nclass NotInvertibleMatrixException extends Error {\n    constructor(reason) {\n        let msg = \"this matrix is not invertible: \";\n        switch (reason) {\n            case NotInvertibleReason.NOT_SQUARED: {\n                msg += \"matrix is not squared\";\n                break;\n            }\n            case NotInvertibleReason.ZERO_DETERMINANT: {\n                msg += \"the determinant is 0\";\n                break;\n            }\n        }\n        super(msg);\n        this.reason = reason;\n        Object.setPrototypeOf(this, NotInvertibleMatrixException);\n    }\n}\nexports.NotInvertibleMatrixException = NotInvertibleMatrixException;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/exceptions/not-invertible-matrix-exception.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/frozen-row-based-matrix.ts":
/*!***********************************************************!*\
  !*** ./src/ts/geometry/matrix/frozen-row-based-matrix.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenRowBasedMatrix_data, _FrozenRowBasedMatrix_totRows, _FrozenRowBasedMatrix_totColumns;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrozenRowBasedMatrix = void 0;\nconst abstract_matrix_1 = __webpack_require__(/*! ./abstract-matrix */ \"./src/ts/geometry/matrix/abstract-matrix.ts\");\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst matrix_algebra_1 = __webpack_require__(/*! ./matrix-algebra */ \"./src/ts/geometry/matrix/matrix-algebra.ts\");\nconst invalid_row_exception_1 = __webpack_require__(/*! ./exceptions/invalid-row-exception */ \"./src/ts/geometry/matrix/exceptions/invalid-row-exception.ts\");\nconst arrays_1 = __webpack_require__(/*! ../../types/arrays */ \"./src/ts/types/arrays.ts\");\nconst mutable_row_based_matrix_1 = __webpack_require__(/*! ./mutable-row-based-matrix */ \"./src/ts/geometry/matrix/mutable-row-based-matrix.ts\");\n/**\n * A **frozen** implementation of matrix based on a bi-dimensional array.\n * Every instance of this class **can NOT be modified** and each method that has to modify the\n * internal data *returns a copy* of this matrix with the required modification.\n * This means that the original matrix will never been modified\n */\nclass FrozenRowBasedMatrix extends abstract_matrix_1.AbstractMatrix {\n    constructor(data) {\n        super();\n        _FrozenRowBasedMatrix_data.set(this, void 0);\n        _FrozenRowBasedMatrix_totRows.set(this, void 0);\n        _FrozenRowBasedMatrix_totColumns.set(this, void 0);\n        if (data.length > 0) {\n            (0, matrix_1.checkValidMatrixData)(data, true);\n            __classPrivateFieldSet(this, _FrozenRowBasedMatrix_data, data, \"f\");\n            __classPrivateFieldSet(this, _FrozenRowBasedMatrix_totRows, data.length, \"f\");\n            __classPrivateFieldSet(this, _FrozenRowBasedMatrix_totColumns, data[0].length, \"f\");\n        }\n    }\n    add(other) {\n        if (typeof other == \"number\") {\n            return matrix_algebra_1.MatrixAlgebra.add(this, other);\n        }\n        return matrix_algebra_1.MatrixAlgebra.add(this, other);\n    }\n    addColumn(column) {\n        return new FrozenRowBasedMatrix(arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"), __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"), __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\") + 1));\n    }\n    addRow(row) {\n        if (row.length != __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\")) {\n            throw new invalid_row_exception_1.InvalidRowException(row, \"the row to add has size \" + row.length + \" but \" +\n                \"the matrix has \" + __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\") + \" columns\");\n        }\n        let data = arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"), __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\") + 1, __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"));\n        for (let c = 0; c < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"); c++) {\n            data[__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\")][c] = row[c];\n        }\n        return new FrozenRowBasedMatrix(data);\n    }\n    calculateAndFill(builder) {\n        let data = new Array(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"));\n        for (let r = 0; r < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"); r++) {\n            data[r] = new Array(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"));\n            for (let c = 0; c < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"); c++) {\n                data[r][c] = builder(r, c);\n            }\n        }\n        return new FrozenRowBasedMatrix(data);\n    }\n    columnSize() {\n        return __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\");\n    }\n    determinant() {\n        return matrix_algebra_1.MatrixAlgebra.determinant(this);\n    }\n    divide(other) {\n        if (typeof other == \"number\")\n            return matrix_algebra_1.MatrixAlgebra.divide(this, other);\n        return matrix_algebra_1.MatrixAlgebra.divide(this, other);\n    }\n    fill(value) {\n        let data = new Array(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"));\n        for (let r = 0; r < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"); r++) {\n            data[r] = new Array(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"));\n            for (let c = 0; c < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"); c++) {\n                data[r][c] = value;\n            }\n        }\n        return new FrozenRowBasedMatrix(data);\n    }\n    frozen() {\n        return this;\n    }\n    get(rowIndex, columnIndex) {\n        return __classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\")[rowIndex][columnIndex];\n    }\n    getCharacteristicPolynomial() {\n        return matrix_algebra_1.MatrixAlgebra.characteristicPolynomial(this);\n    }\n    getColumn(columnIndex) {\n        let res = new Array(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"));\n        for (let r = 0; r < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"); r++) {\n            res[r] = __classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\")[r][columnIndex];\n        }\n        return res;\n    }\n    getFactory() {\n        return FrozenRowBasedMatrix.factory;\n    }\n    getRow(rowIndex) {\n        let res = new Array(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"));\n        for (let c = 0; c < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"); c++) {\n            res[c] = __classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\")[rowIndex][c];\n        }\n        return res;\n    }\n    invert() {\n        return matrix_algebra_1.MatrixAlgebra.invert(this);\n    }\n    isFrozen() {\n        return true;\n    }\n    isUnfrozen() {\n        return false;\n    }\n    multiply(other) {\n        if (typeof other == \"number\") {\n            return matrix_algebra_1.MatrixAlgebra.multiply(this, other);\n        }\n        return matrix_algebra_1.MatrixAlgebra.multiply(this, other);\n    }\n    removeColumn() {\n        return new FrozenRowBasedMatrix(arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"), __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"), __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\") - 1));\n    }\n    removeRow() {\n        return new FrozenRowBasedMatrix(arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"), __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\") - 1, __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\")));\n    }\n    rowSize() {\n        return __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\");\n    }\n    set(value, rowIndex, columnIndex) {\n        this.checkValidIndexes(rowIndex, columnIndex);\n        let data = arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"));\n        data[rowIndex][columnIndex] = value;\n        return new FrozenRowBasedMatrix(data);\n    }\n    setColumn(column, columnIndex) {\n        this.checkValidColumnIndex(columnIndex);\n        let data = arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"));\n        for (let r = 0; r < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totRows, \"f\"); r++) {\n            data[r][columnIndex] = column[r];\n        }\n        return new FrozenRowBasedMatrix(data);\n    }\n    setRow(row, rowIndex) {\n        this.checkValidRowIndex(rowIndex);\n        let data = arrays_1.Arrays.clone2(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"));\n        for (let c = 0; c < __classPrivateFieldGet(this, _FrozenRowBasedMatrix_totColumns, \"f\"); c++) {\n            data[rowIndex][c] = row[c];\n        }\n        return new FrozenRowBasedMatrix(data);\n    }\n    subtract(other) {\n        if (typeof other == \"number\") {\n            return matrix_algebra_1.MatrixAlgebra.subtract(this, other);\n        }\n        return matrix_algebra_1.MatrixAlgebra.subtract(this, other);\n    }\n    transpose() {\n        return matrix_algebra_1.MatrixAlgebra.transpose(this);\n    }\n    unfrozen() {\n        return new mutable_row_based_matrix_1.MutableRowBasedMatrix(__classPrivateFieldGet(this, _FrozenRowBasedMatrix_data, \"f\"));\n    }\n}\nexports.FrozenRowBasedMatrix = FrozenRowBasedMatrix;\n_FrozenRowBasedMatrix_data = new WeakMap(), _FrozenRowBasedMatrix_totRows = new WeakMap(), _FrozenRowBasedMatrix_totColumns = new WeakMap();\nFrozenRowBasedMatrix.factory = new class extends matrix_1.MatrixFactory {\n    createMatrix(rows, columns, fill) {\n        if (typeof rows == \"number\") {\n            return new FrozenRowBasedMatrix((0, matrix_1.matrixData)(rows, columns, fill));\n        }\n        else {\n            return new FrozenRowBasedMatrix(rows);\n        }\n    }\n};\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/frozen-row-based-matrix.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/matrix-algebra.ts":
/*!**************************************************!*\
  !*** ./src/ts/geometry/matrix/matrix-algebra.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MatrixAlgebra = void 0;\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../../types/exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst not_invertible_matrix_exception_1 = __webpack_require__(/*! ./exceptions/not-invertible-matrix-exception */ \"./src/ts/geometry/matrix/exceptions/not-invertible-matrix-exception.ts\");\n/**\n * A class with methods to realize operation between matrix following the algebra of matrices\n */\nclass MatrixAlgebra {\n    static add(mat1, mat2OrScalar) {\n        let res;\n        if (typeof mat2OrScalar == \"number\") {\n            let scalar = mat2OrScalar;\n            res = (0, matrix_1.matrix)(mat1.rowSize(), mat1.columnSize());\n            for (let r = 0; r < mat1.rowSize(); r++) {\n                for (let c = 0; c < mat1.columnSize(); c++) {\n                    res.set(mat1.get(r, c) + scalar, r, c);\n                }\n            }\n        }\n        else {\n            let mat2 = mat2OrScalar;\n            if (!mat1.sameStructureOf(mat2)) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"illegal matrix to be added: this matrix has size \" +\n                    mat1.rowSize() + \" x \" + mat1.columnSize() + \" while the argument has \" + mat2.rowSize() +\n                    \" x \" + mat2.columnSize());\n            }\n            res = (0, matrix_1.matrix)(mat1.rowSize(), mat1.columnSize());\n            for (let r = 0; r < mat1.rowSize(); r++) {\n                for (let c = 0; c < mat1.columnSize(); c++) {\n                    res.set(mat1.get(r, c) + mat2.get(r, c), r, c);\n                }\n            }\n        }\n        return res;\n    }\n    static subtract(mat1, mat2OrScalar) {\n        let res;\n        if (typeof mat2OrScalar == \"number\") {\n            let scalar = mat2OrScalar;\n            res = (0, matrix_1.matrix)(mat1.rowSize(), mat1.columnSize());\n            for (let r = 0; r < mat1.rowSize(); r++) {\n                for (let c = 0; c < mat1.columnSize(); c++) {\n                    res.set(mat1.get(r, c) - scalar, r, c);\n                }\n            }\n        }\n        else {\n            let mat2 = mat2OrScalar;\n            if (!mat1.sameStructureOf(mat2)) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"illegal matrix to be added: this matrix has size \" +\n                    mat1.rowSize() + \" x \" + mat1.columnSize() + \" while the argument has \" + mat2.rowSize() +\n                    \" x \" + mat2.columnSize());\n            }\n            res = (0, matrix_1.matrix)(mat1.rowSize(), mat1.columnSize());\n            for (let r = 0; r < mat1.rowSize(); r++) {\n                for (let c = 0; c < mat1.columnSize(); c++) {\n                    res.set(mat1.get(r, c) - mat2.get(r, c), r, c);\n                }\n            }\n        }\n        return res;\n    }\n    static multiply(mat1, mat2OrScalar) {\n        let res;\n        if (typeof mat2OrScalar == \"number\") {\n            let scalar = mat2OrScalar;\n            res = (0, matrix_1.matrix)(mat1.rowSize(), mat1.columnSize());\n            for (let r = 0; r < mat1.rowSize(); r++) {\n                for (let c = 0; c < mat1.columnSize(); c++) {\n                    res.set(mat1.get(r, c) * scalar, r, c);\n                }\n            }\n        }\n        else {\n            let mat2 = mat2OrScalar;\n            if (mat1.columnSize() != mat2.rowSize()) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"illegal matrix to be multiplied: this matrix has columns \" +\n                    mat1.columnSize() + \" while the argument has rows \" + mat2.rowSize());\n            }\n            let data = (0, matrix_1.matrixData)(mat1.rowSize(), mat2.columnSize(), 0);\n            for (let i = 0; i < mat1.rowSize(); i++) {\n                for (let j = 0; j < mat2.columnSize(); j++) {\n                    for (let k = 0; k < mat2.rowSize(); k++) {\n                        data[i][j] += mat1.get(i, k) * mat2.get(k, j);\n                    }\n                }\n            }\n            res = (0, matrix_1.matrix)(data);\n        }\n        return res;\n    }\n    static divide(mat1, mat2OrScalar) {\n        let res;\n        if (typeof mat2OrScalar == \"number\") {\n            let scalar = mat2OrScalar;\n            res = (0, matrix_1.matrix)(mat1.rowSize(), mat1.columnSize());\n            for (let r = 0; r < mat1.rowSize(); r++) {\n                for (let c = 0; c < mat1.columnSize(); c++) {\n                    res.set(mat1.get(r, c) / scalar, r, c);\n                }\n            }\n        }\n        else {\n            let mat2 = mat2OrScalar;\n            if (!mat2.isSquared()) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"illegal matrix: the second matrix MUST be squared\");\n            }\n            res = this.multiply(mat1, this.invert(mat2));\n        }\n        return res;\n    }\n    /**\n     * Returns the transposition of the given matrix\n     * @param {Matrix<T>} mat the original matrix\n     * @return {Matrix<T>} the transposed matrix\n     */\n    static transpose(mat) {\n        let res = (0, matrix_1.matrix)(mat.columnSize(), mat.rowSize());\n        for (let r = 0; r < mat.rowSize(); r++) {\n            for (let c = 0; c < mat.columnSize(); c++) {\n                res.set(mat.get(r, c), c, r);\n            }\n        }\n        return res;\n    }\n    /**\n     * Calculates and returns the determinant of the given matrix\n     * This method will work properly **only if the two matrix contain only\n     * numbers**: this means that the behaviour of this method is not predictable\n     * using different types of matrices and will throw exceptions\n     * @param {NumMatrix} matrix the original matrix\n     * @return {number} the determinant of the matrix\n     * @throws {IllegalArgumentException} if the matrix is not squared (the determinant\n     * is not defined to **non-squared** matrix)\n     */\n    static determinant(matrix) {\n        if (!matrix.isSquared()) {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"this matrix is not squared [size: \" + matrix.size().toArray() +\n                \"]: determinant undefined for non-squared matrix\");\n        }\n        switch (matrix.rowSize()) {\n            case 1: {\n                return matrix.get(0, 0);\n            }\n            case 2: {\n                return matrix.get(0, 0) * matrix.get(1, 1) - matrix.get(0, 1) * matrix.get(1, 0);\n            }\n            case 3: {\n                return matrix.get(0, 0) * (matrix.get(1, 1) * matrix.get(2, 2) - matrix.get(1, 2) * matrix.get(2, 1)) -\n                    matrix.get(0, 1) * (matrix.get(1, 0) * matrix.get(2, 2) - matrix.get(1, 2) * matrix.get(2, 0)) +\n                    matrix.get(0, 2) * (matrix.get(1, 0) * matrix.get(2, 1) - matrix.get(1, 1) * matrix.get(2, 0));\n            }\n            case 4: {\n                return matrix.get(0, 0) * matrix.get(1, 1) * matrix.get(2, 2) * matrix.get(3, 3)\n                    + matrix.get(0, 0) * matrix.get(1, 2) * matrix.get(2, 3) * matrix.get(3, 1)\n                    + matrix.get(0, 0) * matrix.get(1, 3) * matrix.get(2, 1) * matrix.get(3, 2)\n                    - matrix.get(0, 0) * matrix.get(1, 3) * matrix.get(2, 2) * matrix.get(3, 1)\n                    - matrix.get(0, 0) * matrix.get(1, 2) * matrix.get(2, 1) * matrix.get(3, 3)\n                    - matrix.get(0, 0) * matrix.get(1, 1) * matrix.get(2, 3) * matrix.get(3, 2)\n                    - matrix.get(0, 1) * matrix.get(1, 0) * matrix.get(2, 2) * matrix.get(3, 3)\n                    - matrix.get(0, 2) * matrix.get(1, 0) * matrix.get(2, 3) * matrix.get(3, 1)\n                    - matrix.get(0, 3) * matrix.get(1, 0) * matrix.get(2, 1) * matrix.get(3, 2)\n                    + matrix.get(0, 3) * matrix.get(1, 0) * matrix.get(2, 2) * matrix.get(3, 1)\n                    + matrix.get(0, 2) * matrix.get(1, 0) * matrix.get(2, 1) * matrix.get(3, 3)\n                    + matrix.get(0, 1) * matrix.get(1, 0) * matrix.get(2, 3) * matrix.get(3, 2)\n                    + matrix.get(0, 1) * matrix.get(1, 2) * matrix.get(2, 0) * matrix.get(3, 3)\n                    + matrix.get(0, 2) * matrix.get(1, 3) * matrix.get(2, 0) * matrix.get(3, 1)\n                    + matrix.get(0, 3) * matrix.get(1, 1) * matrix.get(2, 0) * matrix.get(3, 2)\n                    - matrix.get(0, 3) * matrix.get(1, 2) * matrix.get(2, 0) * matrix.get(3, 1)\n                    - matrix.get(0, 2) * matrix.get(1, 1) * matrix.get(2, 0) * matrix.get(3, 3)\n                    - matrix.get(0, 1) * matrix.get(1, 3) * matrix.get(2, 0) * matrix.get(3, 2)\n                    - matrix.get(0, 1) * matrix.get(1, 2) * matrix.get(2, 3) * matrix.get(3, 0)\n                    - matrix.get(0, 2) * matrix.get(1, 3) * matrix.get(2, 1) * matrix.get(3, 0)\n                    - matrix.get(0, 3) * matrix.get(1, 1) * matrix.get(2, 2) * matrix.get(3, 0)\n                    + matrix.get(0, 3) * matrix.get(1, 2) * matrix.get(2, 1) * matrix.get(3, 0)\n                    + matrix.get(0, 2) * matrix.get(1, 1) * matrix.get(2, 3) * matrix.get(3, 0)\n                    + matrix.get(0, 1) * matrix.get(1, 3) * matrix.get(2, 2) * matrix.get(3, 0);\n            }\n            default: {\n                let res = 0;\n                let sign = 1;\n                for (let col = 0; col < matrix.columnSize(); col++) {\n                    res += (sign * matrix.get(0, col) * this.determinant(this.minor(matrix, 0, col)));\n                    sign *= -1;\n                }\n                return res;\n            }\n        }\n    }\n    /**\n     * Returns the trace of this matrix.\n     * This method will work properly **only if the two matrix contain only\n     * numbers**: this means that the behaviour of this method is not predictable\n     * using different types of matrices and will throw exceptions\n     * @param {NumMatrix} mat the original matrix\n     * @return the trace of this matrix\n     * @throws {IllegalArgumentException} if this matrix is not squared\n     */\n    static trace(mat) {\n        if (!mat.isSquared()) {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"this matrix is not squared [size: \" + mat.size().toArray() + \"]\");\n        }\n        let res = 0;\n        for (let i = 0; i < mat.rowSize(); i++)\n            res += mat.get(i, i);\n        return res;\n    }\n    /**\n     * Returns the *minor matrix* of the one specified as parameter.\n     * The *minor matrix* is the same matrix but with the specified `row` and the specified `column`\n     * dropped\n     * @param {Matrix<T>} mat the original matrix\n     * @param {number} row the index of the row to be dropped\n     * @param {number} column the index of the column to be dropped\n     * @return {Matrix<T>} the matrix with the specified row and column dropped\n     * @throws {IllegalRowIndexException} if the index of the row is not valid for the given matrix\n     * @throws {IllegalColumnIndexException} if the index of the column is not valid for the fiven matrix\n     */\n    static minor(mat, row, column) {\n        let res = (0, matrix_1.matrixData)(mat.rowSize() - 1, mat.columnSize() - 1);\n        let rR = 0;\n        let cR = 0;\n        for (let r = 0; r < mat.rowSize(); r++) {\n            if (r != row) {\n                cR = 0;\n                for (let c = 0; c < mat.columnSize(); c++) {\n                    if (c != column) {\n                        res[rR][cR] = mat.get(r, c);\n                        cR++;\n                    }\n                }\n                rR++;\n            }\n        }\n        return (0, matrix_1.matrix)(res);\n    }\n    /**\n     * Calculates and returns the cofactor of the element specified by `row` and `column`\n     * of the given matrix.\n     * Make sure that the matrix given as parameter **contains only numbers** otherwise\n     * this method will throw exceptions\n     * @param {NumMatrix} mat the original matrix\n     * @param {number} row the index of the row of the element\n     * @param {number} column the index of the column of the element\n     * @return {number} the *cofactor* of the given matrix for the specified `row` and `column`\n     * @throws {IllegalRowIndexException} if the index of the row is not valid\n     * @throws {IllegalColumnIndexException} if the index of the column is not valid\n     * @throws {IllegalArgumentException} if the matrix is not squared (the determinant\n     * is not defined to **non-squared** matrix)\n     */\n    static cofactor(mat, row, column) {\n        mat.checkValidIndexes(row, column, true);\n        return Math.pow(-1, row + column) * (this.minor(mat, row, column).determinant());\n    }\n    /**\n     * Computes and returns the **cofactor matrix** which is the matrix that contains\n     * each element of the one given as parameter replaced with its cofactor\n     * @param {NumMatrix} mat the original matrix\n     * @return {NumMatrix} the *cofactor matrix*\n     * @throws {IllegalArgumentException} if the matrix is not squared (the determinant\n     * is not defined to **non-squared** matrix)\n     */\n    static cofactorMatrix(mat) {\n        let res = (0, matrix_1.matrix)(mat.rowSize(), mat.columnSize());\n        for (let r = 0; r < mat.rowSize(); r++) {\n            for (let c = 0; c < mat.columnSize(); c++) {\n                res.set(this.cofactor(mat, r, c), r, c);\n            }\n        }\n        return res;\n    }\n    /**\n     * Checks if a numeric matrix is invertible and returns the determinant of the given matrix.\n     * If the matrix is not invertible, this method will return `undefined`\n     *\n     * If `throwError` is `true`, this method will throw an error instead of returning the determinant.\n     * @param {NumMatrix} mat the matrix\n     * @param {boolean} throwError the flag that if `true` make this method throwing an error\n     * @return {boolean} the determinant of the matrix or `undefined` if the matrix is not invertible\n     * @throws NotInvertibleMatrixException if `throwError` is `true` and the matrix is not invertible\n     */\n    static checkInvertible(mat, throwError = false) {\n        if (!mat.isSquared()) {\n            if (throwError)\n                throw new not_invertible_matrix_exception_1.NotInvertibleMatrixException(not_invertible_matrix_exception_1.NotInvertibleReason.NOT_SQUARED);\n            return undefined;\n        }\n        let determinant = this.determinant(mat);\n        if (determinant == 0) {\n            if (throwError)\n                throw new not_invertible_matrix_exception_1.NotInvertibleMatrixException(not_invertible_matrix_exception_1.NotInvertibleReason.ZERO_DETERMINANT);\n            return undefined;\n        }\n        return determinant;\n    }\n    /**\n     * Calculates and returns the inverse matrix of the one given as parameter.\n     * This method will work properly **only if the two matrix contain only\n     * numbers**: this means that the behaviour of this method is not predictable\n     * using different types of matrices and will throw exceptions\n     * @param {NumMatrix} mat the original matrix\n     * @return {NumMatrix} the inverse matrix\n     * @throws {NotInvertibleMatrixException} if the matrix is not invertible\n     * (it's not squared or had a determinant that is 0)\n     */\n    static invert(mat) {\n        let determinant = this.checkInvertible(mat, true);\n        let res;\n        res = this.cofactorMatrix(mat); /* 1. Take the cofactor matrix */\n        res = this.transpose(res); /* 2. Calculate the transposed cofactor matrix (added matrix) */\n        res = this.multiply(res, (1 / determinant)); /* 3. Multiply by 1/det */\n        return res;\n    }\n    /**\n     * Returns a function that represents the characteristic polynomial of the\n     * given matrix\n     * @param {NumMatrix} mat the original matrix\n     * @return {((lambda: number) => number)} the function that allow to calculate the characteristic\n     * polynomial for a given lambda\n     */\n    static characteristicPolynomial(mat) {\n        if (!mat.isSquared()) {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the given matrix is not squared: unable to calculate the \" +\n                \"characteristic polynomial\");\n        }\n        return function (lambda) {\n            return MatrixAlgebra.determinant(MatrixAlgebra.subtract(mat, MatrixAlgebra.multiply((0, matrix_1.identityMatrix)(mat.rowSize()), lambda)));\n        };\n    }\n}\nexports.MatrixAlgebra = MatrixAlgebra;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/matrix-algebra.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/matrix.ts":
/*!******************************************!*\
  !*** ./src/ts/geometry/matrix/matrix.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.identityMatrix = exports.checkValidMatrixData = exports.matrixData = exports.mutableMatrix = exports.frozenMatrix = exports.matrix = exports.MatrixFactory = exports.FlatType = void 0;\nvar FlatType;\n(function (FlatType) {\n    FlatType[FlatType[\"BY_ROWS\"] = 0] = \"BY_ROWS\";\n    FlatType[FlatType[\"BY_COLUMNS\"] = 1] = \"BY_COLUMNS\";\n})(FlatType = exports.FlatType || (exports.FlatType = {}));\n/**\n * A factory for a type of matrix.\n * Each class which extends `Matrix` should have a *static* factory\n */\nclass MatrixFactory {\n    createSquaredMatrix(dim, fill) {\n        return this.createMatrix(dim, dim, fill);\n    }\n    createNumberMatrix(rows, columns, fill) {\n        return this.createMatrix(rows, columns, fill);\n    }\n    createSquaredNumberMatrix(dim, fill) {\n        return this.createSquaredMatrix(dim, fill);\n    }\n    /**\n     * Creates and return the identity matrix with the given dimension\n     * @param {number} dim the dimension of the identity matrix\n     */\n    createIdentityMatrix(dim) {\n        return this.createSquaredNumberMatrix(dim).calculateAndFill((rowIndex, columnIndex) => {\n            if (rowIndex == columnIndex) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n    }\n    /**\n     * Converts a flat array to a matrix by specifying the type of the flat and the numbers of the\n     * element of a group. This method performs the opposite operations of `flatten`.\n     * Precisely, if `flatType` is:\n     *\n     * - `FlatType.BY_ROWS` then the elements of the array will be split in groups, each with the\n     * dimension specified by `groupSize`; **each group will be a row** of the resulting matrix\n     * (for example `[1, 2, 3, 4, 5, 6]` with `groupSize=2` and `flatType=FlatType.BY_ROWS` will make\n     * this method returning the matrix `[[1, 2], [3, 4], [5, 6]]`);\n     * this means that in this case **`groupSize` will become the number of the columns** of the resulting matrix\n     *\n     * - `FlatType.BY_COLUMNS` then the elements of the array will be split in groups, each with the\n     * dimension specified by `groupSize`; **each group will be a column** of the resulting matrix\n     * (for example `[1, 2, 3, 4, 5, 6]` with `groupSize=2` and `flatType=FlatType.BY_COLUMNS` will make\n     * this method returning the matrix `[[1, 3, 5], [2, 4, 6]]`);\n     * this means that in this case **`groupSize` will become the number of the rows** of the resulting matrix\n     * @param array the flat array to be converted into a matrix\n     * @param groupSize the number of the elements of each group\n     * @param flatType the type of the groups (indicates if each group will be a *row* or a *column*\n     * of the new matrix\n     */\n    createFromFlatten(array, groupSize, flatType = FlatType.BY_ROWS) {\n        if (array.length % groupSize != 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the dimension of the given array is not a multiple of the size of the group\");\n        }\n        let res;\n        switch (flatType) {\n            case FlatType.BY_ROWS: {\n                let rows = array.length / groupSize;\n                res = this.createMatrix(rows, groupSize);\n                for (let i = 0; i < array.length; i++) {\n                    res.set(array[i], Math.floor(i / groupSize), groupSize);\n                }\n                break;\n            }\n            case FlatType.BY_COLUMNS: {\n                let columns = array.length / groupSize;\n                res = this.createMatrix(groupSize, columns);\n                for (let i = 0; i < array.length; i++) {\n                    res.set(array[i], i % groupSize, Math.floor(i / groupSize));\n                }\n                break;\n            }\n        }\n        return res;\n    }\n    /**\n     * Creates a new matrix starting from another one by transforming each element of the `other` matrix\n     * to the elements of the new one by applying the `elementMapper` function\n     * @param {Matrix<T>>} other the other matrix\n     * @param {element: T, row: number, column: number) => R} elementMapper the function to be applied on each\n     * element of the `other` matrix to create the new ones\n     * @return {Matrix<R>} the new matrix\n     */\n    createFromOther(other, elementMapper) {\n        let res = this.createMatrix(other.rowSize(), other.columnSize());\n        for (let r = 0; r < res.rowSize(); r++) {\n            for (let c = 0; c < res.columnSize(); c++) {\n                res = res.set(elementMapper(other.get(r, c), r, c), r, c);\n            }\n        }\n        return res;\n    }\n    /**\n     * Creates and returns a new matrix with the same structure of the `other` given as parameter\n     * (with the same number of rows and columns)\n     * @param {Matrix<any>} other the other matrix\n     * @return {Matrix<T>} the new matrix with the same structure of the `other`\n     */\n    createWithSameStructureOf(other) {\n        return this.createMatrix(other.rowSize(), other.columnSize());\n    }\n}\nexports.MatrixFactory = MatrixFactory;\nconst frozen_row_based_matrix_1 = __webpack_require__(/*! ./frozen-row-based-matrix */ \"./src/ts/geometry/matrix/frozen-row-based-matrix.ts\");\nconst mutable_row_based_matrix_1 = __webpack_require__(/*! ./mutable-row-based-matrix */ \"./src/ts/geometry/matrix/mutable-row-based-matrix.ts\");\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../../types/exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nfunction matrix(arrayOrRows, columns, fill) {\n    let factory = frozen_row_based_matrix_1.FrozenRowBasedMatrix.factory;\n    if (typeof arrayOrRows == \"number\") {\n        return factory.createMatrix(arrayOrRows, columns, fill);\n    }\n    else {\n        return factory.createMatrix(arrayOrRows);\n    }\n    /*\n    let factory: MatrixFactory = FrozenRowBasedMatrix.factory\n\n    if(arrayOrRows instanceof Array) {\n        let rRows = arrayOrRows.length\n        let rColumns = Math.max(...arrayOrRows.map((array: Array<T>) => array.length))\n        let res: Matrix<T> = factory.createMatrix(rRows, rColumns)\n        let currRow: Row<T>\n\n        for(let r = 0; r < rRows; r++) {\n            currRow = arrayOrRows[r]\n            for(let c = 0; c < currRow.length; c++) {\n                res.set(currRow[c], r, c)\n            }\n        }\n        return res\n\n    } else {\n        return factory.createMatrix<T>(arrayOrRows as number, columns, fill)\n    }*/\n}\nexports.matrix = matrix;\nfunction frozenMatrix(arrayOrRows, columns, fill) {\n    let factory = frozen_row_based_matrix_1.FrozenRowBasedMatrix.factory;\n    if (typeof arrayOrRows == \"number\") {\n        return factory.createMatrix(arrayOrRows, columns, fill);\n    }\n    else {\n        return factory.createMatrix(arrayOrRows);\n    }\n}\nexports.frozenMatrix = frozenMatrix;\nfunction mutableMatrix(arrayOrRows, columns, fill) {\n    let factory = mutable_row_based_matrix_1.MutableRowBasedMatrix.factory;\n    if (typeof arrayOrRows == \"number\") {\n        return factory.createMatrix(arrayOrRows, columns, fill);\n    }\n    else {\n        return factory.createMatrix(arrayOrRows);\n    }\n}\nexports.mutableMatrix = mutableMatrix;\nfunction matrixData(rows, columns, fill) {\n    let res = new Array(rows);\n    if (fill == undefined) {\n        for (let r = 0; r < rows; r++) {\n            res[r] = new Array(columns);\n        }\n    }\n    else {\n        let row;\n        for (let r = 0; r < rows; r++) {\n            row = new Array(columns);\n            for (let c = 0; c < columns; c++) {\n                row[c] = fill;\n            }\n            res[r] = row;\n        }\n    }\n    return res;\n}\nexports.matrixData = matrixData;\n/**\n * Checks if the given bi-dimensional array has a valid format to be the internal data af a matrix.\n * This means that the bi-dimensional array given has parameter must have each element that is an\n * array with the same length as the others,\n * If `throwError` is true, this method will throw `IllegalArgumentException` if the given data\n * is not valid instead of returning a boolean\n * @param {Array<Array<T>>|Array<Row<T>>|MatrixData<T>} data the data to be checked\n * @param {boolean} throwError a flag that, if `true` make this method throwing an exception\n * @return {boolean} a boolean that indicates if the data is valid\n * @throws {IllegalArgumentException} if `throwError` is `true` and the data is not valid\n */\nfunction checkValidMatrixData(data, throwError = false) {\n    let totColumns = data[0].length;\n    for (let row of data) {\n        if (row.length != totColumns) {\n            if (throwError) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"every row must have the same number of elements\");\n            }\n            return false;\n        }\n    }\n    return true;\n}\nexports.checkValidMatrixData = checkValidMatrixData;\n/**\n * Creates and returns the identity matrix\n * @param {number} dim the dimension of the matrix to be created\n * @return {NumMatrix} the identity matrix with the specified dimension\n */\nfunction identityMatrix(dim) {\n    let res = matrix(dim, dim, 0);\n    for (let i = 0; i < dim; i++) {\n        res.set(1, i, i);\n    }\n    return res;\n}\nexports.identityMatrix = identityMatrix;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/matrix.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/mutable-row-based-matrix.ts":
/*!************************************************************!*\
  !*** ./src/ts/geometry/matrix/mutable-row-based-matrix.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MutableRowBasedMatrix_data, _MutableRowBasedMatrix_totRows, _MutableRowBasedMatrix_totColumns;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MutableRowBasedMatrix = void 0;\nconst abstract_matrix_1 = __webpack_require__(/*! ./abstract-matrix */ \"./src/ts/geometry/matrix/abstract-matrix.ts\");\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../../types/exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nconst invalid_column_exception_1 = __webpack_require__(/*! ./exceptions/invalid-column-exception */ \"./src/ts/geometry/matrix/exceptions/invalid-column-exception.ts\");\nconst invalid_row_exception_1 = __webpack_require__(/*! ./exceptions/invalid-row-exception */ \"./src/ts/geometry/matrix/exceptions/invalid-row-exception.ts\");\nconst matrix_algebra_1 = __webpack_require__(/*! ./matrix-algebra */ \"./src/ts/geometry/matrix/matrix-algebra.ts\");\nconst frozen_row_based_matrix_1 = __webpack_require__(/*! ./frozen-row-based-matrix */ \"./src/ts/geometry/matrix/frozen-row-based-matrix.ts\");\nconst arrays_1 = __webpack_require__(/*! ../../types/arrays */ \"./src/ts/types/arrays.ts\");\n/**\n * A **mutable** implementation of matrix based on a bi-dimensional array.\n * Every instance of this class is mutable and this means that can be modified with no problems.\n * So, methods like the matrix operations (`add()`, `multiply()`, `subtract()`, `divide()`) or\n * the matrix manipulation (`addRow()`, `removeRow()`, `addColumn()`, `removeColumn()`, `set()`, ecc...)\n * will modify the internal data of the matrix; **these methods will return this matrix** after the modification\n */\nclass MutableRowBasedMatrix extends abstract_matrix_1.AbstractMatrix {\n    constructor(data) {\n        super();\n        _MutableRowBasedMatrix_data.set(this, void 0);\n        _MutableRowBasedMatrix_totRows.set(this, void 0);\n        _MutableRowBasedMatrix_totColumns.set(this, void 0);\n        if (data.length > 0) {\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_totRows, data.length, \"f\");\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_totColumns, data[0].length, \"f\");\n            for (let row of data) {\n                if (row.length != __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\")) {\n                    throw Error(\"every row must have the same number of elements\");\n                }\n            }\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_data, data, \"f\");\n        }\n    }\n    add(other) {\n        let mat = this;\n        if (typeof other == 'number') {\n            for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n                for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                    (__classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[r][c]) += other;\n                }\n            }\n        }\n        else if (other instanceof abstract_matrix_1.AbstractMatrix) {\n            if (!this.sameStructureOf(this)) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"illegal matrix to be added: this matrix has size \" +\n                    __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\") + \" x \" + __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\") + \" while the argument has \" + other.rowSize() +\n                    \" x \" + other.columnSize());\n            }\n            for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n                for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                    __classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[r][c] += other.get(r, c);\n                }\n            }\n        }\n        return mat;\n    }\n    addColumn(column) {\n        var _a;\n        if (__classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\") == 0) {\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_totRows, column.length, \"f\");\n            for (let i = 0; i < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); i++) {\n                __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[i] = [];\n            }\n        }\n        else {\n            if (column.length != __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\")) {\n                throw new invalid_column_exception_1.InvalidColumnException(column, \"the number of the element is not the same of the column of the matrix\");\n            }\n        }\n        for (let i = 0; i < column.length; i++) {\n            __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[i].push(column[i]);\n        }\n        __classPrivateFieldSet(this, _MutableRowBasedMatrix_totColumns, (_a = __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"), _a++, _a), \"f\");\n        return this;\n    }\n    addRow(row) {\n        var _a;\n        if (__classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\") == 0) {\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_totColumns, row.length, \"f\");\n        }\n        else {\n            if (row.length != __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\")) {\n                throw new invalid_row_exception_1.InvalidRowException(row, \"the number of the element of the row [\" + row.length +\n                    \"] is not the same of the column of the matrix [\" + __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\") + \"]\");\n            }\n        }\n        __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\").push(row);\n        __classPrivateFieldSet(this, _MutableRowBasedMatrix_totRows, (_a = __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"), _a++, _a), \"f\");\n        return this;\n    }\n    calculateAndFill(builder) {\n        for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n            for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[r][c] = builder(r, c);\n            }\n        }\n        return this;\n    }\n    columnSize() {\n        return __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\");\n    }\n    determinant() {\n        return matrix_algebra_1.MatrixAlgebra.determinant(this);\n    }\n    divide(other) {\n        let mat = this;\n        if (typeof other == \"number\") {\n            for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n                for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                    __classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[r][c] /= other;\n                }\n            }\n        }\n        else {\n            mat.multiply(matrix_algebra_1.MatrixAlgebra.invert(other));\n        }\n        return mat;\n    }\n    fill(value) {\n        for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n            for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[r][c] = value;\n            }\n        }\n        return this;\n    }\n    frozen() {\n        return new frozen_row_based_matrix_1.FrozenRowBasedMatrix(__classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\"));\n    }\n    get(rowIndex, columnIndex) {\n        return __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[rowIndex][columnIndex];\n    }\n    getCharacteristicPolynomial() {\n        return matrix_algebra_1.MatrixAlgebra.characteristicPolynomial(this);\n    }\n    getColumn(columnIndex) {\n        let res = new Array(__classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"));\n        for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n            res[r] = __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[r][columnIndex];\n        }\n        return res;\n    }\n    getFactory() {\n        return MutableRowBasedMatrix.factory;\n    }\n    getRow(rowIndex) {\n        return arrays_1.Arrays.clone(__classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[rowIndex]);\n    }\n    invert() {\n        let determinant = matrix_algebra_1.MatrixAlgebra.checkInvertible(this, true);\n        return this.getCofactorMatrix().transpose().multiply((1 / determinant));\n    }\n    isFrozen() {\n        return false;\n    }\n    isUnfrozen() {\n        return true;\n    }\n    multiply(other) {\n        let mat = this;\n        if (typeof other == \"number\") {\n            for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n                for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                    __classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[r][c] *= other;\n                }\n            }\n        }\n        else {\n            let data = (0, matrix_1.matrixData)(__classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"), __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"));\n            for (let rT = 0; rT < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); rT++) {\n                for (let cO = 0; cO < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); cO++) {\n                    for (let rO = 0; rO < other.rowSize(); rO++) {\n                        data[rT][cO] = data[rT][cO] + __classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[rT][rO] * other.get(rO, cO);\n                    }\n                }\n            }\n            arrays_1.Arrays.copy2(data, __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\"));\n        }\n        return mat;\n    }\n    removeColumn() {\n        var _a;\n        for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n            __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\").splice(__classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\") - 1, 1);\n        }\n        __classPrivateFieldSet(this, _MutableRowBasedMatrix_totColumns, (_a = __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"), _a--, _a), \"f\");\n        return this;\n    }\n    removeRow() {\n        var _a;\n        __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\").splice(__classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\") - 1, 1);\n        __classPrivateFieldSet(this, _MutableRowBasedMatrix_totRows, (_a = __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"), _a--, _a), \"f\");\n        return this;\n    }\n    rowSize() {\n        return __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\");\n    }\n    set(value, rowIndex, columnIndex) {\n        this.checkValidIndexes(rowIndex, columnIndex);\n        __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[rowIndex][columnIndex] = value;\n        return this;\n    }\n    setColumn(column, columnIndex) {\n        this.checkValidColumnIndex(columnIndex);\n        for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n            __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[r][columnIndex] = column[r];\n        }\n        return this;\n    }\n    setRow(row, rowIndex) {\n        this.checkValidRowIndex(rowIndex);\n        for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n            __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[rowIndex][c] = row[c];\n        }\n        return this;\n    }\n    subtract(other) {\n        let mat = this;\n        let row;\n        if (typeof other == \"number\") {\n            for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n                row = __classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[r];\n                for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                    row[c] -= other;\n                }\n            }\n        }\n        else {\n            for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"); r++) {\n                row = __classPrivateFieldGet(mat, _MutableRowBasedMatrix_data, \"f\")[r];\n                for (let c = 0; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                    row[c] -= other.get(r, c);\n                }\n            }\n        }\n        return mat;\n    }\n    transpose() {\n        if (!this.isSquared()) {\n            let dim = Math.max(__classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"), __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"));\n            arrays_1.Arrays.reshape2(__classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\"), dim, dim);\n        }\n        for (let r = 0; r < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\") - 1; r++) {\n            for (let c = r + 1; c < __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"); c++) {\n                [__classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[r][c], __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[c][r]] = [__classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[c][r], __classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\")[r][c]];\n            }\n        }\n        if (!this.isSquared()) {\n            arrays_1.Arrays.reshape2(__classPrivateFieldGet(this, _MutableRowBasedMatrix_data, \"f\"), __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"), __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\"));\n            let temp = __classPrivateFieldGet(this, _MutableRowBasedMatrix_totRows, \"f\");\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_totRows, __classPrivateFieldGet(this, _MutableRowBasedMatrix_totColumns, \"f\"), \"f\");\n            __classPrivateFieldSet(this, _MutableRowBasedMatrix_totColumns, temp, \"f\");\n        }\n        return this;\n    }\n    unfrozen() {\n        return this;\n    }\n}\nexports.MutableRowBasedMatrix = MutableRowBasedMatrix;\n_MutableRowBasedMatrix_data = new WeakMap(), _MutableRowBasedMatrix_totRows = new WeakMap(), _MutableRowBasedMatrix_totColumns = new WeakMap();\nMutableRowBasedMatrix.factory = new class extends matrix_1.MatrixFactory {\n    createMatrix(rows, columns, fill) {\n        if (typeof rows == \"number\") {\n            let data = new Array(rows);\n            for (let r = 0; r < rows; r++) {\n                data[r] = Array(columns);\n            }\n            let res = new MutableRowBasedMatrix(data);\n            if (fill != undefined) {\n                res.fill(fill);\n            }\n            return res;\n        }\n        else {\n            return new MutableRowBasedMatrix(rows);\n        }\n    }\n};\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/mutable-row-based-matrix.ts?");

/***/ }),

/***/ "./src/ts/geometry/matrix/rotation-matrices.ts":
/*!*****************************************************!*\
  !*** ./src/ts/geometry/matrix/rotation-matrices.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RotationMatrices = void 0;\nconst angle_1 = __webpack_require__(/*! ../angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst axis_1 = __webpack_require__(/*! ../axis */ \"./src/ts/geometry/axis.ts\");\nclass RotationMatrices {\n    /**\n     * Returns the matrix for the elementary angle around the `x` axis for the specified\n     * angle. Multiply a point for this matrix will return the coordinates of the point after the angle\n     * @param {Angle} angle the angle of the angle\n     * @return {NumMatrix} the matrix for the angle\n     */\n    static RX(angle) {\n        let theta = angle.getValueIn(angle_1.AngleUnit.RAD);\n        return (0, matrix_1.matrix)([\n            [1, 0, 0],\n            [0, Math.cos(theta), -1 * Math.sin(theta)],\n            [0, Math.sin(theta), Math.cos(theta)]\n        ]);\n    }\n    /**\n     * Returns the matrix for the elementary angle around the `y` axis for the specified\n     * angle. Multiply a point for this matrix will return the coordinates of the point after the angle\n     * @param {Angle} angle the angle of the angle\n     * @return {NumMatrix} the matrix for the angle\n     */\n    static RY(angle) {\n        let theta = angle.getValueIn(angle_1.AngleUnit.RAD);\n        return (0, matrix_1.matrix)([\n            [Math.cos(theta), 0, Math.sin(theta)],\n            [0, 1, 0],\n            [-1 * Math.sin(theta), 0, Math.cos(theta)]\n        ]);\n    }\n    /**\n     * Returns the matrix for the elementary angle around the `z` axis for the specified\n     * angle. Multiply a point for this matrix will return the coordinates of the point after the angle\n     * @param {Angle} angle the angle of the angle\n     * @return {NumMatrix} the matrix for the angle\n     */\n    static RZ(angle) {\n        let theta = angle.getValueIn(angle_1.AngleUnit.RAD);\n        return (0, matrix_1.matrix)([\n            [Math.cos(theta), -1 * Math.sin(theta), 0],\n            [Math.sin(theta), Math.cos(theta), 0],\n            [0, 0, 1]\n        ]);\n    }\n    /**\n     * Return the matrix for the elementary angle around the specified axis for the specified axis.\n     * Multiply a point for this matrix will return the coordinates of the point after the angle\n     * @param {Axis} axis the axis around which the angle is desired to be performed\n     * @param {Angle} angle the angle of the angle\n     * @return {NumMatrix} the matrix for the angle\n     */\n    static R(axis, angle) {\n        switch (axis) {\n            case axis_1.Axis.X: {\n                return this.RX(angle);\n            }\n            case axis_1.Axis.Y: {\n                return this.RY(angle);\n            }\n            case axis_1.Axis.Z: {\n                return this.RZ(angle);\n            }\n        }\n    }\n}\nexports.RotationMatrices = RotationMatrices;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/matrix/rotation-matrices.ts?");

/***/ }),

/***/ "./src/ts/geometry/point/abstract-point-3d.ts":
/*!****************************************************!*\
  !*** ./src/ts/geometry/point/abstract-point-3d.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbstractPoint3D = void 0;\nconst point_3d_1 = __webpack_require__(/*! ./point-3d */ \"./src/ts/geometry/point/point-3d.ts\");\nconst matrix_1 = __webpack_require__(/*! ../matrix/matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst axis_1 = __webpack_require__(/*! ../axis */ \"./src/ts/geometry/axis.ts\");\n/**\n * The abstract implementation of a `Point3D`.\n * This point can be\n *\n * - **frozen**: in this case is not possible to modify the values of the internal coordinates;\n * this kind of point can **throw an exception** or **returns a modified copy** depending on the\n * configuration\n *\n * - **mutable**: in this case is possible to modify the values of the internal coordinates using all the\n * method for these kind of purposes; these methods will return `this`\n */\nclass AbstractPoint3D {\n    asRowVector() {\n        let matrixData = new Array(1);\n        matrixData[0][0] = this.getX();\n        matrixData[0][1] = this.getY();\n        matrixData[0][2] = this.getZ();\n        return (0, matrix_1.frozenMatrix)(matrixData);\n    }\n    asColumnVector() {\n        let matrixData = new Array(3);\n        matrixData[0] = [this.getX()];\n        matrixData[1] = [this.getY()];\n        matrixData[2] = [this.getZ()];\n        return (0, matrix_1.frozenMatrix)(matrixData);\n    }\n    dilate(mx, my, mz) {\n        let result = this;\n        if (mx != null) {\n            result = result.dilateCoordinate(mx, axis_1.Axis.X);\n        }\n        if (my != null) {\n            result = result.dilateCoordinate(my, axis_1.Axis.Y);\n        }\n        if (mz != null) {\n            result = result.dilateCoordinate(mz, axis_1.Axis.Z);\n        }\n        return result;\n    }\n    dilateX(mx) {\n        return this.dilateCoordinate(mx, axis_1.Axis.X);\n    }\n    dilateY(my) {\n        return this.dilateCoordinate(my, axis_1.Axis.Y);\n    }\n    dilateZ(mz) {\n        return this.dilateCoordinate(mz, axis_1.Axis.Z);\n    }\n    dilateByVector(vector) {\n        return this\n            .dilateCoordinate(vector.getX(), axis_1.Axis.X)\n            .dilateCoordinate(vector.getY(), axis_1.Axis.Y)\n            .dilateCoordinate(vector.getZ(), axis_1.Axis.Z);\n    }\n    getX() {\n        return this.getCoordinate(axis_1.Axis.X);\n    }\n    getY() {\n        return this.getCoordinate(axis_1.Axis.Y);\n    }\n    getZ() {\n        return this.getCoordinate(axis_1.Axis.Z);\n    }\n    rotateAroundX(angle) {\n        return this.rotateAround(axis_1.Axis.X, angle);\n    }\n    rotateAroundY(angle) {\n        return this.rotateAround(axis_1.Axis.Y, angle);\n    }\n    rotateAroundZ(angle) {\n        return this.rotateAround(axis_1.Axis.Z, angle);\n    }\n    set(newX, newY, newZ) {\n        let result = this;\n        if (newX != null) {\n            result = this.setCoordinate(newX, axis_1.Axis.X);\n        }\n        if (newY != null) {\n            result = this.setCoordinate(newY, axis_1.Axis.Y);\n        }\n        if (newZ != null) {\n            result = this.setCoordinate(newZ, axis_1.Axis.Z);\n        }\n        return result;\n    }\n    setX(newX) {\n        return this.setCoordinate(newX, axis_1.Axis.X);\n    }\n    setY(newY) {\n        return this.setCoordinate(newY, axis_1.Axis.Y);\n    }\n    setZ(newZ) {\n        return this.setCoordinate(newZ, axis_1.Axis.Z);\n    }\n    translate(dx, dy, dz) {\n        let result = this;\n        if (dx != null) {\n            result = this.translateCoordinate(dx, axis_1.Axis.X);\n        }\n        if (dy != null) {\n            result = this.translateCoordinate(dy, axis_1.Axis.Y);\n        }\n        if (dz != null) {\n            result = this.translateCoordinate(dz, axis_1.Axis.Z);\n        }\n        return result;\n    }\n    translateByVector(vector) {\n        return this\n            .translateCoordinate(vector.getX(), axis_1.Axis.X)\n            .translateCoordinate(vector.getY(), axis_1.Axis.Y)\n            .translateCoordinate(vector.getZ(), axis_1.Axis.Z);\n    }\n    translateX(dx) {\n        return this.translateCoordinate(dx, axis_1.Axis.X);\n    }\n    translateY(dy) {\n        return this.translateCoordinate(dy, axis_1.Axis.Y);\n    }\n    translateZ(dz) {\n        return this.translateCoordinate(dz, axis_1.Axis.Z);\n    }\n    equals(other) {\n        return (0, point_3d_1.samePoints)(this, other);\n    }\n    toString() {\n        return \"(\" + this.getX() + \", \" + this.getY() + \", \" + this.getZ() + \")\";\n    }\n    toArray() {\n        return [this.getX(), this.getY(), this.getZ()];\n    }\n}\nexports.AbstractPoint3D = AbstractPoint3D;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/point/abstract-point-3d.ts?");

/***/ }),

/***/ "./src/ts/geometry/point/frozen-point-3d.ts":
/*!**************************************************!*\
  !*** ./src/ts/geometry/point/frozen-point-3d.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenPoint3D_instances, _FrozenPoint3D_x, _FrozenPoint3D_y, _FrozenPoint3D_z, _FrozenPoint3D_denyModCopy, _FrozenPoint3D_checkCopyDenied;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrozenPoint3D = void 0;\nconst point_3d_1 = __webpack_require__(/*! ./point-3d */ \"./src/ts/geometry/point/point-3d.ts\");\nconst abstract_point_3d_1 = __webpack_require__(/*! ./abstract-point-3d */ \"./src/ts/geometry/point/abstract-point-3d.ts\");\nconst illegal_modification_exception_1 = __webpack_require__(/*! ../../types/exceptions/illegal-modification-exception */ \"./src/ts/types/exceptions/illegal-modification-exception.ts\");\nconst mutable_point_3d_1 = __webpack_require__(/*! ./mutable-point-3d */ \"./src/ts/geometry/point/mutable-point-3d.ts\");\nconst rotation_matrices_1 = __webpack_require__(/*! ../matrix/rotation-matrices */ \"./src/ts/geometry/matrix/rotation-matrices.ts\");\nconst axis_1 = __webpack_require__(/*! ../axis */ \"./src/ts/geometry/axis.ts\");\n/**\n * The frozen implementation of a point in 3D reference system.\n * This class extends `AbstractPoint3D` and implement `Point3D`.\n * Notice that every object of this class keeps the setting of the denying of\n * the returning modified copies.\n * If `denyModCopy` is disabled in the constructor, every method that tries to modify\n * a coordinate of this point will return a copy of this after the modification; if this\n * flag is false, then every of these methods will throw an `IllegalModificationException`\n */\nclass FrozenPoint3D extends abstract_point_3d_1.AbstractPoint3D {\n    constructor(x, y, z, denyModCopy = true) {\n        super();\n        _FrozenPoint3D_instances.add(this);\n        _FrozenPoint3D_x.set(this, void 0);\n        _FrozenPoint3D_y.set(this, void 0);\n        _FrozenPoint3D_z.set(this, void 0);\n        _FrozenPoint3D_denyModCopy.set(this, void 0);\n        (0, point_3d_1.checkNotNullCoordinates)(x, y, z, true);\n        __classPrivateFieldSet(this, _FrozenPoint3D_x, x, \"f\");\n        __classPrivateFieldSet(this, _FrozenPoint3D_y, y, \"f\");\n        __classPrivateFieldSet(this, _FrozenPoint3D_z, z, \"f\");\n        __classPrivateFieldSet(this, _FrozenPoint3D_denyModCopy, denyModCopy, \"f\");\n    }\n    setCoordinate(newValue, axis) {\n        __classPrivateFieldGet(this, _FrozenPoint3D_instances, \"m\", _FrozenPoint3D_checkCopyDenied).call(this);\n        switch (axis) {\n            case axis_1.Axis.X: {\n                return new FrozenPoint3D(newValue, __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n            }\n            case axis_1.Axis.Y: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\"), newValue, __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n            }\n            case axis_1.Axis.Z: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), newValue);\n            }\n        }\n    }\n    translateCoordinate(translation, axis) {\n        __classPrivateFieldGet(this, _FrozenPoint3D_instances, \"m\", _FrozenPoint3D_checkCopyDenied).call(this);\n        switch (axis) {\n            case axis_1.Axis.X: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\") + translation, __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n            }\n            case axis_1.Axis.Y: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\") + translation, __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n            }\n            case axis_1.Axis.Z: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\") + translation);\n            }\n        }\n    }\n    dilateCoordinate(dilation, axis) {\n        __classPrivateFieldGet(this, _FrozenPoint3D_instances, \"m\", _FrozenPoint3D_checkCopyDenied).call(this);\n        switch (axis) {\n            case axis_1.Axis.X: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\") * dilation, __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n            }\n            case axis_1.Axis.Y: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\") * dilation, __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n            }\n            case axis_1.Axis.Z: {\n                return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\") * dilation);\n            }\n        }\n    }\n    rotateAround(axis, angle) {\n        let rotated = this.asColumnVector().multiply(rotation_matrices_1.RotationMatrices.R(axis, angle));\n        return new FrozenPoint3D(rotated.get(0, 0), rotated.get(1, 0), rotated.get(2, 0), __classPrivateFieldGet(this, _FrozenPoint3D_denyModCopy, \"f\"));\n    }\n    getCoordinate(axis) {\n        switch (axis) {\n            case axis_1.Axis.X: {\n                return __classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\");\n            }\n            case axis_1.Axis.Y: {\n                return __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\");\n            }\n            case axis_1.Axis.Z: {\n                return __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\");\n            }\n        }\n    }\n    frozen(denyModifiedCopy) {\n        if (__classPrivateFieldGet(this, _FrozenPoint3D_denyModCopy, \"f\") === denyModifiedCopy) {\n            return this;\n        }\n        else {\n            return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"), denyModifiedCopy);\n        }\n    }\n    unfrozen() {\n        return new mutable_point_3d_1.MutablePoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n    }\n    isFrozen() {\n        return true;\n    }\n    isUnfrozen() {\n        return false;\n    }\n    clone() {\n        return new FrozenPoint3D(__classPrivateFieldGet(this, _FrozenPoint3D_x, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_y, \"f\"), __classPrivateFieldGet(this, _FrozenPoint3D_z, \"f\"));\n    }\n}\nexports.FrozenPoint3D = FrozenPoint3D;\n_FrozenPoint3D_x = new WeakMap(), _FrozenPoint3D_y = new WeakMap(), _FrozenPoint3D_z = new WeakMap(), _FrozenPoint3D_denyModCopy = new WeakMap(), _FrozenPoint3D_instances = new WeakSet(), _FrozenPoint3D_checkCopyDenied = function _FrozenPoint3D_checkCopyDenied() {\n    if (__classPrivateFieldGet(this, _FrozenPoint3D_denyModCopy, \"f\")) {\n        throw new illegal_modification_exception_1.IllegalModificationException(\"this point is frozen and copy is denied: unable to modify values or to return a modified copy\");\n    }\n    else {\n        console.log(\"warning: this point 3D is frozen: a copy will be returned\");\n    }\n};\n\n\n//# sourceURL=webpack:///./src/ts/geometry/point/frozen-point-3d.ts?");

/***/ }),

/***/ "./src/ts/geometry/point/mutable-point-3d.ts":
/*!***************************************************!*\
  !*** ./src/ts/geometry/point/mutable-point-3d.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MutablePoint3D_x, _MutablePoint3D_y, _MutablePoint3D_z;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MutablePoint3D = void 0;\nconst abstract_point_3d_1 = __webpack_require__(/*! ./abstract-point-3d */ \"./src/ts/geometry/point/abstract-point-3d.ts\");\nconst point_3d_1 = __webpack_require__(/*! ./point-3d */ \"./src/ts/geometry/point/point-3d.ts\");\nconst frozen_point_3d_1 = __webpack_require__(/*! ./frozen-point-3d */ \"./src/ts/geometry/point/frozen-point-3d.ts\");\nconst rotation_matrices_1 = __webpack_require__(/*! ../matrix/rotation-matrices */ \"./src/ts/geometry/matrix/rotation-matrices.ts\");\nconst axis_1 = __webpack_require__(/*! ../axis */ \"./src/ts/geometry/axis.ts\");\n/**\n * The implementation of a mutable point in a 3D reference system.\n * This class extends `AbstractPoint3D` and implements `Point3D`.\n * All the methods of this class that change the value of one of the coordinates of\n * this point will return `this` object after the modification\n */\nclass MutablePoint3D extends abstract_point_3d_1.AbstractPoint3D {\n    constructor(x, y, z) {\n        super();\n        _MutablePoint3D_x.set(this, void 0);\n        _MutablePoint3D_y.set(this, void 0);\n        _MutablePoint3D_z.set(this, void 0);\n        (0, point_3d_1.checkNotNullCoordinates)(x, y, z, true);\n        __classPrivateFieldSet(this, _MutablePoint3D_x, x, \"f\");\n        __classPrivateFieldSet(this, _MutablePoint3D_y, y, \"f\");\n        __classPrivateFieldSet(this, _MutablePoint3D_z, z, \"f\");\n    }\n    getCoordinate(axis) {\n        switch (axis) {\n            case axis_1.Axis.X:\n                return __classPrivateFieldGet(this, _MutablePoint3D_x, \"f\");\n            case axis_1.Axis.Y:\n                return __classPrivateFieldGet(this, _MutablePoint3D_y, \"f\");\n            case axis_1.Axis.Z:\n                return __classPrivateFieldGet(this, _MutablePoint3D_z, \"f\");\n        }\n    }\n    setCoordinate(newValue, axis) {\n        switch (axis) {\n            case axis_1.Axis.X: {\n                __classPrivateFieldSet(this, _MutablePoint3D_x, newValue, \"f\");\n                break;\n            }\n            case axis_1.Axis.Y: {\n                __classPrivateFieldSet(this, _MutablePoint3D_y, newValue, \"f\");\n                break;\n            }\n            case axis_1.Axis.Z: {\n                __classPrivateFieldSet(this, _MutablePoint3D_z, newValue, \"f\");\n                break;\n            }\n        }\n        return this;\n    }\n    translateCoordinate(translation, axis) {\n        switch (axis) {\n            case axis_1.Axis.X: {\n                __classPrivateFieldSet(this, _MutablePoint3D_x, __classPrivateFieldGet(this, _MutablePoint3D_x, \"f\") + translation, \"f\");\n                break;\n            }\n            case axis_1.Axis.Y: {\n                __classPrivateFieldSet(this, _MutablePoint3D_y, __classPrivateFieldGet(this, _MutablePoint3D_y, \"f\") + translation, \"f\");\n                break;\n            }\n            case axis_1.Axis.Z: {\n                __classPrivateFieldSet(this, _MutablePoint3D_z, __classPrivateFieldGet(this, _MutablePoint3D_z, \"f\") + translation, \"f\");\n                break;\n            }\n        }\n        return this;\n    }\n    dilateCoordinate(dilation, axis) {\n        switch (axis) {\n            case axis_1.Axis.X: {\n                __classPrivateFieldSet(this, _MutablePoint3D_x, __classPrivateFieldGet(this, _MutablePoint3D_x, \"f\") * dilation, \"f\");\n                break;\n            }\n            case axis_1.Axis.Y: {\n                __classPrivateFieldSet(this, _MutablePoint3D_y, __classPrivateFieldGet(this, _MutablePoint3D_y, \"f\") * dilation, \"f\");\n                break;\n            }\n            case axis_1.Axis.Z: {\n                __classPrivateFieldSet(this, _MutablePoint3D_z, __classPrivateFieldGet(this, _MutablePoint3D_z, \"f\") * dilation, \"f\");\n                break;\n            }\n        }\n        return this;\n    }\n    rotateAround(axis, angle) {\n        let rotated = rotation_matrices_1.RotationMatrices.R(axis, angle).multiply(this.asColumnVector());\n        __classPrivateFieldSet(this, _MutablePoint3D_x, rotated.get(0, 0), \"f\");\n        __classPrivateFieldSet(this, _MutablePoint3D_y, rotated.get(1, 0), \"f\");\n        __classPrivateFieldSet(this, _MutablePoint3D_z, rotated.get(2, 0), \"f\");\n        return this;\n    }\n    frozen(denyModifiedCopy = true) {\n        return new frozen_point_3d_1.FrozenPoint3D(__classPrivateFieldGet(this, _MutablePoint3D_x, \"f\"), __classPrivateFieldGet(this, _MutablePoint3D_y, \"f\"), __classPrivateFieldGet(this, _MutablePoint3D_z, \"f\"), denyModifiedCopy);\n    }\n    isFrozen() {\n        return false;\n    }\n    isUnfrozen() {\n        return true;\n    }\n    unfrozen() {\n        return this;\n    }\n    clone() {\n        return new MutablePoint3D(__classPrivateFieldGet(this, _MutablePoint3D_x, \"f\"), __classPrivateFieldGet(this, _MutablePoint3D_y, \"f\"), __classPrivateFieldGet(this, _MutablePoint3D_z, \"f\"));\n    }\n}\nexports.MutablePoint3D = MutablePoint3D;\n_MutablePoint3D_x = new WeakMap(), _MutablePoint3D_y = new WeakMap(), _MutablePoint3D_z = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/geometry/point/mutable-point-3d.ts?");

/***/ }),

/***/ "./src/ts/geometry/point/point-3d.ts":
/*!*******************************************!*\
  !*** ./src/ts/geometry/point/point-3d.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkNotNullCoordinates = exports.samePoints = exports.isPoint = void 0;\n/**\n * Returns `true` if the given `object` is a **point**\n * @param {any} object\n * @return {boolean} `true` if the given `object` is a **point**, `false` otherwise\n */\nfunction isPoint(object) {\n    return 'getX' in object && 'getY' in object && 'getZ' in object;\n}\nexports.isPoint = isPoint;\n/**\n * Returns `true` if the two objects are the same point.\n * Notice that **this function return `false` if one or both of the arguments\n * are `null` or `undefined`**\n * @param {any} point1 the first object\n * @param {any} point2 the second object\n * @return {boolean} `true` if the two objects are the same point, `false` otherwise\n */\nfunction samePoints(point1, point2) {\n    if (point1 != null && point2 != null) {\n        if (isPoint(point1) && isPoint(point2)) {\n            return point1.getX() === point2.getX() &&\n                point1.getY() === point2.getY() &&\n                point1.getZ() === point2.getZ();\n        }\n    }\n    return false;\n}\nexports.samePoints = samePoints;\n/**\n * Checks if all the given coordinates are not `null`.\n * If `throwError` is enabled, this function will immediately throw an error\n * when it will find a `null` value for a coordinate\n * @param {number} x the `x` coordinate\n * @param {number} y the `y` coordinate\n * @param {number} z the `z` coordinate\n * @param throwError the `flag` that if enabled will make this function able to throw an exception\n * @return {boolean} `true` if all the coordinates are not null, `false` otherwise\n * @throws {Error} if `throwError` is `true` and a coordinate is `null`\n */\nfunction checkNotNullCoordinates(x, y, z, throwError = false) {\n    if (x == null) {\n        if (throwError) {\n            throw Error(\"x coordinate can not be null\");\n        }\n        return false;\n    }\n    if (y == null) {\n        if (throwError) {\n            throw Error(\"y coordinate can not be null\");\n        }\n        return false;\n    }\n    if (z == null) {\n        if (throwError) {\n            throw Error(\"z coordinate can not be null\");\n        }\n        return false;\n    }\n    return true;\n}\nexports.checkNotNullCoordinates = checkNotNullCoordinates;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/point/point-3d.ts?");

/***/ }),

/***/ "./src/ts/geometry/point/point-factory.ts":
/*!************************************************!*\
  !*** ./src/ts/geometry/point/point-factory.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.origin = exports.mutablePoint3D = exports.frozenPoint3D = exports.point3D = exports.PointFactory = void 0;\nconst frozen_point_3d_1 = __webpack_require__(/*! ./frozen-point-3d */ \"./src/ts/geometry/point/frozen-point-3d.ts\");\nconst mutable_point_3d_1 = __webpack_require__(/*! ./mutable-point-3d */ \"./src/ts/geometry/point/mutable-point-3d.ts\");\nconst triple_1 = __webpack_require__(/*! ../../types/triple */ \"./src/ts/types/triple.ts\");\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../../types/exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nconst abstract_matrix_1 = __webpack_require__(/*! ../matrix/abstract-matrix */ \"./src/ts/geometry/matrix/abstract-matrix.ts\");\nconst types_1 = __webpack_require__(/*! ../../types/types */ \"./src/ts/types/types.ts\");\n/**\n * A factory for the points\n */\nclass PointFactory {\n    /**\n     * Creates and return a new frozen point.\n     * If `denyModifiedCopy` is set to `true`, all the methods that modify the values of the\n     * coordinates of the point will throw an error. Instead, if it is `false`, all of this methods\n     * will not modify the internal values of the coordinates but will return new frozen copies that\n     * will contain the modification\n     * @param {number} x the value of the `x` coordinate\n     * @param {number} y the value of the `y` coordinate\n     * @param {number} z the value of the `z` coordinate\n     * @param {boolean} denyModifiedCopy the flag to deny the return of a modified copy (`false` by default)\n     * @return {Point3D} the new point\n     */\n    static newFrozenPoint3D(x, y, z, denyModifiedCopy = false) {\n        return new frozen_point_3d_1.FrozenPoint3D(x, y, z, denyModifiedCopy);\n    }\n    /**\n     * Creates and return a new point that is modifiable\n     * @param {number} x the value of the `x` coordinate\n     * @param {number} y the value of the `y` coordinate\n     * @param {number} z the value of the `z` coordinate\n     * @return {Point3D} the new point\n     */\n    static newMutablePoint3D(x, y, z) {\n        return new mutable_point_3d_1.MutablePoint3D(x, y, z);\n    }\n    /**\n     * Returns the origin of a cartesian reference system\n     * @param {boolean} frozen a flag that indicates if the returning point have to be frozen (`false`\n     * by default)\n     * @param {boolean} denyModifiedCopy the flag to deny the return of a modified copy if\n     * the point is frozen (`true` by default)\n     */\n    static origin(frozen = false, denyModifiedCopy = true) {\n        if (frozen) {\n            return new frozen_point_3d_1.FrozenPoint3D(0, 0, 0, denyModifiedCopy);\n        }\n        else {\n            return new mutable_point_3d_1.MutablePoint3D(0, 0, 0);\n        }\n    }\n    /**\n     * Creates and returns a new `Point3D`\n     * @param {number} x the value of the `x` coordinate\n     * @param {number} y the value of the `y` coordinate\n     * @param {number} z the value of the `z` coordinate\n     * @param {boolean} frozen a flag that indicates if the returning point have to be frozen (`false`\n     * by default)\n     * @param {boolean} denyModifiedCopy the flag to deny the return of a modified copy if\n     * the point is frozen (`true` by default)\n     */\n    static newPoint3D(x, y, z, frozen = true, denyModifiedCopy = false) {\n        if (frozen) {\n            return this.newFrozenPoint3D(x, y, z, denyModifiedCopy);\n        }\n        else {\n            return this.newMutablePoint3D(x, y, z);\n        }\n    }\n}\nexports.PointFactory = PointFactory;\nfunction point3D(xOrData, y, z) {\n    if (typeof xOrData == \"number\") {\n        return PointFactory.newPoint3D(xOrData, y, z);\n    }\n    else if (xOrData instanceof triple_1.Triple) {\n        return PointFactory.newPoint3D(xOrData.getFirst(), xOrData.getSecond(), xOrData.getThird());\n    }\n    else if (xOrData instanceof (Array)) {\n        if (xOrData.length != 3)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the array must have exactly 3 elements and not [\" + xOrData.length + \"]\");\n        return PointFactory.newPoint3D(xOrData[0], xOrData[1], xOrData[2]);\n    }\n    else if (xOrData instanceof abstract_matrix_1.AbstractMatrix) {\n        if (xOrData.rowSize() == 1 && xOrData.columnSize() == 3) {\n            return PointFactory.newPoint3D(xOrData.get(0, 0), xOrData.get(0, 1), xOrData.get(0, 2));\n        }\n        else if (xOrData.rowSize() == 3 && xOrData.columnSize() == 1) {\n            return PointFactory.newPoint3D(xOrData.get(0, 0), xOrData.get(1, 0), xOrData.get(2, 0));\n        }\n        else {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the matrix must have dimension 1x3 or 3x1 and not [\" +\n                xOrData.rowSize() + \"x\" + xOrData.columnSize() + \"]\");\n        }\n    }\n    throw new illegal_argument_exception_1.IllegalArgumentException(\"invalid parameter type [\" + (0, types_1.getTypeName)(xOrData) + \"]\");\n}\nexports.point3D = point3D;\nfunction frozenPoint3D(xOrData, y, z) {\n    if (typeof xOrData == \"number\") {\n        return PointFactory.newPoint3D(xOrData, y, z, true, false);\n    }\n    else if (xOrData instanceof triple_1.Triple) {\n        return PointFactory.newPoint3D(xOrData.getFirst(), xOrData.getSecond(), xOrData.getThird(), true, false);\n    }\n    else if (xOrData instanceof (Array)) {\n        if (xOrData.length != 3)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the array must have exactly 3 elements and not [\" + xOrData.length + \"]\");\n        return PointFactory.newPoint3D(xOrData[0], xOrData[1], xOrData[2], true, false);\n    }\n    else if (xOrData instanceof abstract_matrix_1.AbstractMatrix) {\n        if (xOrData.rowSize() == 1 && xOrData.columnSize() == 3) {\n            return PointFactory.newPoint3D(xOrData.get(0, 0), xOrData.get(0, 1), xOrData.get(0, 2), true, false);\n        }\n        else if (xOrData.rowSize() == 3 && xOrData.columnSize() == 1) {\n            return PointFactory.newPoint3D(xOrData.get(0, 0), xOrData.get(1, 0), xOrData.get(2, 0), true, false);\n        }\n        else {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the matrix must have dimension 1x3 or 3x1 and not [\" +\n                xOrData.rowSize() + \"x\" + xOrData.columnSize() + \"]\");\n        }\n    }\n    throw new illegal_argument_exception_1.IllegalArgumentException(\"invalid parameter type [\" + (0, types_1.getTypeName)(xOrData) + \"]\");\n}\nexports.frozenPoint3D = frozenPoint3D;\nfunction mutablePoint3D(xOrData, y, z) {\n    if (typeof xOrData == \"number\") {\n        return PointFactory.newPoint3D(xOrData, y, z, false);\n    }\n    else if (xOrData instanceof triple_1.Triple) {\n        return PointFactory.newPoint3D(xOrData.getFirst(), xOrData.getSecond(), xOrData.getThird(), false);\n    }\n    else if (xOrData instanceof (Array)) {\n        if (xOrData.length != 3)\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the array must have exactly 3 elements and not [\" + xOrData.length + \"]\");\n        return PointFactory.newPoint3D(xOrData[0], xOrData[1], xOrData[2], false);\n    }\n    else if (xOrData instanceof abstract_matrix_1.AbstractMatrix) {\n        if (xOrData.rowSize() == 1 && xOrData.columnSize() == 3) {\n            return PointFactory.newPoint3D(xOrData.get(0, 0), xOrData.get(0, 1), xOrData.get(0, 2), false);\n        }\n        else if (xOrData.rowSize() == 3 && xOrData.columnSize() == 1) {\n            return PointFactory.newPoint3D(xOrData.get(0, 0), xOrData.get(1, 0), xOrData.get(2, 0), false);\n        }\n        else {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"the matrix must have dimension 1x3 or 3x1 and not [\" +\n                xOrData.rowSize() + \"x\" + xOrData.columnSize() + \"]\");\n        }\n    }\n    throw new illegal_argument_exception_1.IllegalArgumentException(\"invalid parameter type [\" + (0, types_1.getTypeName)(xOrData) + \"]\");\n}\nexports.mutablePoint3D = mutablePoint3D;\n/**\n * Creates and returns a new `Point3D` that is located into the **origin** (0, 0, 0)\n * @param {boolean} frozen a flag that indicates if the returning point have to be frozen (`false`\n * by default)\n * @param {boolean} denyModifiedCopy the flag to deny the return of a modified copy if\n * the point is frozen (`true` by default)\n * @return the new point that coincide with the origin\n */\nfunction origin(frozen = true, denyModifiedCopy = false) {\n    return PointFactory.newPoint3D(0, 0, 0, frozen, denyModifiedCopy);\n}\nexports.origin = origin;\n\n\n//# sourceURL=webpack:///./src/ts/geometry/point/point-factory.ts?");

/***/ }),

/***/ "./src/ts/log/log.ts":
/*!***************************!*\
  !*** ./src/ts/log/log.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _a, _Log_logEnabled;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Log = void 0;\nclass Log {\n    static enableLog() {\n        __classPrivateFieldSet(Log, _a, true, \"f\", _Log_logEnabled);\n    }\n    static disableLog() {\n        __classPrivateFieldSet(Log, _a, false, \"f\", _Log_logEnabled);\n    }\n    static log(message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.log(message, ...optionalParams);\n        }\n    }\n    static logNamed(name, message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.log(name + \" | \" + message, ...optionalParams);\n        }\n    }\n    static logError(message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.error(message, ...optionalParams);\n        }\n    }\n    static logWarning(message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.warn(message, ...optionalParams);\n        }\n    }\n    static logInfo(message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.info(message, ...optionalParams);\n        }\n    }\n    static logDebug(message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.debug(message, ...optionalParams);\n        }\n    }\n    static logTrace(message, ...optionalParams) {\n        if (__classPrivateFieldGet(Log, _a, \"f\", _Log_logEnabled)) {\n            console.trace(message);\n        }\n    }\n}\nexports.Log = Log;\n_a = Log;\n_Log_logEnabled = { value: void 0 };\n\n\n//# sourceURL=webpack:///./src/ts/log/log.ts?");

/***/ }),

/***/ "./src/ts/obj/flowed-mesh-object.ts":
/*!******************************************!*\
  !*** ./src/ts/obj/flowed-mesh-object.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FlowedMeshObject_name, _FlowedMeshObject_data, _FlowedMeshObject_position, _FlowedMeshObject_polarRotation, _FlowedMeshObject_scale, _FlowedMeshObject_limitChecker, _FlowedMeshObject_hidden, _FlowedMeshObject_translationFlow, _FlowedMeshObject_polarRotationFlow, _FlowedMeshObject_scaleFlow, _FlowedMeshObject_performedTranslationBuilder, _FlowedMeshObject_performedPolarRotationBuilder, _FlowedMeshObject_performedScaleBuilder;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FlowedMeshObject = void 0;\nconst number_trio_1 = __webpack_require__(/*! ../types/numbers/number-trio */ \"./src/ts/types/numbers/number-trio.ts\");\nconst limits_checkers_1 = __webpack_require__(/*! ../geometry/limits/limits-checkers */ \"./src/ts/geometry/limits/limits-checkers.ts\");\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst flow_1 = __webpack_require__(/*! ../signals/flow */ \"./src/ts/signals/flow.ts\");\nconst performed_translation_1 = __webpack_require__(/*! ../geometry/data/performed-translation */ \"./src/ts/geometry/data/performed-translation.ts\");\nconst performed_polar_rotation_1 = __webpack_require__(/*! ../geometry/data/performed-polar-rotation */ \"./src/ts/geometry/data/performed-polar-rotation.ts\");\nconst point_factory_1 = __webpack_require__(/*! ../geometry/point/point-factory */ \"./src/ts/geometry/point/point-factory.ts\");\nconst performed_scale_1 = __webpack_require__(/*! ../geometry/data/performed-scale */ \"./src/ts/geometry/data/performed-scale.ts\");\nconst mesh_object_signals_1 = __webpack_require__(/*! ./mesh-object-signals */ \"./src/ts/obj/mesh-object-signals.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nconst triple_1 = __webpack_require__(/*! ../types/triple */ \"./src/ts/types/triple.ts\");\nclass FlowedMeshObject {\n    constructor(name, data) {\n        _FlowedMeshObject_name.set(this, void 0);\n        _FlowedMeshObject_data.set(this, void 0);\n        _FlowedMeshObject_position.set(this, void 0);\n        _FlowedMeshObject_polarRotation.set(this, void 0);\n        _FlowedMeshObject_scale.set(this, void 0);\n        _FlowedMeshObject_limitChecker.set(this, void 0);\n        _FlowedMeshObject_hidden.set(this, void 0);\n        _FlowedMeshObject_translationFlow.set(this, void 0);\n        _FlowedMeshObject_polarRotationFlow.set(this, void 0);\n        _FlowedMeshObject_scaleFlow.set(this, void 0);\n        _FlowedMeshObject_performedTranslationBuilder.set(this, void 0);\n        _FlowedMeshObject_performedPolarRotationBuilder.set(this, void 0);\n        _FlowedMeshObject_performedScaleBuilder.set(this, void 0);\n        __classPrivateFieldSet(this, _FlowedMeshObject_name, name, \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_data, data, \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_position, (0, point_factory_1.mutablePoint3D)(0, 0, 0), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_polarRotation, (0, triple_1.trioOf)((0, angle_1.angle)(0), (0, angle_1.angle)(0), (0, angle_1.angle)(0)), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_scale, (0, number_trio_1.numberTrio)(1, 1, 1), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_limitChecker, limits_checkers_1.LimitsCheckers.unlimited(), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_hidden, false, \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_translationFlow, flow_1.default.newSingleFlow(mesh_object_signals_1.MeshObjectSignals.translationSignalNameOf(name)), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_polarRotationFlow, flow_1.default.newSingleFlow(mesh_object_signals_1.MeshObjectSignals.polarRotationSignalNameOf(name)), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_scaleFlow, flow_1.default.newSingleFlow(mesh_object_signals_1.MeshObjectSignals.scaleSignalNameOf(name)), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_performedTranslationBuilder, new performed_translation_1.PerformedTranslationBuilder(), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_performedPolarRotationBuilder, new performed_polar_rotation_1.PerformedPolarRotationBuilder(), \"f\");\n        __classPrivateFieldSet(this, _FlowedMeshObject_performedScaleBuilder, new performed_scale_1.PerformedScaleBuilder(), \"f\");\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedTranslationBuilder, \"f\").who = name;\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedPolarRotationBuilder, \"f\").who = name;\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedScaleBuilder, \"f\").who = name;\n    }\n    draw(gl, programInfo, clear) {\n        if (clear == undefined) {\n            clear = false;\n        }\n        if (clear) {\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        }\n        if (!__classPrivateFieldGet(this, _FlowedMeshObject_hidden, \"f\")) {\n            let u_world = __classPrivateFieldGet(this, _FlowedMeshObject_data, \"f\").u_world;\n            for (let { bufferInfo, material } of __classPrivateFieldGet(this, _FlowedMeshObject_data, \"f\").parts) {\n                // calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer\n                WebGLUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n                // calls gl.uniform\n                WebGLUtils.setUniforms(programInfo, {\n                    u_colorMult: [1, 1, 1, 1],\n                    u_color: [1, 1, 1, 1],\n                    u_world: u_world,\n                }, material);\n                // calls gl.drawArrays or gl.drawElements\n                WebGLUtils.drawBufferInfo(gl, bufferInfo);\n            }\n            // for (let part of this.#data.parts) {\n            //   // calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer\n            //   WebGLUtils.setBuffersAndAttributes(gl, programInfo, part.bufferInfo);\n            //   // calls gl.uniform\n            //   WebGLUtils.setUniforms(programInfo, { u_world }, part.material);\n            //   // calls gl.drawArrays or gl.drawElements\n            //   WebGLUtils.drawBufferInfo(gl, part.bufferInfo);\n            // }\n            log_1.Log.log(\"MeshObject[\" + __classPrivateFieldGet(this, _FlowedMeshObject_name, \"f\") + \"] | drawn\");\n        }\n        else {\n            log_1.Log.log(\"MeshObject[\" + __classPrivateFieldGet(this, _FlowedMeshObject_name, \"f\") + \"] | hidden, draw skipped\");\n        }\n    }\n    getCurrentScale() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").clone();\n    }\n    getHidden() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_hidden, \"f\");\n    }\n    getLimitsChecker() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_limitChecker, \"f\");\n    }\n    getPosition() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").clone();\n    }\n    getName() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_name, \"f\");\n    }\n    getPolarRotation() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").clone();\n    }\n    getPolarRotationSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_polarRotationFlow, \"f\");\n    }\n    getScaleSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_scaleFlow, \"f\");\n    }\n    getTranslationSubscriber() {\n        return __classPrivateFieldGet(this, _FlowedMeshObject_translationFlow, \"f\");\n    }\n    glInit(gl) {\n        __classPrivateFieldGet(this, _FlowedMeshObject_data, \"f\").u_world = M4.identity();\n        log_1.Log.log(\"MeshObject[\" + __classPrivateFieldGet(this, _FlowedMeshObject_name, \"f\") + \"] initialized\");\n    }\n    setHidden(hidden) {\n        __classPrivateFieldSet(this, _FlowedMeshObject_hidden, hidden, \"f\");\n    }\n    setLimitsChecker(limitsChecker) {\n        __classPrivateFieldSet(this, _FlowedMeshObject_limitChecker, limitsChecker, \"f\");\n    }\n    setPolarRotation(psi, theta, phi) {\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedPolarRotationBuilder, \"f\").clear();\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedPolarRotationBuilder, \"f\").from = __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").clone();\n        __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").setFirst(psi);\n        __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").setSecond(theta);\n        __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").setThird(phi);\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedPolarRotationBuilder, \"f\").to = __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").clone();\n        __classPrivateFieldGet(this, _FlowedMeshObject_polarRotationFlow, \"f\").fire(this, __classPrivateFieldGet(this, _FlowedMeshObject_performedPolarRotationBuilder, \"f\").build());\n        this.updateUMatrix();\n    }\n    setPosition(position, y, z) {\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedTranslationBuilder, \"f\").clear();\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedTranslationBuilder, \"f\").from = __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").clone();\n        if (typeof position === \"number\") {\n            __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").set(position, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").set(position.getX(), position.getY(), position.getZ());\n        }\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedTranslationBuilder, \"f\").to = __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").clone();\n        __classPrivateFieldGet(this, _FlowedMeshObject_translationFlow, \"f\").fire(this, __classPrivateFieldGet(this, _FlowedMeshObject_performedTranslationBuilder, \"f\").build());\n        this.updateUMatrix();\n    }\n    setScale(scale, y, z) {\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedScaleBuilder, \"f\").clear();\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedScaleBuilder, \"f\").from = __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").clone();\n        if (typeof scale === \"number\") {\n            __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").setFirst(scale);\n            __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").setSecond(y);\n            __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").setThird(z);\n        }\n        else {\n            __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").setFirst(scale.getFirst());\n            __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").setSecond(scale.getSecond());\n            __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").setThird(scale.getThird());\n        }\n        __classPrivateFieldGet(this, _FlowedMeshObject_performedScaleBuilder, \"f\").to = __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").clone();\n        __classPrivateFieldGet(this, _FlowedMeshObject_scaleFlow, \"f\").fire(this, __classPrivateFieldGet(this, _FlowedMeshObject_performedScaleBuilder, \"f\").build());\n        this.updateUMatrix();\n    }\n    updateUMatrix(u_world = M4.identity(), position = true, rotation = true, scale = true) {\n        if (position) {\n            u_world = M4.translate(u_world, __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").getX(), __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").getY(), __classPrivateFieldGet(this, _FlowedMeshObject_position, \"f\").getZ());\n        }\n        if (rotation) {\n            u_world = M4.xRotate(u_world, __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").getFirst().getValueIn(angle_1.AngleUnit.RAD));\n            u_world = M4.yRotate(u_world, __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").getSecond().getValueIn(angle_1.AngleUnit.RAD));\n            u_world = M4.zRotate(u_world, __classPrivateFieldGet(this, _FlowedMeshObject_polarRotation, \"f\").getThird().getValueIn(angle_1.AngleUnit.RAD));\n        }\n        if (scale) {\n            u_world = M4.scale(u_world, __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").getFirst(), __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").getSecond(), __classPrivateFieldGet(this, _FlowedMeshObject_scale, \"f\").getThird());\n        }\n        __classPrivateFieldGet(this, _FlowedMeshObject_data, \"f\").u_world = u_world;\n        log_1.Log.log(\"MeshObject[\" + __classPrivateFieldGet(this, _FlowedMeshObject_name, \"f\") + \"] | u_world updated: \" + u_world);\n    }\n}\nexports.FlowedMeshObject = FlowedMeshObject;\n_FlowedMeshObject_name = new WeakMap(), _FlowedMeshObject_data = new WeakMap(), _FlowedMeshObject_position = new WeakMap(), _FlowedMeshObject_polarRotation = new WeakMap(), _FlowedMeshObject_scale = new WeakMap(), _FlowedMeshObject_limitChecker = new WeakMap(), _FlowedMeshObject_hidden = new WeakMap(), _FlowedMeshObject_translationFlow = new WeakMap(), _FlowedMeshObject_polarRotationFlow = new WeakMap(), _FlowedMeshObject_scaleFlow = new WeakMap(), _FlowedMeshObject_performedTranslationBuilder = new WeakMap(), _FlowedMeshObject_performedPolarRotationBuilder = new WeakMap(), _FlowedMeshObject_performedScaleBuilder = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/obj/flowed-mesh-object.ts?");

/***/ }),

/***/ "./src/ts/obj/mesh-object-drawer.ts":
/*!******************************************!*\
  !*** ./src/ts/obj/mesh-object-drawer.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MeshObjectDrawer_glEnvironment, _MeshObjectDrawer_meshObjectManager, _MeshObjectDrawer_camera, _MeshObjectDrawer_sharedUniforms, _MeshObjectDrawer_slManager, _MeshObjectDrawer_lightFrustum, _MeshObjectDrawer_bias, _MeshObjectDrawer_cubeLinesBufferInfo;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MeshObjectDrawer = void 0;\nconst flowed_camera_1 = __webpack_require__(/*! ../camera/flowed-camera */ \"./src/ts/camera/flowed-camera.ts\");\nconst webgl_wrappers_1 = __webpack_require__(/*! ../webgl/webgl-wrappers */ \"./src/ts/webgl/webgl-wrappers.ts\");\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nconst sl_manager_1 = __webpack_require__(/*! ./sl-manager */ \"./src/ts/obj/sl-manager.ts\");\nclass MeshObjectDrawer {\n    constructor(applicationName, glEnvironment, meshObjectManager) {\n        _MeshObjectDrawer_glEnvironment.set(this, void 0);\n        _MeshObjectDrawer_meshObjectManager.set(this, void 0);\n        this.zNear = 0.1;\n        this.zFar = 200;\n        _MeshObjectDrawer_camera.set(this, new flowed_camera_1.default());\n        _MeshObjectDrawer_sharedUniforms.set(this, void 0);\n        _MeshObjectDrawer_slManager.set(this, void 0);\n        _MeshObjectDrawer_lightFrustum.set(this, void 0);\n        _MeshObjectDrawer_bias.set(this, void 0);\n        _MeshObjectDrawer_cubeLinesBufferInfo.set(this, void 0);\n        this.applicationName = applicationName;\n        __classPrivateFieldSet(this, _MeshObjectDrawer_glEnvironment, glEnvironment, \"f\");\n        __classPrivateFieldSet(this, _MeshObjectDrawer_meshObjectManager, meshObjectManager, \"f\");\n        __classPrivateFieldSet(this, _MeshObjectDrawer_sharedUniforms, new webgl_wrappers_1.SharedUniforms(), \"f\");\n        __classPrivateFieldSet(this, _MeshObjectDrawer_slManager, new sl_manager_1.SlManager(__classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\")), \"f\");\n        __classPrivateFieldSet(this, _MeshObjectDrawer_lightFrustum, false, \"f\");\n        __classPrivateFieldSet(this, _MeshObjectDrawer_bias, -0.006, \"f\");\n        __classPrivateFieldSet(this, _MeshObjectDrawer_cubeLinesBufferInfo, WebGLUtils.createBufferInfoFromArrays(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getContext(), {\n            position: [\n                -1, -1, -1,\n                1, -1, -1,\n                -1, 1, -1,\n                1, 1, -1,\n                -1, -1, 1,\n                1, -1, 1,\n                -1, 1, 1,\n                1, 1, 1,\n            ],\n            indices: [\n                0, 1,\n                1, 3,\n                3, 2,\n                2, 0,\n                4, 5,\n                5, 7,\n                7, 6,\n                6, 4,\n                0, 4,\n                1, 5,\n                3, 7,\n                2, 6,\n            ],\n        }), \"f\");\n    }\n    /**\n     * Updates the internal *View Matrix* using the camera\n     */\n    updateViewMatrix() {\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | updating view matrix\");\n        __classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\").u_view = M4.inverse(__classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").calculateCameraMatrix());\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | view matrix updated\");\n    }\n    /**\n     * Updates the internal *Projection Matrix* using the camera, the canvas, the zNear and the zFar\n     */\n    updateProjectionMatrix() {\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | updating projection matrix\");\n        __classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\").u_projection = M4.perspective(__classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentFov().getValueIn(angle_1.AngleUnit.RAD), __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").calculateAspectRatio(), this.zNear, this.zFar);\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | projection matrix updated\");\n    }\n    drawSceneWith(projectionMatrix, cameraMatrix, textureMatrix, lightWorldMatrix, programInfo) {\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName +\n            \"] | starting drawing with program info [\" + programInfo + \"]\");\n        let gl = __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getContext();\n        let viewMatrix = M4.inverse(cameraMatrix);\n        gl.useProgram(programInfo.program);\n        WebGLUtils.setUniforms(programInfo, {\n            u_view: viewMatrix,\n            u_projection: projectionMatrix,\n            u_bias: __classPrivateFieldGet(this, _MeshObjectDrawer_bias, \"f\"),\n            u_textureMatrix: textureMatrix,\n            u_projectedTexture: sl_manager_1.SlManager.getTextureForLights(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getContext()).getFirst(),\n            u_lightDirection: __classPrivateFieldGet(this, _MeshObjectDrawer_slManager, \"f\").calculateLightWorldMatrix().slice(8, 11),\n        });\n        gl.uniform1f(gl.getUniformLocation(programInfo.program, \"mesh\"), 1.);\n        for (let meshObject of __classPrivateFieldGet(this, _MeshObjectDrawer_meshObjectManager, \"f\").getAll()) {\n            log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | drawing mesh object [\" + meshObject.getName() + \"]\");\n            meshObject.draw(gl, programInfo, false);\n        }\n    }\n    render() {\n        let gl = __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getContext();\n        gl.enable(gl.CULL_FACE);\n        gl.enable(gl.DEPTH_TEST);\n        let lightWorldMatrix = __classPrivateFieldGet(this, _MeshObjectDrawer_slManager, \"f\").calculateLightWorldMatrix();\n        let lightProjectionMatrix = __classPrivateFieldGet(this, _MeshObjectDrawer_slManager, \"f\").calculateLightProjectionMatrix();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, sl_manager_1.SlManager.getTextureForLights(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getContext()).getSecond());\n        gl.viewport(0, 0, sl_manager_1.SlManager.depthTextureSize, sl_manager_1.SlManager.depthTextureSize);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        /* TO ADJUST BASED ON WHICH PROGRAMS ARE PRESENT AND USED */\n        if (__classPrivateFieldGet(this, _MeshObjectDrawer_slManager, \"f\").getShadows()) {\n            this.drawSceneWith(lightProjectionMatrix, lightWorldMatrix, M4.identity(), lightWorldMatrix, __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgramInfo('color'));\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        let textureMatrix = M4.identity();\n        textureMatrix = M4.translate(textureMatrix, 0.5, 0.5, 0.5);\n        textureMatrix = M4.scale(textureMatrix, 0.5, 0.5, 0.5);\n        textureMatrix = M4.multiply(textureMatrix, lightProjectionMatrix);\n        textureMatrix = M4.multiply(textureMatrix, M4.inverse(lightWorldMatrix));\n        this.updateProjectionMatrix();\n        this.updateViewMatrix();\n        let viewProjectionMatrix = M4.multiply(__classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\").u_projection, __classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\").u_view);\n        this.drawSceneWith(viewProjectionMatrix, __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").calculateCameraMatrix(), textureMatrix, lightWorldMatrix, __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgramInfo('main'));\n        if (__classPrivateFieldGet(this, _MeshObjectDrawer_lightFrustum, \"f\")) {\n            let viewMatrix = M4.inverse(__classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").calculateCameraMatrix());\n            gl.useProgram(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgramInfo('color').program);\n            WebGLUtils.setBuffersAndAttributes(gl, __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgramInfo('color'), __classPrivateFieldGet(this, _MeshObjectDrawer_cubeLinesBufferInfo, \"f\"));\n            const mat = M4.multiply(lightWorldMatrix, M4.inverse(lightProjectionMatrix));\n            WebGLUtils.setUniforms(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgramInfo('color'), {\n                u_color: [1, 1, 1, 1],\n                u_view: viewMatrix,\n                u_projection: __classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\").u_projection,\n                u_world: mat,\n            });\n            WebGLUtils.drawBufferInfo(gl, __classPrivateFieldGet(this, _MeshObjectDrawer_cubeLinesBufferInfo, \"f\"), gl.LINES);\n        }\n    }\n    /**\n     * Begin the drawing process\n     */\n    startDrawing() {\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | starting drawing...\");\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"]\\n\" +\n            \"\\tcanvas size: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getCanvas().width + \"x\" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getCanvas().height + \"\\n\" +\n            \"\\tcanvas aspect ratio: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").calculateAspectRatio() + \"\\n\" +\n            \"\\tcamera position: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentPosition().toString() + \"\\n\" +\n            \"\\tcamera up: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentUp().toString() + \"\\n\" +\n            \"\\tcamera target: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentTarget().toString() + \"\\n\" +\n            \"\\tfov: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentFov().getValueIn(angle_1.AngleUnit.DEG) + \"°\\n\" +\n            \"\\tzNear: \" + this.zNear + \"\\n\" +\n            \"\\tzFar: \" + this.zFar);\n        let gl = __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getContext();\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | context obtained [\" + gl + \"]\");\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.enable(gl.CULL_FACE);\n        gl.enable(gl.DEPTH_TEST);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        this.updateProjectionMatrix();\n        this.updateViewMatrix();\n        gl.useProgram(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgram());\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | program used [\" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgram() + \"]\");\n        WebGLUtils.setUniforms(__classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getProgramInfo(), __classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\"));\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | uniforms set [\" + __classPrivateFieldGet(this, _MeshObjectDrawer_sharedUniforms, \"f\") + \"]\");\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | start drawing done!\");\n    }\n    /**\n     * Draw the scene using the object manager and the camera\n     */\n    drawScene() {\n        log_1.Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"]\\n\" +\n            \"\\tcanvas size: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getCanvas().width + \"x\" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").getCanvas().height + \"\\n\" +\n            \"\\tcanvas aspect ratio: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_glEnvironment, \"f\").calculateAspectRatio() + \"\\n\" +\n            \"\\tcamera position: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentPosition().toString() + \"\\n\" +\n            \"\\tcamera up: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentUp().toString() + \"\\n\" +\n            \"\\tcamera target: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentTarget().toString() + \"\\n\" +\n            \"\\tfov: \" + __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\").getCurrentFov().getValueIn(angle_1.AngleUnit.DEG) + \"°\\n\" +\n            \"\\tzNear: \" + this.zNear + \"\\n\" +\n            \"\\tzFar: \" + this.zFar);\n        // Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | drawing scene\")\n        //\n        // let gl: WebGLRenderingContext = this.#glEnvironment.getContext()\n        // let programInfo: ProgramInfo = this.#glEnvironment.getProgramInfo()\n        // this.startDrawing()\n        // for(let meshObject of this.#meshObjectManager.getAll()) {\n        //     Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | drawing mesh object [\" + meshObject.getName() + \"]\")\n        //     meshObject.draw(gl, programInfo, false)\n        // }\n        //\n        // Log.log(\"MeshObjectDrawer[\" + this.applicationName + \"] | scene drawn\")\n        this.render();\n    }\n    setBias(bias) {\n        __classPrivateFieldSet(this, _MeshObjectDrawer_bias, bias, \"f\");\n    }\n    /**\n     * Returns the `Camera` associated of this drawer\n     */\n    getCamera() {\n        return __classPrivateFieldGet(this, _MeshObjectDrawer_camera, \"f\");\n    }\n    /**\n     * Returns the manager for the shadows and the lights\n     */\n    getSlManager() {\n        return __classPrivateFieldGet(this, _MeshObjectDrawer_slManager, \"f\");\n    }\n    /**\n     * Returns the `MeshObjectManager` associated of this drawer\n     */\n    getMeshObjectManager() {\n        return __classPrivateFieldGet(this, _MeshObjectDrawer_meshObjectManager, \"f\");\n    }\n    setLightFrustum(lightFrustum) {\n        __classPrivateFieldSet(this, _MeshObjectDrawer_lightFrustum, lightFrustum, \"f\");\n    }\n    getLightFrustum() {\n        return __classPrivateFieldGet(this, _MeshObjectDrawer_lightFrustum, \"f\");\n    }\n    getBias() {\n        return __classPrivateFieldGet(this, _MeshObjectDrawer_bias, \"f\");\n    }\n}\nexports.MeshObjectDrawer = MeshObjectDrawer;\n_MeshObjectDrawer_glEnvironment = new WeakMap(), _MeshObjectDrawer_meshObjectManager = new WeakMap(), _MeshObjectDrawer_camera = new WeakMap(), _MeshObjectDrawer_sharedUniforms = new WeakMap(), _MeshObjectDrawer_slManager = new WeakMap(), _MeshObjectDrawer_lightFrustum = new WeakMap(), _MeshObjectDrawer_bias = new WeakMap(), _MeshObjectDrawer_cubeLinesBufferInfo = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/obj/mesh-object-drawer.ts?");

/***/ }),

/***/ "./src/ts/obj/mesh-object-manager.ts":
/*!*******************************************!*\
  !*** ./src/ts/obj/mesh-object-manager.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MeshObjectManager_glEnvironment, _MeshObjectManager_objects, _MeshObjectManager_loadedObjectFlow;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MeshObjectManager = void 0;\nconst flowed_mesh_object_1 = __webpack_require__(/*! ./flowed-mesh-object */ \"./src/ts/obj/flowed-mesh-object.ts\");\nconst flow_1 = __webpack_require__(/*! ../signals/flow */ \"./src/ts/signals/flow.ts\");\nconst mesh_object_signals_1 = __webpack_require__(/*! ./mesh-object-signals */ \"./src/ts/obj/mesh-object-signals.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\n/**\n * A manager for the mesh object able to load them maintaining their data.\n * When an object is loaded using this manager, its MeshObject is saved into\n * an internal map and can be retrieved as needed simply calling the 'get' function\n */\nclass MeshObjectManager {\n    constructor(applicationName, environment) {\n        _MeshObjectManager_glEnvironment.set(this, void 0);\n        _MeshObjectManager_objects.set(this, void 0);\n        _MeshObjectManager_loadedObjectFlow.set(this, void 0);\n        this.applicationName = applicationName;\n        __classPrivateFieldSet(this, _MeshObjectManager_glEnvironment, environment, \"f\");\n        __classPrivateFieldSet(this, _MeshObjectManager_objects, new Map(), \"f\");\n        __classPrivateFieldSet(this, _MeshObjectManager_loadedObjectFlow, flow_1.default.newSingleFlow(mesh_object_signals_1.MeshObjectSignals.OBJECT_LOADED_SIGNAL_STRING_NAME), \"f\");\n    }\n    /**\n     * Loads an '.obj' file using the 'load_mesh.js' and stores its data\n     * into a MeshObject, saving it into the internal map of this manager.\n     * The name is associated to the created object and can be used to retrieve\n     * it when calling the 'get' function\n     * @param {string} name the name associated to the object\n     * @param {string} path the path of the '.obj' file\n     * @returns the new MeshObject that is also stored into the manager\n     */\n    loadObj(name, path) {\n        log_1.Log.log(\"MeshObjectManager[\" + this.applicationName + \"] | loading object '\" + name + \"' from '\" + path + \"'\");\n        let data = loadObjX(__classPrivateFieldGet(this, _MeshObjectManager_glEnvironment, \"f\").getContext(), path);\n        let res = new flowed_mesh_object_1.FlowedMeshObject(name, data);\n        __classPrivateFieldGet(this, _MeshObjectManager_objects, \"f\").set(name, res);\n        res.glInit(__classPrivateFieldGet(this, _MeshObjectManager_glEnvironment, \"f\").getContext());\n        __classPrivateFieldGet(this, _MeshObjectManager_loadedObjectFlow, \"f\").fire(this, res);\n        return res;\n    }\n    /**\n     * Loads a mesh object using the raw data passed as parameter and stores its\n     * data into a MeshObject, saving it into the internal map of this manager.\n     * The name is associated to the created object and can be used to retrieve\n     * it when calling the 'get' function\n     * @param {string} name the name associated to the object\n     * @param {any} position the data about the position of the vertex\n     * @param {any} texcoord the data about the texcoords\n     * @param {any} normal the data about the normals\n     * @param {any} indices the data about the indices\n     * @returns the new MeshObject that is also stored into the manager\n     */\n    loadFromRawData(name, position, texcoord, normal, indices) {\n        let attributes = {\n            position: { data: position },\n            texcoord: undefined,\n            normal: undefined\n        };\n        if (texcoord != null) {\n            attributes.texcoord = { data: texcoord };\n        }\n        if (normal != null) {\n            attributes.normal = { data: normal };\n        }\n        if (indices != null) {\n            attributes.indices = { data: indices };\n        }\n        let data = {\n            mesh: null,\n            attributes: attributes,\n            numVertices: undefined,\n            uniforms: undefined\n        };\n        let meshObj = new flowed_mesh_object_1.FlowedMeshObject(name, data);\n        __classPrivateFieldGet(this, _MeshObjectManager_objects, \"f\").set(name, meshObj);\n        meshObj.glInit(__classPrivateFieldGet(this, _MeshObjectManager_glEnvironment, \"f\").getContext());\n        __classPrivateFieldGet(this, _MeshObjectManager_loadedObjectFlow, \"f\").fire(this, meshObj);\n        return meshObj;\n    }\n    ;\n    /**\n     * Returns the subscriber for the signal that is triggered every time a new object is loaded\n     * @returns {SingleSignalFlow<MeshObjectManager, MeshObject, void>} the subscriber for the signal\n     * that is triggered every time a new object is loaded\n     */\n    getLoadedObjectSubscriber() {\n        return __classPrivateFieldGet(this, _MeshObjectManager_loadedObjectFlow, \"f\");\n    }\n    /**\n     * Returns the MeshObject associated with the given name or 'undefined' if\n     * no object is associated to it\n     * @param {string} name the name associated to the object\n     * @returns {MeshObject} the MeshObject associated with the given name or 'undefined' if\n     * no object is associated to it\n     */\n    get(name) {\n        return __classPrivateFieldGet(this, _MeshObjectManager_objects, \"f\").get(name);\n    }\n    ;\n    /**\n     * Returns all the objects saved into this manager\n     * @returns {Array<MeshObject>} all of the objects saved into this manager\n     */\n    getAll() {\n        return new Array(...__classPrivateFieldGet(this, _MeshObjectManager_objects, \"f\").values());\n    }\n}\nexports.MeshObjectManager = MeshObjectManager;\n_MeshObjectManager_glEnvironment = new WeakMap(), _MeshObjectManager_objects = new WeakMap(), _MeshObjectManager_loadedObjectFlow = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/obj/mesh-object-manager.ts?");

/***/ }),

/***/ "./src/ts/obj/mesh-object-signals.ts":
/*!*******************************************!*\
  !*** ./src/ts/obj/mesh-object-signals.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MeshObjectSignals = void 0;\nconst flow_1 = __webpack_require__(/*! ../signals/flow */ \"./src/ts/signals/flow.ts\");\nclass MeshObjectSignals {\n    /**\n     * Creates the string name of the signal that is emitted when the object is translated\n     * @param {string} name the name of the **mesh** object\n     * @returns {string} the string name of the signal that is emitted when the object is translated\n     */\n    static translationSignalNameOf(name) {\n        return \"mesh-objects.\" + name + \".translation\";\n    }\n    /**\n     * Creates the string name of the signal that is emitted when the object is polar rotated\n     * @param {string} name the name of the **mesh** object\n     * @returns {string} the string name of the signal that is emitted when the object is polar rotated\n     */\n    static polarRotationSignalNameOf(name) {\n        return \"mesh-objects.\" + name + \".polar-rotation\";\n    }\n    /**\n     * Creates the string name of the signal that is emitted when the object is scaled\n     * @param {string} name the name of the **mesh** object\n     * @returns {string} the string name of the signal that is emitted when the object is scaled\n     */\n    static scaleSignalNameOf(name) {\n        return \"mesh-objects.\" + name + \".scale\";\n    }\n    /**\n     * Returns the registered `SignalName` for the translation signal of the given object\n     * @param {string} name the name of the **mesh** object\n     * @returns {SignalName} the registered `SignalName` for the translation signal of the given object\n     */\n    static getTranslationSignalNameOf(name) {\n        return flow_1.default.getSignalName(MeshObjectSignals.translationSignalNameOf(name));\n    }\n    /**\n     * Returns the registered `SignalName` for the polar rotation signal of the given object\n     * @param {string} name the name of the **mesh** object\n     * @returns {SignalName} the registered `SignalName` for the polar rotation signal of the given object\n     */\n    static getPolarRotationSignalNameOf(name) {\n        return flow_1.default.getSignalName(MeshObjectSignals.polarRotationSignalNameOf(name));\n    }\n    /**\n     * Returns the registered `SignalName` for the scale signal of the given object\n     * @param {string} name the name of the **mesh** object\n     * @returns {SignalName} the registered `SignalName` for the scale signal of the given object\n     */\n    static getScaleSignalNameOf(name) {\n        return flow_1.default.getSignalName(MeshObjectSignals.scaleSignalNameOf(name));\n    }\n    /**\n     * Returns the subscriber for the translation signal of the given object\n     * @param {MeshObject} obj the object\n     * @returns {SingleSignalSubscriber<PerformedTranslation>} the subscriber for the translation signal of the given object     *\n     */\n    static getTranslationSubscriberOf(obj) {\n        return flow_1.default.getSubscriber(MeshObjectSignals.translationSignalNameOf(obj.getName()));\n    }\n}\nexports.MeshObjectSignals = MeshObjectSignals;\n/**\n * The string name of the signal that is emitted when the object is loaded by the manager\n */\nMeshObjectSignals.OBJECT_LOADED_SIGNAL_STRING_NAME = \"mesh-manager.loaded\";\n\n\n//# sourceURL=webpack:///./src/ts/obj/mesh-object-signals.ts?");

/***/ }),

/***/ "./src/ts/obj/sl-manager.ts":
/*!**********************************!*\
  !*** ./src/ts/obj/sl-manager.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _SlManager_instances, _a, _SlManager_depthTB, _SlManager_lightDirection, _SlManager_sharedUniforms, _SlManager_lightPosition, _SlManager_lightTarget, _SlManager_lightUp, _SlManager_lightFov, _SlManager_spotlight, _SlManager_projWidth, _SlManager_projHeight, _SlManager_shadows, _SlManager_near, _SlManager_far, _SlManager_updateSharedUniforms;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SlManager = void 0;\nconst number_trio_1 = __webpack_require__(/*! ../types/numbers/number-trio */ \"./src/ts/types/numbers/number-trio.ts\");\nconst point_factory_1 = __webpack_require__(/*! ../geometry/point/point-factory */ \"./src/ts/geometry/point/point-factory.ts\");\nconst angle_1 = __webpack_require__(/*! ../geometry/angle/angle */ \"./src/ts/geometry/angle/angle.ts\");\nconst pair_1 = __webpack_require__(/*! ../types/pair */ \"./src/ts/types/pair.ts\");\nclass SlManager {\n    static getTextureForLights(gl) {\n        let res = __classPrivateFieldGet(SlManager, _a, \"f\", _SlManager_depthTB).get(gl);\n        if (res === undefined) {\n            let depthTexture = gl.createTexture();\n            let depthTextureSize = this.depthTextureSize;\n            gl.bindTexture(gl.TEXTURE_2D, depthTexture);\n            gl.texImage2D(gl.TEXTURE_2D, // target\n            0, // mip level\n            gl.DEPTH_COMPONENT, // internal format\n            depthTextureSize, // width\n            depthTextureSize, // height\n            0, // border\n            gl.DEPTH_COMPONENT, // format\n            gl.UNSIGNED_INT, // type\n            null); // data\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            let depthFramebuffer = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, // target\n            gl.DEPTH_ATTACHMENT, // attachment point\n            gl.TEXTURE_2D, // texture target\n            depthTexture, // texture\n            0); // mip level\n            // --------------------------------------------------\n            // UNUSED TEXTURE\n            // create a color texture of the same size as the depth texture\n            // see article why this is needed_\n            let unusedTexture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, unusedTexture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, depthTextureSize, depthTextureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // attach it to the framebuffer\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, // target\n            gl.COLOR_ATTACHMENT0, // attachment point\n            gl.TEXTURE_2D, // texture target\n            unusedTexture, // texture\n            0);\n            res = (0, pair_1.pairOf)(depthTexture, depthFramebuffer);\n            __classPrivateFieldGet(this, _a, \"f\", _SlManager_depthTB).set(gl, res);\n        }\n        return res;\n    }\n    constructor(sharedUniforms) {\n        _SlManager_instances.add(this);\n        _SlManager_lightDirection.set(this, (0, number_trio_1.numberTrio)(0, 0, 0));\n        _SlManager_sharedUniforms.set(this, void 0);\n        _SlManager_lightPosition.set(this, (0, point_factory_1.mutablePoint3D)(0, 0, 100));\n        _SlManager_lightTarget.set(this, (0, point_factory_1.mutablePoint3D)(0, 0, 0));\n        _SlManager_lightUp.set(this, (0, number_trio_1.numberTrio)(0, 1, 0));\n        _SlManager_lightFov.set(this, (0, angle_1.radians)(0));\n        _SlManager_spotlight.set(this, false);\n        _SlManager_projWidth.set(this, 10);\n        _SlManager_projHeight.set(this, 10);\n        _SlManager_shadows.set(this, false);\n        _SlManager_near.set(this, 1);\n        _SlManager_far.set(this, 700);\n        __classPrivateFieldSet(this, _SlManager_sharedUniforms, sharedUniforms, \"f\");\n    }\n    calculateLightWorldMatrix() {\n        return M4.lookAt([__classPrivateFieldGet(this, _SlManager_lightPosition, \"f\").getX(), __classPrivateFieldGet(this, _SlManager_lightPosition, \"f\").getY(), __classPrivateFieldGet(this, _SlManager_lightPosition, \"f\").getZ()], [__classPrivateFieldGet(this, _SlManager_lightTarget, \"f\").getX(), __classPrivateFieldGet(this, _SlManager_lightTarget, \"f\").getY(), __classPrivateFieldGet(this, _SlManager_lightTarget, \"f\").getZ()], [__classPrivateFieldGet(this, _SlManager_lightUp, \"f\").getFirst(), __classPrivateFieldGet(this, _SlManager_lightUp, \"f\").getSecond(), __classPrivateFieldGet(this, _SlManager_lightUp, \"f\").getThird()]);\n    }\n    calculateLightProjectionMatrix() {\n        if (__classPrivateFieldGet(this, _SlManager_spotlight, \"f\")) {\n            return M4.perspective(__classPrivateFieldGet(this, _SlManager_lightFov, \"f\").getValueIn(angle_1.AngleUnit.RAD), __classPrivateFieldGet(this, _SlManager_projWidth, \"f\") / __classPrivateFieldGet(this, _SlManager_projHeight, \"f\"), __classPrivateFieldGet(this, _SlManager_near, \"f\"), __classPrivateFieldGet(this, _SlManager_far, \"f\"));\n        }\n        else {\n            return M4.orthographic(-__classPrivateFieldGet(this, _SlManager_projWidth, \"f\") / 2, __classPrivateFieldGet(this, _SlManager_projWidth, \"f\") / 2, -__classPrivateFieldGet(this, _SlManager_projHeight, \"f\") / 2, __classPrivateFieldGet(this, _SlManager_projHeight, \"f\") / 2, __classPrivateFieldGet(this, _SlManager_near, \"f\"), __classPrivateFieldGet(this, _SlManager_far, \"f\"));\n        }\n    }\n    getLightDirection() {\n        return __classPrivateFieldGet(this, _SlManager_lightDirection, \"f\").clone();\n    }\n    getLightPosition() {\n        return __classPrivateFieldGet(this, _SlManager_lightPosition, \"f\").clone();\n    }\n    getLightTarget() {\n        return __classPrivateFieldGet(this, _SlManager_lightTarget, \"f\").clone();\n    }\n    getLightUp() {\n        return __classPrivateFieldGet(this, _SlManager_lightUp, \"f\").clone();\n    }\n    getFov() {\n        return __classPrivateFieldGet(this, _SlManager_lightFov, \"f\").clone();\n    }\n    getNear() {\n        return __classPrivateFieldGet(this, _SlManager_near, \"f\");\n    }\n    getFar() {\n        return __classPrivateFieldGet(this, _SlManager_far, \"f\");\n    }\n    isSpotlight() {\n        return __classPrivateFieldGet(this, _SlManager_spotlight, \"f\");\n    }\n    getProjWidth() {\n        return __classPrivateFieldGet(this, _SlManager_projWidth, \"f\");\n    }\n    getProjHeight() {\n        return __classPrivateFieldGet(this, _SlManager_projHeight, \"f\");\n    }\n    setLightDirection(x, y, z) {\n        if (typeof x === \"number\") {\n            __classPrivateFieldGet(this, _SlManager_lightDirection, \"f\").setAll(x, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _SlManager_lightDirection, \"f\").setAll(x.getFirst(), x.getSecond(), x.getThird());\n        }\n    }\n    setLightPosition(x, y, z) {\n        if (typeof x === \"number\") {\n            __classPrivateFieldGet(this, _SlManager_lightPosition, \"f\").set(x, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _SlManager_lightPosition, \"f\").set(x.getX(), x.getY(), x.getZ());\n        }\n        __classPrivateFieldGet(this, _SlManager_instances, \"m\", _SlManager_updateSharedUniforms).call(this);\n    }\n    setLightTarget(x, y, z) {\n        if (typeof x === \"number\") {\n            __classPrivateFieldGet(this, _SlManager_lightTarget, \"f\").set(x, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _SlManager_lightTarget, \"f\").set(x.getX(), x.getY(), x.getZ());\n        }\n    }\n    setLightUp(x, y, z) {\n        if (typeof x === \"number\") {\n            __classPrivateFieldGet(this, _SlManager_lightUp, \"f\").setAll(x, y, z);\n        }\n        else {\n            __classPrivateFieldGet(this, _SlManager_lightUp, \"f\").setAll(x.getFirst(), x.getSecond(), x.getThird());\n        }\n    }\n    setFov(value) {\n        __classPrivateFieldSet(this, _SlManager_lightFov, value, \"f\");\n    }\n    setSpotlight(value) {\n        __classPrivateFieldSet(this, _SlManager_spotlight, value, \"f\");\n    }\n    setProjWidth(value) {\n        __classPrivateFieldSet(this, _SlManager_projWidth, value, \"f\");\n    }\n    setProjHeight(value) {\n        __classPrivateFieldSet(this, _SlManager_projHeight, value, \"f\");\n    }\n    setShadows(value) {\n        __classPrivateFieldSet(this, _SlManager_shadows, value, \"f\");\n    }\n    getShadows() {\n        return __classPrivateFieldGet(this, _SlManager_shadows, \"f\");\n    }\n    setNear(value) {\n        __classPrivateFieldSet(this, _SlManager_near, value, \"f\");\n    }\n    setFar(value) {\n        __classPrivateFieldSet(this, _SlManager_far, value, \"f\");\n    }\n}\nexports.SlManager = SlManager;\n_a = SlManager, _SlManager_lightDirection = new WeakMap(), _SlManager_sharedUniforms = new WeakMap(), _SlManager_lightPosition = new WeakMap(), _SlManager_lightTarget = new WeakMap(), _SlManager_lightUp = new WeakMap(), _SlManager_lightFov = new WeakMap(), _SlManager_spotlight = new WeakMap(), _SlManager_projWidth = new WeakMap(), _SlManager_projHeight = new WeakMap(), _SlManager_shadows = new WeakMap(), _SlManager_near = new WeakMap(), _SlManager_far = new WeakMap(), _SlManager_instances = new WeakSet(), _SlManager_updateSharedUniforms = function _SlManager_updateSharedUniforms() {\n    __classPrivateFieldGet(this, _SlManager_sharedUniforms, \"f\").u_lightDirection = __classPrivateFieldGet(this, _SlManager_lightDirection, \"f\").toArray();\n};\nSlManager.depthTextureSize = 512;\n_SlManager_depthTB = { value: new Map() };\n\n\n//# sourceURL=webpack:///./src/ts/obj/sl-manager.ts?");

/***/ }),

/***/ "./src/ts/signals/exceptions/illegal-signal-name-exception.ts":
/*!********************************************************************!*\
  !*** ./src/ts/signals/exceptions/illegal-signal-name-exception.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IllegalSignalNameException = void 0;\nclass IllegalSignalNameException extends Error {\n    constructor(nameAttempted, cause) {\n        super(\"signal name \\\"\" + nameAttempted + \"\\\" is not valid: \" + cause);\n        this.nameAttempted = nameAttempted;\n        this.cause = cause;\n        Object.setPrototypeOf(this, IllegalSignalNameException.prototype);\n    }\n}\nexports.IllegalSignalNameException = IllegalSignalNameException;\n\n\n//# sourceURL=webpack:///./src/ts/signals/exceptions/illegal-signal-name-exception.ts?");

/***/ }),

/***/ "./src/ts/signals/flow.ts":
/*!********************************!*\
  !*** ./src/ts/signals/flow.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _a, _SignalFlows_singleSignalFlows, _SignalFlows_newSignalFlow, _SignalFlows_getOrThrow;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst signal_1 = __webpack_require__(/*! ./signal */ \"./src/ts/signals/signal.ts\");\nconst mapped_single_signal_flow_1 = __webpack_require__(/*! ./mapped-single-signal-flow */ \"./src/ts/signals/mapped-single-signal-flow.ts\");\nconst pair_1 = __webpack_require__(/*! ../types/pair */ \"./src/ts/types/pair.ts\");\nconst illegal_signal_name_exception_1 = __webpack_require__(/*! ./exceptions/illegal-signal-name-exception */ \"./src/ts/signals/exceptions/illegal-signal-name-exception.ts\");\nconst options_1 = __webpack_require__(/*! ./options */ \"./src/ts/signals/options.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nclass SignalFlows {\n    static newSingleFlow(signalName) {\n        if (__classPrivateFieldGet(this, _a, \"f\", _SignalFlows_singleSignalFlows).has(signalName))\n            throw new illegal_signal_name_exception_1.IllegalSignalNameException(signalName, \"name already exists\");\n        let signalNameInst = new signal_1.SignalName(signalName);\n        let flow = new mapped_single_signal_flow_1.MappedSingleSignalFlow(signalNameInst);\n        __classPrivateFieldGet(this, _a, \"f\", _SignalFlows_singleSignalFlows).set(signalName, (0, pair_1.pairOf)(signalNameInst, flow));\n        __classPrivateFieldGet(this, _a, \"f\", _SignalFlows_newSignalFlow).fire(null, signalName);\n        log_1.Log.log(\"SignalSystem | registered signal \" + signalName);\n        return flow;\n    }\n    /**\n     * Returns the global subscriber for the signal that is fired every time a new\n     * signal is created and registered.\n     * The signal will have the name `signal-system.new` and the data will be the name of the\n     * new signal\n     */\n    static getNewSignalSubscriber() {\n        return __classPrivateFieldGet(this, _a, \"f\", _SignalFlows_newSignalFlow);\n    }\n    /**\n     * Returns the `SignalName` associated to the signal with the given string of name or\n     * `undefined` if the name is not registered\n     * @param {string} signalName the string name of the signal\n     * @return {SignalName} the `SignalName` instance associated with the given `name` or `undefined`\n     * if no `SignalName` is associated with the given name\n     */\n    static getSignalName(signalName) {\n        return __classPrivateFieldGet(this, _a, \"m\", _SignalFlows_getOrThrow).call(this, signalName).getFirst();\n    }\n    static getSubscriber(signalName) {\n        if (typeof signalName === \"string\") {\n            return __classPrivateFieldGet(this, _a, \"m\", _SignalFlows_getOrThrow).call(this, signalName).getSecond();\n        }\n        else {\n            return __classPrivateFieldGet(this, _a, \"m\", _SignalFlows_getOrThrow).call(this, signalName.name).getSecond();\n        }\n    }\n    /**\n     * Immediately subscribes to the given `signalName` if already registered or\n     * asynchronous waits for the signal to be registered and then subscribes to it\n     * @param {SubscriptionOptions} options the options for the subscription\n     * @param {(receipt: SubscriptionReceipt) => void} whenReceiptAvailable the callback with the receipt\n     * that is called when the subscription receipt is available\n     */\n    static subscribeWhenRegistered(signalName, options, whenReceiptAvailable = () => { }) {\n        try {\n            let receipt = this.getSubscriber(signalName).subscribe(options);\n            whenReceiptAvailable(receipt);\n            log_1.Log.log(\"SignalSystem | subscribed to signal \" + signalName +\n                \" immediately with subscriptionId \" + receipt.subscriptionId);\n        }\n        catch (e) {\n            log_1.Log.log(\"SignalSystem | signal \" + signalName + \" not registered, waiting for registration\");\n            let newSignalReceipt = this.getNewSignalSubscriber()\n                .subscribe((0, options_1.handler)((signal) => {\n                if (signal.data === signalName) {\n                    log_1.Log.log(\"SignalSystem | signal \" + signalName + \" registered, subscribing\");\n                    let receipt = this.getSubscriber(signalName).subscribe(options);\n                    whenReceiptAvailable(receipt);\n                    this.getNewSignalSubscriber().unsubscribe(newSignalReceipt);\n                }\n            }));\n        }\n    }\n    /**\n     * Gets an array containing all the signals that have correctly been registered\n     * @return {Array<SignalName>} the array with all the registered signals\n     */\n    static getRegisteredSignals() {\n        let res = [];\n        __classPrivateFieldGet(this, _a, \"f\", _SignalFlows_singleSignalFlows).forEach((value, _) => {\n            res.push(value.getFirst());\n        });\n        return res;\n    }\n}\nexports[\"default\"] = SignalFlows;\n_a = SignalFlows, _SignalFlows_getOrThrow = function _SignalFlows_getOrThrow(signalName) {\n    let signalFlow = __classPrivateFieldGet(this, _a, \"f\", _SignalFlows_singleSignalFlows).get(signalName);\n    if (signalFlow == undefined) {\n        throw new illegal_signal_name_exception_1.IllegalSignalNameException(signalName, \"no signal with this name\");\n    }\n    return signalFlow;\n};\nSignalFlows.NEW_SIGNAL_SIGNAL_NAME = \"signal-system.new\";\n_SignalFlows_singleSignalFlows = { value: new Map() };\n_SignalFlows_newSignalFlow = { value: new mapped_single_signal_flow_1.MappedSingleSignalFlow(new signal_1.SignalName(SignalFlows.NEW_SIGNAL_SIGNAL_NAME)) };\n\n\n//# sourceURL=webpack:///./src/ts/signals/flow.ts?");

/***/ }),

/***/ "./src/ts/signals/mapped-single-signal-flow.ts":
/*!*****************************************************!*\
  !*** ./src/ts/signals/mapped-single-signal-flow.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _MappedSingleSignalFlow_id, _MappedSingleSignalFlow_subscriptions;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MappedSingleSignalFlow = void 0;\nconst signal_1 = __webpack_require__(/*! ./signal */ \"./src/ts/signals/signal.ts\");\nconst subscriptions_1 = __webpack_require__(/*! ./subscriptions */ \"./src/ts/signals/subscriptions.ts\");\nconst result_1 = __webpack_require__(/*! ../types/result */ \"./src/ts/types/result.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\n/**\n * An implementation of `SingleSignalFlow` based on a map\n */\nclass MappedSingleSignalFlow {\n    constructor(signalName) {\n        _MappedSingleSignalFlow_id.set(this, 0);\n        _MappedSingleSignalFlow_subscriptions.set(this, new Map());\n        this.signalName = signalName;\n    }\n    subscribe(options) {\n        var _a;\n        let res = new subscriptions_1.SubscriptionReceipt(this.signalName.name + \"#\" + __classPrivateFieldGet(this, _MappedSingleSignalFlow_id, \"f\").toString(), this.signalName, subscriptions_1.SubscriptionStatus.ACCEPTED);\n        __classPrivateFieldSet(this, _MappedSingleSignalFlow_id, (_a = __classPrivateFieldGet(this, _MappedSingleSignalFlow_id, \"f\"), _a++, _a), \"f\");\n        let subscription = new subscriptions_1.Subscription(res, options);\n        __classPrivateFieldGet(this, _MappedSingleSignalFlow_subscriptions, \"f\").set(res.subscriptionId, subscription);\n        return res;\n    }\n    unsubscribe(subscriptionReceipt) {\n        if (__classPrivateFieldGet(this, _MappedSingleSignalFlow_subscriptions, \"f\").delete(subscriptionReceipt.subscriptionId)) {\n            return (0, subscriptions_1.withSubscriptionStatusChanged)(subscriptionReceipt, subscriptions_1.SubscriptionStatus.UNSUBSCRIBED);\n        }\n        return null;\n    }\n    fire(source, data) {\n        log_1.Log.log(\"SignalSystem | firing signal \" + this.signalName.name);\n        let signal = new signal_1.Signal(this.signalName, source, data);\n        let results = new Map();\n        let currentResult;\n        for (let subscription of __classPrivateFieldGet(this, _MappedSingleSignalFlow_subscriptions, \"f\").values()) {\n            log_1.Log.log(\"SignalSystem | firing signal \" + this.signalName.name + \" to subscriber \" + subscription.receipt.subscriptionId);\n            currentResult = (0, result_1.resultOf)(subscription.options.handler, signal.clone());\n            results.set(subscription.receipt.subscriptionId, currentResult);\n        }\n        log_1.Log.log(\"SignalSystem | signal \" + this.signalName.name + \" fired\");\n        return new signal_1.SyncFiredSignal(signal, results);\n    }\n}\nexports.MappedSingleSignalFlow = MappedSingleSignalFlow;\n_MappedSingleSignalFlow_id = new WeakMap(), _MappedSingleSignalFlow_subscriptions = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/signals/mapped-single-signal-flow.ts?");

/***/ }),

/***/ "./src/ts/signals/options.ts":
/*!***********************************!*\
  !*** ./src/ts/signals/options.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.handlerFor = exports.handler = exports.SubscriptionOptions = void 0;\nclass SubscriptionOptions {\n    constructor(signalName, handler) {\n        this.signalName = undefined;\n        this.signalName = signalName;\n        this.handler = handler;\n    }\n}\nexports.SubscriptionOptions = SubscriptionOptions;\n/**\n * Creates and returns a new `SubscriptionOptions` which contains only the handler to be invoked when\n * the signal is triggered\n * @param {SignalHandler<S, D, R>} handler the asynchronous function that has to be invoked once a signal is triggered\n * @return {SubscriptionOptions<S, D, R>} the new created options ready to be passed to the `subscribe` function\n */\nfunction handler(handler) {\n    return new SubscriptionOptions(undefined, handler);\n}\nexports.handler = handler;\n/**\n * Creates and returns a new `SubscriptionOptions` which contains the name of the signal the options will refer to\n * and the handler to be invoked when the specified signal is triggered\n * @param {SignalName} signalName the name of the signal these options refer to\n * @param {SignalHandler<S, D, R>} handler the asynchronous function that has to be invoked once a signal is triggered\n * @return {SubscriptionOptions<S, D, R>} the new created options ready to be passed to the `subscribe` function\n */\nfunction handlerFor(signalName, handler) {\n    return new SubscriptionOptions(signalName, handler);\n}\nexports.handlerFor = handlerFor;\n\n\n//# sourceURL=webpack:///./src/ts/signals/options.ts?");

/***/ }),

/***/ "./src/ts/signals/signal.ts":
/*!**********************************!*\
  !*** ./src/ts/signals/signal.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SyncFiredSignal_result;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SyncFiredSignal = exports.FiredSignal = exports.Signal = exports.SignalName = void 0;\n/**\n * The name of a signal\n */\nclass SignalName {\n    constructor(signalName) {\n        this.name = signalName;\n    }\n    equals(other) {\n        if (other != undefined) {\n            if (other instanceof SignalName) {\n                return other.name == this.name;\n            }\n        }\n        return false;\n    }\n}\nexports.SignalName = SignalName;\n/**\n * A signal that is currently firing\n */\nclass Signal {\n    constructor(name, source, data) {\n        this.name = name;\n        this.source = source;\n        this.data = data;\n    }\n    clone() {\n        return new Signal(this.name, this.source, this.data);\n    }\n}\nexports.Signal = Signal;\n/**\n * A signal that has previously been fired.\n * It contains also the firing signal that was received from the handlers and the that\n * in which the signal was fired\n */\nclass FiredSignal {\n    constructor(signal) {\n        /**\n         * The time in which the signal was fired\n         */\n        this.date = new Date();\n        this.signal = signal;\n    }\n}\nexports.FiredSignal = FiredSignal;\n/**\n * A synchronous fired signal.\n * This signal contains the result of the executed handlers associated by the subscription id\n */\nclass SyncFiredSignal extends FiredSignal {\n    constructor(signal, result) {\n        super(signal);\n        _SyncFiredSignal_result.set(this, new Map());\n        __classPrivateFieldSet(this, _SyncFiredSignal_result, result, \"f\");\n    }\n    /**\n     * Gets the result of the given subscription\n     * @param {string} subscriptionId the id of the desired subscription\n     * @return {Result<R>} the result for the specified subscription or `undefined` if no\n     * result is present for that subscription\n     */\n    getResultOf(subscriptionId) {\n        return __classPrivateFieldGet(this, _SyncFiredSignal_result, \"f\").get(subscriptionId);\n    }\n}\nexports.SyncFiredSignal = SyncFiredSignal;\n_SyncFiredSignal_result = new WeakMap();\n\n\n//# sourceURL=webpack:///./src/ts/signals/signal.ts?");

/***/ }),

/***/ "./src/ts/signals/signals-decorator.ts":
/*!*********************************************!*\
  !*** ./src/ts/signals/signals-decorator.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unsubscribeWhen = exports.subscribeWhen = exports.SignalListener = exports.OnSignalMethod = exports.OnSignalSubMethod = exports.OnSignal = void 0;\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nconst flow_1 = __webpack_require__(/*! ./flow */ \"./src/ts/signals/flow.ts\");\nconst options_1 = __webpack_require__(/*! ./options */ \"./src/ts/signals/options.ts\");\nclass SignalSubscriptionContinuation {\n    constructor() {\n        this.subscribeWhen = null;\n        this.subscribeWhenData = null;\n        this.unsubscribeWhen = null;\n        this.unsubscribeWhenData = null;\n    }\n}\nconst SignalToRegister = Symbol(\"SignalToRegister\");\nfunction getOrCreateSignalSubscriptionContinuation(target, propertyKey) {\n    target[SignalToRegister] = target[SignalToRegister] || new Map();\n    let signalSubscriptionContinuation = target[SignalToRegister].get(propertyKey);\n    if (signalSubscriptionContinuation == undefined) {\n        signalSubscriptionContinuation = new SignalSubscriptionContinuation();\n        target[SignalToRegister].set(propertyKey, signalSubscriptionContinuation);\n    }\n    return signalSubscriptionContinuation;\n}\n/**\n * Register a method as a signal handler for the give `signalName`\n * @param {string} signalName the name of the signal to subscribe to\n * @param {(receipt: SubscriptionReceipt<S, D, R>) => void} withReceipt the function that will be invoked\n * when the subscription is completed\n */\nfunction OnSignal(signalName) {\n    return function (target, propertyKey, descriptor) {\n        log_1.Log.log(\"onSignal | registering signal handler for signal \" + signalName + \" on method \" + propertyKey);\n        let options = (0, options_1.handler)((signal) => {\n            return descriptor.value(signal);\n        });\n        flow_1.default.subscribeWhenRegistered(signalName, options);\n    };\n}\nexports.OnSignal = OnSignal;\nexports.OnSignalSubMethod = Symbol(\"OnSignalMethod\");\nfunction OnSignalMethod(signalName) {\n    return function (target, propertyKey, descriptor) {\n        log_1.Log.log(\"onSignal | registering signal handler for signal \" + signalName + \" on method \" + propertyKey);\n        target[exports.OnSignalSubMethod] = target[exports.OnSignalSubMethod] || new Map();\n        target[exports.OnSignalSubMethod].set(propertyKey, signalName);\n    };\n}\nexports.OnSignalMethod = OnSignalMethod;\nfunction SignalListener(Base) {\n    return class extends Base {\n        constructor(...args) {\n            super(...args);\n            const onSignalMethods = Base.prototype[exports.OnSignalSubMethod];\n            if (onSignalMethods != undefined) {\n                onSignalMethods.forEach((signalName, methodName) => {\n                    let options = (0, options_1.handler)((signal) => {\n                        return this[methodName](signal);\n                    });\n                    flow_1.default.subscribeWhenRegistered(signalName, options);\n                });\n            }\n        }\n    };\n}\nexports.SignalListener = SignalListener;\nfunction subscribeWhen(otherSignal, signalData) {\n    return function (target, propertyKey, descriptor) {\n        let continuation = getOrCreateSignalSubscriptionContinuation(target, propertyKey);\n        continuation.subscribeWhen = otherSignal;\n        continuation.subscribeWhenData = signalData;\n    };\n}\nexports.subscribeWhen = subscribeWhen;\nfunction unsubscribeWhen(otherSignal, signalData) {\n    return function (target, propertyKey, descriptor) {\n        let continuation = getOrCreateSignalSubscriptionContinuation(target, propertyKey);\n        continuation.unsubscribeWhen = otherSignal;\n        continuation.unsubscribeWhenData = signalData;\n    };\n}\nexports.unsubscribeWhen = unsubscribeWhen;\n\n\n//# sourceURL=webpack:///./src/ts/signals/signals-decorator.ts?");

/***/ }),

/***/ "./src/ts/signals/subscriptions.ts":
/*!*****************************************!*\
  !*** ./src/ts/signals/subscriptions.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subscription = exports.withSubscriptionStatusChanged = exports.SubscriptionReceipt = exports.SubscriptionStatus = void 0;\n/**\n * The status of a subscription\n */\nvar SubscriptionStatus;\n(function (SubscriptionStatus) {\n    SubscriptionStatus[\"ACCEPTED\"] = \"ACCEPTED\";\n    SubscriptionStatus[\"DENIED\"] = \"DENIED\";\n    SubscriptionStatus[\"UNSUBSCRIBED\"] = \"UNSUBSCRIBED\";\n})(SubscriptionStatus = exports.SubscriptionStatus || (exports.SubscriptionStatus = {}));\n/**\n * The receipt of a subscription\n */\nclass SubscriptionReceipt {\n    constructor(subscriptionId, signalName, currentStatus) {\n        this.subscriptionId = subscriptionId;\n        this.signalName = signalName;\n        this.status = currentStatus;\n    }\n}\nexports.SubscriptionReceipt = SubscriptionReceipt;\n/**\n * Returns a new `SubscriptionReceipt` with a new status\n * @param {SubscriptionReceipt<S, D, R>} oldReceipt the old receipt\n * @param {SubscriptionStatus} newStatus the new status of the subscription\n * @return {SubscriptionReceipt<S, D, R>} the new receipt with the changed status\n */\nfunction withSubscriptionStatusChanged(oldReceipt, newStatus) {\n    return new SubscriptionReceipt(oldReceipt.subscriptionId, oldReceipt.signalName, newStatus);\n}\nexports.withSubscriptionStatusChanged = withSubscriptionStatusChanged;\n/**\n * A processed subscription\n */\nclass Subscription {\n    constructor(result, subscriber) {\n        this.receipt = result;\n        this.options = subscriber;\n    }\n}\nexports.Subscription = Subscription;\n\n\n//# sourceURL=webpack:///./src/ts/signals/subscriptions.ts?");

/***/ }),

/***/ "./src/ts/types/arrays.ts":
/*!********************************!*\
  !*** ./src/ts/types/arrays.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Arrays = void 0;\nconst illegal_argument_exception_1 = __webpack_require__(/*! ./exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nclass Arrays {\n    /**\n     * Copies the `src` array into `dst`.\n     * This method will consider all different cases about the lenghts of the arrays:\n     *\n     * - if `src.length == dst.length` the source array will be entirely copied into the destination\n     * with no problems so, at the end, `dst` will be an exact clone of `src`\n     *\n     * - if `src.length > dst.length` then `dst` will be a *truncated* copy of `src` (the copy will be stopped\n     * when `dst` has no more index available)\n     *\n     * - if `src.length < dst.length` then `src` will be entirely copied to `dst` and the exceeded indexes will\n     * be not touched by this method\n     * @param {Array<T>} src the source array\n     * @param {Array<T>} dst the destination array\n     */\n    static copy(src, dst) {\n        for (let i = 0; i < Math.min(src.length, dst.length); i++) {\n            dst[i] = src[i];\n        }\n    }\n    /**\n     * Copies the `src` array of array to `dst` (2-dimensional array)\n     * The copy will follow the mechanism explained in the `Arrays.copy()` method that copy\n     * *until is possible*\n     * @param {Array<Array<T>>} src the source array\n     * @param {Array<Array<T>>} dst the destination array\n     */\n    static copy2(src, dst) {\n        let srci;\n        let dsti;\n        for (let i = 0; i < Math.min(src.length, dst.length); i++) {\n            srci = src[i];\n            dsti = dst[i];\n            for (let j = 0; j < Math.min(srci.length, dsti.length); j++) {\n                dsti[j] = srci[j];\n            }\n        }\n    }\n    static clone(original, newLength) {\n        if (newLength == undefined) {\n            newLength = original.length;\n        }\n        else {\n            if (newLength < 0) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"newLength can not be negative\");\n            }\n        }\n        let res = new Array(newLength);\n        for (let i = 0; i < newLength; i++) {\n            res[i] = original[i];\n        }\n        return res;\n    }\n    static clone2(original, newHigh, newLength) {\n        let res;\n        let originali;\n        let resi;\n        if (newHigh == undefined && newLength == undefined) {\n            res = new Array(original.length);\n            for (let i = 0; i < original.length; i++) {\n                originali = original[i];\n                resi = new Array(originali.length);\n                for (let j = 0; j < resi.length; j++) {\n                    resi[j] = originali[j];\n                }\n                res[i] = resi;\n            }\n        }\n        else if (newHigh != undefined && newLength == undefined) {\n            if (newHigh < 0) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"newHigh can not be negative\");\n            }\n            res = new Array(newHigh);\n            for (let i = 0; i < Math.min(newHigh, original.length); i++) {\n                originali = original[i];\n                resi = new Array();\n                for (let j = 0; j < originali.length; j++) {\n                    resi[j] = originali[j];\n                }\n                res[i] = resi;\n            }\n        }\n        else if (newHigh == undefined && newLength != undefined) {\n            if (newLength < 0) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"newLength can not be negative\");\n            }\n            res = new Array(original.length);\n            for (let i = 0; i < original.length; i++) {\n                originali = original[i];\n                resi = new Array();\n                for (let j = 0; j < Math.min(originali.length, newLength); j++) {\n                    resi[j] = originali[j];\n                }\n                res[i] = resi;\n            }\n        }\n        else if (newHigh != undefined && newLength != undefined) {\n            if (newHigh < 0) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"newHigh can not be negative\");\n            }\n            if (newLength < 0) {\n                throw new illegal_argument_exception_1.IllegalArgumentException(\"newLength can not be negative\");\n            }\n            res = new Array(newHigh);\n            for (let i = 0; i < Math.min(original.length, newHigh); i++) {\n                originali = original[i];\n                resi = new Array();\n                for (let j = 0; j < Math.min(originali.length, newLength); j++) {\n                    resi[j] = originali[j];\n                }\n                res[i] = resi;\n            }\n        }\n        return res;\n    }\n    /**\n     * Reshape an array.\n     * The behaviour of this method depends on the `newLength` parameter:\n     * - if the size of the array is equals to `newLength`, this method will perform nothing\n     * - if the `newLength` of the array is greater than the current size, then the array will be padded with `null`\n     * element until the desired length is reached (or with the element specified using the `fill` parameter)\n     * - if the `newLength` of the array is less than the current size, then the array will be truncated to reach\n     * the desired length\n     * @param {Array<T>} array the array to be reshaped\n     * @param {number} newLength the new length of the array\n     * @param {T|null} fill the element to use to pad the array (`null` as default)\n     * @return {Array<T>} An array containing the deleted elements.\n     * If only one element is removed, an array of one element is returned.\n     * If no elements are removed, an empty array is returned.\n     */\n    static reshape(array, newLength, fill = null) {\n        if (newLength != array.length) {\n            if (newLength < array.length) {\n                return array.splice(newLength - 1, array.length);\n            }\n            else {\n                array.push(fill);\n                return new Array();\n            }\n        }\n    }\n    static reshape2(array, newHigh, newWeight) {\n        let res;\n        if (newHigh != array.length) {\n            if (newHigh < array.length) {\n                res = array.splice(newHigh - 1, array.length);\n            }\n            else {\n                array.push(new Array(0));\n                res = new Array(0);\n            }\n        }\n        if (newWeight != undefined) {\n            for (let r = 0; r < newHigh; r++) {\n                res.splice(0, 0, this.reshape(array[r], newWeight));\n            }\n        }\n        return res;\n    }\n    /**\n     * Searches for the given element into the given array and removes it\n     * @param {Array<T>} array the array\n     * @param {T} obj the object to remove\n     * @return {T|null} the removed object or `null` if the object is not present into the array\n     */\n    static removeFrom(array, obj) {\n        let idx = array.indexOf(obj);\n        if (idx == -1)\n            return null;\n        return array.splice(idx, 1)[0];\n    }\n}\nexports.Arrays = Arrays;\n\n\n//# sourceURL=webpack:///./src/ts/types/arrays.ts?");

/***/ }),

/***/ "./src/ts/types/cloneable.ts":
/*!***********************************!*\
  !*** ./src/ts/types/cloneable.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tryClone = exports.isCloneable = void 0;\n/**\n * Checks if an object implements `Cloneable`\n * (exposes a method to make a deep clone of the object)\n * @param {any} obj the object to be checked\n */\n// @ts-ignore\nfunction isCloneable(obj) {\n    if (typeof obj == \"object\") {\n        return 'clone' in obj;\n    }\n    return false;\n}\nexports.isCloneable = isCloneable;\n/**\n * Checks if the given object is cloneable and, if yes, returns the clone, otherwise\n * returns the same object\n * @param {T} obj the object\n * @return a clone of the object if possible, otherwise it returns the same object\n */\nfunction tryClone(obj) {\n    if (isCloneable(obj)) {\n        return obj.clone();\n    }\n    return obj;\n}\nexports.tryClone = tryClone;\n\n\n//# sourceURL=webpack:///./src/ts/types/cloneable.ts?");

/***/ }),

/***/ "./src/ts/types/data/performed-number-trio-change.ts":
/*!***********************************************************!*\
  !*** ./src/ts/types/data/performed-number-trio-change.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PerformedNumberTrioChangeBuilder = exports.PerformedNumberTrioChange = void 0;\nclass PerformedNumberTrioChange {\n    constructor(oldValue, newValue) {\n        this.oldValue = oldValue;\n        this.newValue = newValue;\n        this.difference = oldValue.sub(newValue.getFirst(), newValue.getSecond(), newValue.getThird());\n    }\n}\nexports.PerformedNumberTrioChange = PerformedNumberTrioChange;\nclass PerformedNumberTrioChangeBuilder {\n    constructor(oldValue = null, newValue = null) {\n        this.oldValue = oldValue;\n        this.newValue = newValue;\n    }\n    /**\n     * Builds a PerformedNumberTrioChange object throwing an error if one of the required fields is missing\n     * @returns {PerformedNumberTrioChange} the built PerformedNumberTrioChange object\n     * @throws {Error} if one of the required fields is missing\n     */\n    build() {\n        if (this.oldValue == null) {\n            throw new Error(\"Old value not set\");\n        }\n        if (this.newValue == null) {\n            throw new Error(\"New value not set\");\n        }\n        return new PerformedNumberTrioChange(this.oldValue, this.newValue);\n    }\n    /**\n     * Clears the builder by setting all fields to null\n     */\n    clear() {\n        this.oldValue = null;\n        this.newValue = null;\n    }\n}\nexports.PerformedNumberTrioChangeBuilder = PerformedNumberTrioChangeBuilder;\n\n\n//# sourceURL=webpack:///./src/ts/types/data/performed-number-trio-change.ts?");

/***/ }),

/***/ "./src/ts/types/data/performed-object-set.ts":
/*!***************************************************!*\
  !*** ./src/ts/types/data/performed-object-set.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PerformedObjectSetBuilder = exports.PerformedObjectSet = void 0;\nclass PerformedObjectSet {\n    constructor(oldValue, newValue) {\n        this.oldValue = oldValue;\n        this.newValue = newValue;\n    }\n}\nexports.PerformedObjectSet = PerformedObjectSet;\nclass PerformedObjectSetBuilder {\n    constructor(oldValue = null, newValue = null) {\n        this.oldValue = oldValue;\n        this.newValue = newValue;\n    }\n    /**\n     * Builds a new PerformedObjectSet instance throwing an error if the oldValue or newValue is null\n     * @returns {PerformedObjectSet<T>} the new PerformedObjectSet instance\n     * @throws {Error} if the oldValue or newValue is null\n     */\n    build() {\n        if (this.oldValue == null) {\n            throw new Error(\"oldValue is null\");\n        }\n        if (this.newValue == null) {\n            throw new Error(\"newValue is null\");\n        }\n        return new PerformedObjectSet(this.oldValue, this.newValue);\n    }\n    /**\n     * Clears this builder by setting the oldValue and newValue to `null`\n     */\n    clear() {\n        this.oldValue = null;\n        this.newValue = null;\n    }\n}\nexports.PerformedObjectSetBuilder = PerformedObjectSetBuilder;\n\n\n//# sourceURL=webpack:///./src/ts/types/data/performed-object-set.ts?");

/***/ }),

/***/ "./src/ts/types/equatable.ts":
/*!***********************************!*\
  !*** ./src/ts/types/equatable.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equals = exports.isEquatable = void 0;\n/**\n * Checks if an object implements `Equatable`\n * @param {any} obj the object to be checked\n */\nfunction isEquatable(obj) {\n    if (typeof obj == \"object\") {\n        return 'equals' in obj;\n    }\n    return false;\n}\nexports.isEquatable = isEquatable;\n/**\n * Checks if the two objects implement `Equatable` and, in that case, uses the `equals` of\n * `Equatable` to check if the two objects are equals; otherwise it will use the normal `===` operator\n * @param {any} obj1 the first object\n * @param {any} obj2 the second object\n * @return {boolean} `true` if two object are equals following the explained criteria, `false` otherwise\n */\nfunction equals(obj1, obj2) {\n    if (isEquatable(obj1) && isEquatable(obj2)) {\n        return obj1.equals(obj2);\n    }\n    return obj1 === obj2;\n}\nexports.equals = equals;\n\n\n//# sourceURL=webpack:///./src/ts/types/equatable.ts?");

/***/ }),

/***/ "./src/ts/types/exceptions/illegal-argument-exception.ts":
/*!***************************************************************!*\
  !*** ./src/ts/types/exceptions/illegal-argument-exception.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IllegalArgumentException = void 0;\n/**\n * An exception that is thrown when a column is not valid for a reason\n */\nclass IllegalArgumentException extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, IllegalArgumentException.prototype);\n    }\n}\nexports.IllegalArgumentException = IllegalArgumentException;\n\n\n//# sourceURL=webpack:///./src/ts/types/exceptions/illegal-argument-exception.ts?");

/***/ }),

/***/ "./src/ts/types/exceptions/illegal-modification-exception.ts":
/*!*******************************************************************!*\
  !*** ./src/ts/types/exceptions/illegal-modification-exception.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IllegalModificationException = void 0;\n/**\n * An exception that is thrown when the modification of a certain value is not allowed\n */\nclass IllegalModificationException extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, IllegalModificationException.prototype);\n    }\n}\nexports.IllegalModificationException = IllegalModificationException;\n\n\n//# sourceURL=webpack:///./src/ts/types/exceptions/illegal-modification-exception.ts?");

/***/ }),

/***/ "./src/ts/types/exceptions/illegal-state-exception.ts":
/*!************************************************************!*\
  !*** ./src/ts/types/exceptions/illegal-state-exception.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IllegalStateException = void 0;\n/**\n * An exception that is thrown when the state of an object is not valid\n * to perform a certain operation\n */\nclass IllegalStateException extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, IllegalStateException.prototype);\n    }\n}\nexports.IllegalStateException = IllegalStateException;\n\n\n//# sourceURL=webpack:///./src/ts/types/exceptions/illegal-state-exception.ts?");

/***/ }),

/***/ "./src/ts/types/exceptions/index-out-of-bound-exception.ts":
/*!*****************************************************************!*\
  !*** ./src/ts/types/exceptions/index-out-of-bound-exception.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IndexOutOfBoundException = void 0;\n/**\n * An exception that is thrown when it is tried to access an invalid index/position\n * in somewhere\n */\nclass IndexOutOfBoundException extends Error {\n    constructor(triedIndex) {\n        super(\"invalid index \" + triedIndex);\n        this.triedIndex = triedIndex;\n        Object.setPrototypeOf(this, IndexOutOfBoundException.prototype);\n    }\n}\nexports.IndexOutOfBoundException = IndexOutOfBoundException;\n\n\n//# sourceURL=webpack:///./src/ts/types/exceptions/index-out-of-bound-exception.ts?");

/***/ }),

/***/ "./src/ts/types/numbers/number-couple.ts":
/*!***********************************************!*\
  !*** ./src/ts/types/numbers/number-couple.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.numberCouple = exports.NumberCouple = void 0;\nconst pair_1 = __webpack_require__(/*! ../pair */ \"./src/ts/types/pair.ts\");\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nclass NumberCouple extends pair_1.Pair {\n    constructor(number1, number2) {\n        super(number1, number2);\n    }\n    applyAdd(operand1, operand2) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        this.setFirst(this.getSecond() + operand1);\n        this.setSecond(this.getSecond() + operand2);\n        return this;\n    }\n    /**\n     * Apply an addition to the **first** element of this couple.\n     * This method will update the internal elements of this pair by adding\n     * the given argument to the first one, then returns `this`\n     * @param {number} operand the number to be added to the **first** element of this pair\n     * @returns {NumberCouple} this couple\n     */\n    applyAddToFirst(operand) {\n        this.setFirst(this.getFirst() + operand);\n        return this;\n    }\n    /**\n     * Apply an addition to the **second** element of this couple.\n     * This method will update the internal elements of this pair by adding\n     * the given argument to the second one, then returns `this`\n     * @param {number} operand the number to be added to the **second** element of this pair\n     * @returns {NumberCouple} this couple\n     */\n    applyAddToSecond(operand) {\n        this.setSecond(this.getSecond() + operand);\n        return this;\n    }\n    /**\n     * Apply an addition to the element of this couple specified by the `position` parameter.\n     * This method will update the internal elements of this pair by adding\n     * the given argument to the desired one, then returns `this`\n     * @param {number} operand the number to be added to the desired element of this pair\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} this couple\n     */\n    applyAddTo(operand, position) {\n        this.set(this.get(position) + operand, position);\n        return this;\n    }\n    applySub(operand1, operand2) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        this.setFirst(this.getFirst() - operand1);\n        this.setSecond(this.getSecond() - operand2);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the **first** element of this couple.\n     * This method will update the internal elements of this pair by subtracting\n     * the given argument from the first one, then returns `this`\n     * @param {number} operand the number to be subtracted from the **first** element of this pair\n     * @returns {NumberCouple} this couple\n     */\n    applySubFromFirst(operand) {\n        this.setFirst(this.getFirst() - operand);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the **second** element of this couple.\n     * This method will update the internal elements of this pair by subtracting\n     * the given argument from the second one, then returns `this`\n     * @param {number} operand the number to be subtracted from the **second** element of this pair\n     * @returns {NumberCouple} this couple\n     */\n    applySubFromSecond(operand) {\n        this.setSecond(this.getSecond() - operand);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the element of this couple specified by `position`.\n     * This method will update the internal elements of this pair by subtracting\n     * the given argument from the desired one, then returns `this`\n     * @param {number} operand the number to be subtracted\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} this couple\n     */\n    applySubFrom(operand, position) {\n        this.set(this.get(position) - operand, position);\n        return this;\n    }\n    applyMul(operand1, operand2) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        this.setFirst(this.getFirst() * operand1);\n        this.setSecond(this.getSecond() * operand2);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the **first** element of this couple.\n     * This method will update the internal elements of this pair by multiplying\n     * the given argument to the first one, then returns `this`\n     * @param {number} operand the number to be multiplied to the **first** element of this pair\n     * @returns {NumberCouple} this couple\n     */\n    applyMulToFirst(operand) {\n        this.setFirst(this.getFirst() + operand);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the **second** element of this couple.\n     * This method will update the internal elements of this pair by multiplying\n     * the given argument to the second one, then returns `this`\n     * @param {number} operand the number to be multiplied to the **second** element of this pair\n     * @returns {NumberCouple} this couple\n     */\n    applyMulToSecond(operand) {\n        this.setSecond(this.getSecond() + operand);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the element of this couple specified by `position`.\n     * This method will update the internal elements of this pair by multiplying\n     * the given argument to the one at the desired position, then returns `this`\n     * @param {number} operand the number to be multiplied to the **second** element of this pair\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} this couple\n     */\n    applyMulTo(operand, position) {\n        this.set(this.get(position) + operand, position);\n        return this;\n    }\n    applyDiv(operand1, operand2) {\n        if (operand1 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the first operand is 0: impossible to divide by 0');\n        }\n        if (operand2 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the second operand is 0: impossible to divide by 0');\n        }\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        this.setFirst(this.getFirst() / operand1);\n        this.setSecond(this.getSecond() / operand2);\n        return this;\n    }\n    /**\n     * Apply a division to the **first** element of this couple.\n     * This method will update the internal elements of this pair by dividing\n     * the first one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the **first** element of this pair\n     * @returns {NumberCouple} this couple\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivToFirst(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.setFirst(this.getFirst() / operand);\n        return this;\n    }\n    /**\n     * Apply a division to the **second** element of this couple.\n     * This method will update the internal elements of this pair by dividing\n     * the second one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the **second** element of this pair\n     * @returns {NumberCouple} this couple\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivToSecond(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.setSecond(this.getSecond() / operand);\n        return this;\n    }\n    /**\n     * Apply a division to the element of this couple specified by `position`.\n     * This method will update the internal elements of this pair by dividing\n     * the desired one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the desired element of this pair\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} this couple\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivTo(operand, position) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.set(this.get(position) / operand, position);\n        return this;\n    }\n    applySimpleOperator(operator1, operator2) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n        }\n        this.setFirst(operator1(this.getFirst()));\n        this.setSecond(operator2(this.getSecond()));\n        return this;\n    }\n    applyOperator(operator1, operator2, ...args) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n        }\n        this.setFirst(operator1(this.getFirst(), ...args));\n        this.setSecond(operator2(this.getSecond(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **first** element of this pair.\n     * This method will update the internal element of this pair by applying `operand`\n     * to the first element of this pair.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns this couple\n     */\n    applySimpleOperatorToFirst(operator) {\n        this.setFirst(operator(this.getFirst()));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **second** element of this pair.\n     * This method will update the internal element of this pair by applying `operand`\n     * to the second element of this pair.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns this couple\n     */\n    applySimpleOperatorToSecond(operator) {\n        this.setSecond(operator(this.getSecond()));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the element of this pair specified by `position`.\n     * This method will update the internal element of this pair by applying `operand`\n     * to the desired element of this pair.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {PairPosition} position the position\n     * @returns this couple\n     */\n    applySimpleOperatorTo(operator, position) {\n        this.set(operator(this.get(position)), position);\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **first** element of this pair.\n     * This method will update the internal element of this pair by applying `operand`\n     * to the first element of this pair\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this couple\n     */\n    applyOperatorToFirst(operator, ...args) {\n        this.setFirst(operator(this.getFirst(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **second** element of this pair.\n     * This method will update the internal element of this pair by applying `operand`\n     * to the second element of this pair\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this couple\n     */\n    applyOperatorToSecond(operator, ...args) {\n        this.setSecond(operator(this.getSecond(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the element of this pair specified by `position`.\n     * This method will update the internal element of this pair by applying `operand`\n     * to the desired element of this pair\n     * @param {NumericOperator} operator the simple operator function\n     * @param {PairPosition} position the position\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this couple\n     */\n    applyOperatorTo(operator, position, ...args) {\n        this.set(operator(this.get(position), ...args), position);\n        return this;\n    }\n    add(operand1, operand2) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        return new NumberCouple(this.getFirst() + operand1, this.getSecond() + operand2);\n    }\n    /**\n     * Adds the given `operand` to the **first** element of this couple returning the result.\n     * **This method is different from `applyAddToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be added to the first element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    addToFirst(operand) {\n        return new NumberCouple(this.getFirst() + operand, this.getSecond());\n    }\n    /**\n     * Adds the given `operand` to the **second** element of this couple returning the result.\n     * **This method is different from `applyAddToSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be added to the second element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    addToSecond(operand) {\n        return new NumberCouple(this.getFirst(), this.getSecond() + operand);\n    }\n    /**\n     * Adds the given `operand` to the element of this couple at the specified position, returning the result.\n     * **This method is different from `applyAddToSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be added to the second element of this pair\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    addTo(operand, position) {\n        switch (position) {\n            case pair_1.PairPosition.FIRST: return new NumberCouple(this.getFirst() + operand, this.getSecond());\n            case pair_1.PairPosition.SECOND: return new NumberCouple(this.getFirst(), this.getSecond() + operand);\n        }\n    }\n    sub(operand1, operand2) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        return new NumberCouple(this.getFirst() - operand1, this.getSecond() - operand2);\n    }\n    /**\n     * Subtracts the given `operand` from the **first** element of this couple returning the result.\n     * **This method is different from `applySubtractFromFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be subtracted from the first element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    subFromFirst(operand) {\n        return new NumberCouple(this.getFirst() - operand, this.getSecond());\n    }\n    /**\n     * Subtracts the given `operand` from the **second** element of this couple returning the result.\n     * **This method is different from `applySubtractSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be subtracted from the second element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    subFromSecond(operand) {\n        return new NumberCouple(this.getFirst(), this.getSecond() - operand);\n    }\n    /**\n     * Subtracts the given `operand` from the element of this couple at the specified position, returning the result.\n     * **This method is different from `applySubtractSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be subtracted from the desired element of this pair\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    subFrom(operand, position) {\n        switch (position) {\n            case pair_1.PairPosition.FIRST: return new NumberCouple(this.getFirst() - operand, this.getSecond());\n            case pair_1.PairPosition.SECOND: return new NumberCouple(this.getFirst(), this.getSecond() - operand);\n        }\n    }\n    mul(operand1, operand2) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        return new NumberCouple(this.getFirst() * operand1, this.getSecond() * operand2);\n    }\n    /**\n     * Multiply the given `operand` to the **first** element of this couple returning the result.\n     * **This method is different from `applyMulToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be multiplied to the first element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    mulToFirst(operand) {\n        return new NumberCouple(this.getFirst() * operand, this.getSecond());\n    }\n    /**\n     * Multiply the given `operand` to the **second** element of this couple returning the result.\n     * **This method is different from `applyMulToSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be multiplied to the second element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    mulToSecond(operand) {\n        return new NumberCouple(this.getFirst(), this.getSecond() * operand);\n    }\n    /**\n     * Multiply the given `operand` to the element of this couple returning the result.\n     * **This method is different from `applyMulToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the number to be multiplied to the first element of this pair\n     * @param {position} position the position\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    mulTo(operand, position) {\n        switch (position) {\n            case pair_1.PairPosition.FIRST: return new NumberCouple(this.getFirst() * operand, this.getSecond());\n            case pair_1.PairPosition.SECOND: return new NumberCouple(this.getFirst(), this.getSecond() * operand);\n        }\n    }\n    div(operand1, operand2) {\n        if (operand1 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the first operand is 0: impossible to divide by 0');\n        }\n        if (operand2 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the second operand is 0: impossible to divide by 0');\n        }\n        if (operand2 == undefined) {\n            operand2 = operand1;\n        }\n        return new NumberCouple(this.getFirst() / operand1, this.getSecond() / operand2);\n    }\n    /**\n     * Divide the **first** element of this couple by the given `operand`, returning the result.\n     * **This method is different from `applyDivToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the divisor for the first element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFromFirst(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        return new NumberCouple(this.getFirst() / operand, this.getSecond());\n    }\n    /**\n     * Divide the **second** element of this couple by the given `operand`, returning the result.\n     * **This method is different from `applyDivToSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the divisor for the second element of this pair\n     * @returns {NumberCouple} the couple that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFromSecond(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        return new NumberCouple(this.getFirst(), this.getSecond() / operand);\n    }\n    /**\n     * Divide the element of this couple at the specified position by the given `operand`, returning the result.\n     * **This method is different from `applyDivToSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {number} operand the divisor for the desired element of this pair\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} the couple that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFrom(operand, position) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        switch (position) {\n            case pair_1.PairPosition.FIRST: return new NumberCouple(this.getFirst() / operand, this.getSecond());\n            case pair_1.PairPosition.SECOND: return new NumberCouple(this.getFirst(), this.getSecond() / operand);\n        }\n    }\n    simpleOperator(operator1, operator2) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n        }\n        return new NumberCouple(operator1(this.getFirst()), operator2(this.getSecond()));\n    }\n    operator(operator1, operator2, ...args) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n        }\n        return new NumberCouple(operator1(this.getFirst(), ...args), operator2(this.getSecond(), ...args));\n    }\n    /**\n     * Executes a simple operator with the **first** element of this pair.\n     * **This method is different from `applySimpleOperatorToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    simpleOperatorToFirst(operator) {\n        return new NumberCouple(operator(this.getFirst()), this.getSecond());\n    }\n    /**\n     * Executes a simple operator with the **second** element of this pair.\n     * **This method is different from `applySimpleOperatorToSecond()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    simpleOperatorToSecond(operator) {\n        return new NumberCouple(this.getFirst(), operator(this.getSecond()));\n    }\n    /**\n     * Executes a simple operator with the element of this pair at the specified position.\n     * **This method is different from `applySimpleOperatorTo()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {PairPosition} position the position\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    simpleOperatorTo(operator, position) {\n        switch (position) {\n            case pair_1.PairPosition.FIRST: return new NumberCouple(operator(this.getFirst()), this.getSecond());\n            case pair_1.PairPosition.SECOND: return new NumberCouple(this.getFirst(), operator(this.getSecond()));\n        }\n    }\n    /**\n     * Executes an operator with the **first** element of this pair.\n     * **This method is different from `applySimpleOperatorToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    operatorToFirst(operator, ...args) {\n        return new NumberCouple(operator(this.getFirst(), ...args), this.getSecond());\n    }\n    /**\n     * Executes an operator with the **second** element of this pair.\n     * **This method is different from `applySimpleOperatorToFirst()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    operatorToSecond(operator, ...args) {\n        return new NumberCouple(this.getFirst(), operator(this.getSecond(), ...args));\n    }\n    /**\n     * Executes an operator with the element of this pair at the specified position.\n     * **This method is different from `applySimpleOperatorTo()` because it does not touch the\n     * internal elements of this couple** but only returns the couple that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {PairPosition} position the position\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberCouple} the couple that contains the result\n     */\n    operatorTo(operator, position, ...args) {\n        switch (position) {\n            case pair_1.PairPosition.FIRST: return new NumberCouple(operator(this.getFirst(), ...args), this.getSecond());\n            case pair_1.PairPosition.SECOND: return new NumberCouple(this.getFirst(), operator(this.getSecond(), ...args));\n        }\n    }\n    /**\n     * Returns `true` if the given `number` is *between* the ones in this couple.\n     * This method basically chef if the number is `>` or `>=` then the minimum in this\n     * couple and `<` or `<=` then the maximum. The two parameters `leftEq` and `rightEq`\n     * allow to specify:\n     *\n     * - if `leftEq` is `true`, then the *left* check will be `MIN <= number`\n     * - if `rightEq` is `true`, then the *right* check will be `number <= MAX`\n     * @param {number} number the number to be checked\n     * @param {boolean} leftEq if `true`, the check will include the case in which `number` is equal to the minimum\n     * (`true` by default)\n     * @param {boolean} rightEq if `true`, the check will include the case in which `number` is equal to the maximum\n     * (`true` by default)\n     * @return `true` if the given `number` is *between* the ones in this couple, `false` otherwise\n     */\n    isBetween(number, leftEq = true, rightEq = true) {\n        let min;\n        let max;\n        if (this.getFirst() < this.getSecond()) {\n            min = this.getFirst();\n            max = this.getSecond();\n        }\n        else {\n            min = this.getSecond();\n            max = this.getFirst();\n        }\n        return (number > min || (number == min && leftEq))\n            && (number < this.getSecond() || (number == this.getSecond() && rightEq));\n    }\n    clone() {\n        return new NumberCouple(this.getFirst(), this.getSecond());\n    }\n}\nexports.NumberCouple = NumberCouple;\n/**\n * Creates and return a new couple of numbers\n * @param {number} number1 the first number\n * @param {number} number2 the second number\n * @return the new `NumberCouple`\n */\nfunction numberCouple(number1, number2) {\n    return new NumberCouple(number1, number2);\n}\nexports.numberCouple = numberCouple;\n\n\n//# sourceURL=webpack:///./src/ts/types/numbers/number-couple.ts?");

/***/ }),

/***/ "./src/ts/types/numbers/number-trio.ts":
/*!*********************************************!*\
  !*** ./src/ts/types/numbers/number-trio.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.numberTrio = exports.NumberTrio = void 0;\nconst illegal_argument_exception_1 = __webpack_require__(/*! ../exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nconst triple_1 = __webpack_require__(/*! ../triple */ \"./src/ts/types/triple.ts\");\nclass NumberTrio extends triple_1.Triple {\n    constructor(number1, number2, number3) {\n        super(number1, number2, number3);\n    }\n    applyAdd(operand1, operand2, operand3) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        this.setFirst(this.getSecond() + operand1);\n        this.setSecond(this.getSecond() + operand2);\n        this.setThird(this.getThird() + operand3);\n        return this;\n    }\n    /**\n     * Apply an addition to the **first** element of this trio.\n     * This method will update the internal elements of this triple by adding\n     * the given argument to the first one, then returns `this`\n     * @param {number} operand the number to be added to the **first** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applyAddToFirst(operand) {\n        this.setFirst(this.getFirst() + operand);\n        return this;\n    }\n    /**\n     * Apply an addition to the **second** element of this trio.\n     * This method will update the internal elements of this triple by adding\n     * the given argument to the second one, then returns `this`\n     * @param {number} operand the number to be added to the **second** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applyAddToSecond(operand) {\n        this.setSecond(this.getSecond() + operand);\n        return this;\n    }\n    /**\n     * Apply an addition to the **third** element of this trio.\n     * This method will update the internal elements of this triple by adding\n     * the given argument to the third one, then returns `this`\n     * @param {number} operand the number to be added to the **third** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applyAddToThird(operand) {\n        this.setThird(this.getThird() + operand);\n        return this;\n    }\n    /**\n     * Apply an addition to the element of this trio specified by the `position` parameter.\n     * This method will update the internal elements of this triple by adding\n     * the given argument to the desired one, then returns `this`\n     * @param {number} operand the number to be added to the desired element of this triple\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} this trio\n     */\n    applyAddTo(operand, position) {\n        this.set(this.get(position) + operand, position);\n        return this;\n    }\n    applySub(operand1, operand2, operand3) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        this.setFirst(this.getFirst() - operand1);\n        this.setSecond(this.getSecond() - operand2);\n        this.setThird(this.getThird() - operand3);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the **first** element of this trio.\n     * This method will update the internal elements of this triple by subtracting\n     * the given argument from the first one, then returns `this`\n     * @param {number} operand the number to be subtracted from the **first** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applySubFromFirst(operand) {\n        this.setFirst(this.getFirst() - operand);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the **second** element of this trio.\n     * This method will update the internal elements of this triple by subtracting\n     * the given argument from the second one, then returns `this`\n     * @param {number} operand the number to be subtracted from the **second** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applySubFromSecond(operand) {\n        this.setSecond(this.getSecond() - operand);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the **third** element of this trio.\n     * This method will update the internal elements of this triple by subtracting\n     * the given argument from the third one, then returns `this`\n     * @param {number} operand the number to be subtracted from the **third** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applySubFromThird(operand) {\n        this.setThird(this.getThird() - operand);\n        return this;\n    }\n    /**\n     * Apply a subtraction to the element of this trio specified by `position`.\n     * This method will update the internal elements of this triple by subtracting\n     * the given argument from the desired one, then returns `this`\n     * @param {number} operand the number to be subtracted\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} this trio\n     */\n    applySubFrom(operand, position) {\n        this.set(this.get(position) - operand, position);\n        return this;\n    }\n    applyMul(operand1, operand2, operand3) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        this.setFirst(this.getFirst() * operand1);\n        this.setSecond(this.getSecond() * operand2);\n        this.setThird(this.getThird() * operand3);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the **first** element of this trio.\n     * This method will update the internal elements of this triple by multiplying\n     * the given argument to the first one, then returns `this`\n     * @param {number} operand the number to be multiplied to the **first** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applyMulToFirst(operand) {\n        this.setFirst(this.getFirst() + operand);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the **second** element of this trio.\n     * This method will update the internal elements of this triple by multiplying\n     * the given argument to the second one, then returns `this`\n     * @param {number} operand the number to be multiplied to the **second** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applyMulToSecond(operand) {\n        this.setSecond(this.getSecond() + operand);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the **third** element of this trio.\n     * This method will update the internal elements of this triple by multiplying\n     * the given argument to the second one, then returns `this`\n     * @param {number} operand the number to be multiplied to the **third** element of this triple\n     * @returns {NumberTrio} this trio\n     */\n    applyMulToThird(operand) {\n        this.setThird(this.getThird() + operand);\n        return this;\n    }\n    /**\n     * Apply a multiplication to the element of this trio specified by `position`.\n     * This method will update the internal elements of this triple by multiplying\n     * the given argument to the one at the desired position, then returns `this`\n     * @param {number} operand the number to be multiplied to the **second** element of this triple\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} this trio\n     */\n    applyMulTo(operand, position) {\n        this.set(this.get(position) + operand, position);\n        return this;\n    }\n    applyDiv(operand1, operand2, operand3) {\n        if (operand1 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the first operand is 0: impossible to divide by 0');\n        }\n        if (operand2 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the second operand is 0: impossible to divide by 0');\n        }\n        if (operand3 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the third operand is 0: impossible to divide by 0');\n        }\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        this.setFirst(this.getFirst() / operand1);\n        this.setSecond(this.getSecond() / operand2);\n        this.setThird(this.getThird() / operand3);\n        return this;\n    }\n    /**\n     * Apply a division to the **first** element of this trio.\n     * This method will update the internal elements of this triple by dividing\n     * the first one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the **first** element of this triple\n     * @returns {NumberTrio} this trio\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivToFirst(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.setFirst(this.getFirst() / operand);\n        return this;\n    }\n    /**\n     * Apply a division to the **second** element of this trio.\n     * This method will update the internal elements of this triple by dividing\n     * the second one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the **second** element of this triple\n     * @returns {NumberTrio} this trio\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivToSecond(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.setSecond(this.getSecond() / operand);\n        return this;\n    }\n    /**\n     * Apply a division to the **third** element of this trio.\n     * This method will update the internal elements of this triple by dividing\n     * the third one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the **third** element of this triple\n     * @returns {NumberTrio} this trio\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivToThird(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.setThird(this.getThird() / operand);\n        return this;\n    }\n    /**\n     * Apply a division to the element of this trio specified by `position`.\n     * This method will update the internal elements of this triple by dividing\n     * the desired one by the argument of this method, then returns `this`\n     * @param {number} operand the divisor for the desired element of this triple\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} this trio\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    applyDivTo(operand, position) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        this.set(this.get(position) / operand, position);\n        return this;\n    }\n    applySimpleOperator(operator1, operator2, operator3) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n            operator3 = operator1;\n        }\n        this.setFirst(operator1(this.getFirst()));\n        this.setSecond(operator2(this.getSecond()));\n        this.setThird(operator3(this.getThird()));\n        return this;\n    }\n    applyOperator(operator1, operator2, operator3, ...args) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n            operator3 = operator1;\n        }\n        this.setFirst(operator1(this.getFirst(), ...args));\n        this.setSecond(operator2(this.getSecond(), ...args));\n        this.setThird(operator3(this.getThird(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **first** element of this triple.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the first element of this triple.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns this trio\n     */\n    applySimpleOperatorToFirst(operator) {\n        this.setFirst(operator(this.getFirst()));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **second** element of this triple.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the second element of this triple.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns this trio\n     */\n    applySimpleOperatorToSecond(operator) {\n        this.setSecond(operator(this.getSecond()));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **third** element of this triple.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the third element of this triple.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns this trio\n     */\n    applySimpleOperatorToThird(operator) {\n        this.setThird(operator(this.getThird()));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the element of this triple specified by `position`.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the desired element of this triple.\n     * Notice that the operand is simple because it only takes a number and returns the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {TriplePosition} position the position\n     * @returns this trio\n     */\n    applySimpleOperatorTo(operator, position) {\n        this.set(operator(this.get(position)), position);\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **first** element of this triple.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the first element of this triple\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this trio\n     */\n    applyOperatorToFirst(operator, ...args) {\n        this.setFirst(operator(this.getFirst(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **second** element of this triple.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the second element of this triple\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this trio\n     */\n    applyOperatorToSecond(operator, ...args) {\n        this.setSecond(operator(this.getSecond(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the **third** element of this triple.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the third element of this triple\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this trio\n     */\n    applyOperatorToThird(operator, ...args) {\n        this.setThird(operator(this.getThird(), ...args));\n        return this;\n    }\n    /**\n     * Applies a simple operator to the element of this triple specified by `position`.\n     * This method will update the internal element of this triple by applying `operand`\n     * to the desired element of this triple\n     * @param {NumericOperator} operator the simple operator function\n     * @param {TriplePosition} position the position\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns this trio\n     */\n    applyOperatorTo(operator, position, ...args) {\n        this.set(operator(this.get(position), ...args), position);\n        return this;\n    }\n    add(operand1, operand2, operand3) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        return new NumberTrio(this.getFirst() + operand1, this.getSecond() + operand2, this.getThird() + operand3);\n    }\n    /**\n     * Adds the given `operand` to the **first** element of this trio returning the result.\n     * **This method is different from `applyAddToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be added to the first element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    addToFirst(operand) {\n        return new NumberTrio(this.getFirst() + operand, this.getSecond(), this.getThird());\n    }\n    /**\n     * Adds the given `operand` to the **second** element of this trio returning the result.\n     * **This method is different from `applyAddToSecond()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be added to the second element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    addToSecond(operand) {\n        return new NumberTrio(this.getFirst(), this.getSecond() + operand, this.getThird());\n    }\n    /**\n     * Adds the given `operand` to the **third** element of this trio returning the result.\n     * **This method is different from `applyAddToThird()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be added to the third element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    addToThird(operand) {\n        return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() + operand);\n    }\n    /**\n     * Adds the given `operand` to the element of this trio at the specified position, returning the result.\n     * **This method is different from `applyAddTo()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be added to the second element of this triple\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    addTo(operand, position) {\n        switch (position) {\n            case triple_1.TriplePosition.FIRST: return new NumberTrio(this.getFirst() + operand, this.getSecond(), this.getThird());\n            case triple_1.TriplePosition.SECOND: return new NumberTrio(this.getFirst(), this.getSecond() + operand, this.getThird());\n            case triple_1.TriplePosition.THIRD: return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() + operand);\n        }\n    }\n    sub(operand1, operand2, operand3) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        return new NumberTrio(this.getFirst() - operand1, this.getSecond() - operand2, this.getThird() - operand3);\n    }\n    /**\n     * Subtracts the given `operand` from the **first** element of this trio returning the result.\n     * **This method is different from `applySubtractFromFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be subtracted from the first element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    subFromFirst(operand) {\n        return new NumberTrio(this.getFirst() - operand, this.getSecond(), this.getThird());\n    }\n    /**\n     * Subtracts the given `operand` from the **second** element of this trio returning the result.\n     * **This method is different from `applySubtractSecond()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be subtracted from the second element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    subFromSecond(operand) {\n        return new NumberTrio(this.getFirst(), this.getSecond() - operand, this.getThird());\n    }\n    /**\n     * Subtracts the given `operand` from the **third** element of this trio returning the result.\n     * **This method is different from `applySubtractThird()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be subtracted from the third element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    subFromThird(operand) {\n        return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() - operand);\n    }\n    /**\n     * Subtracts the given `operand` from the element of this trio at the specified position, returning the result.\n     * **This method is different from `applySubFrom()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be subtracted from the desired element of this triple\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    subFrom(operand, position) {\n        switch (position) {\n            case triple_1.TriplePosition.FIRST: return new NumberTrio(this.getFirst() - operand, this.getSecond(), this.getThird());\n            case triple_1.TriplePosition.SECOND: return new NumberTrio(this.getFirst(), this.getSecond() - operand, this.getThird());\n            case triple_1.TriplePosition.THIRD: return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() - operand);\n        }\n    }\n    mul(operand1, operand2, operand3) {\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        return new NumberTrio(this.getFirst() * operand1, this.getSecond() * operand2, this.getThird() * operand3);\n    }\n    /**\n     * Multiply the given `operand` to the **first** element of this trio returning the result.\n     * **This method is different from `applyMulToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be multiplied to the first element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    mulToFirst(operand) {\n        return new NumberTrio(this.getFirst() * operand, this.getSecond(), this.getThird());\n    }\n    /**\n     * Multiply the given `operand` to the **second** element of this trio returning the result.\n     * **This method is different from `applyMulToSecond()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be multiplied to the second element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    mulToSecond(operand) {\n        return new NumberTrio(this.getFirst(), this.getSecond() * operand, this.getThird());\n    }\n    /**\n     * Multiply the given `operand` to the **third** element of this trio returning the result.\n     * **This method is different from `applyMulToThird()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be multiplied to the third element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    mulToThird(operand) {\n        return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() * operand);\n    }\n    /**\n     * Multiply the given `operand` to the element of this trio returning the result.\n     * **This method is different from `applyMulToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the number to be multiplied to the first element of this triple\n     * @param {position} position the position\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    mulTo(operand, position) {\n        switch (position) {\n            case triple_1.TriplePosition.FIRST: return new NumberTrio(this.getFirst() * operand, this.getSecond(), this.getThird());\n            case triple_1.TriplePosition.SECOND: return new NumberTrio(this.getFirst(), this.getSecond() * operand, this.getThird());\n            case triple_1.TriplePosition.THIRD: return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() * operand);\n        }\n    }\n    div(operand1, operand2, operand3) {\n        if (operand1 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the first operand is 0: impossible to divide by 0');\n        }\n        if (operand2 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the second operand is 0: impossible to divide by 0');\n        }\n        if (operand3 === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the third operand is 0: impossible to divide by 0');\n        }\n        if (operand2 == undefined) {\n            operand2 = operand1;\n            operand3 = operand1;\n        }\n        return new NumberTrio(this.getFirst() / operand1, this.getSecond() / operand2, this.getThird() / operand3);\n    }\n    /**\n     * Divide the **first** element of this trio by the given `operand`, returning the result.\n     * **This method is different from `applyDivToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the divisor for the first element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFromFirst(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        return new NumberTrio(this.getFirst() / operand, this.getSecond(), this.getThird());\n    }\n    /**\n     * Divide the **second** element of this trio by the given `operand`, returning the result.\n     * **This method is different from `applyDivToSecond()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the divisor for the second element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFromSecond(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        return new NumberTrio(this.getFirst(), this.getSecond() / operand, this.getThird());\n    }\n    /**\n     * Divide the **third** element of this trio by the given `operand`, returning the result.\n     * **This method is different from `applyDivToThird()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the divisor for the third element of this triple\n     * @returns {NumberTrio} the trio that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFromThird(operand) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() / operand);\n    }\n    /**\n     * Divide the element of this trio at the specified position by the given `operand`, returning the result.\n     * **This method is different from `applyDivToSecond()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {number} operand the divisor for the desired element of this triple\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} the trio that contains the result\n     * @throws {IllegalArgumentException} if the operand is `0`\n     */\n    divFrom(operand, position) {\n        if (operand === 0) {\n            throw new illegal_argument_exception_1.IllegalArgumentException('the divisor is 0: impossible to divide by 0');\n        }\n        switch (position) {\n            case triple_1.TriplePosition.FIRST: return new NumberTrio(this.getFirst() / operand, this.getSecond(), this.getThird());\n            case triple_1.TriplePosition.SECOND: return new NumberTrio(this.getFirst(), this.getSecond() / operand, this.getThird());\n            case triple_1.TriplePosition.THIRD: return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird() / operand);\n        }\n    }\n    simpleOperator(operator1, operator2, operator3) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n            operator3 = operator1;\n        }\n        return new NumberTrio(operator1(this.getFirst()), operator2(this.getSecond()), operator3(this.getThird()));\n    }\n    operator(operator1, operator2, operator3, ...args) {\n        if (operator2 == undefined) {\n            operator2 = operator1;\n            operator3 = operator1;\n        }\n        return new NumberTrio(operator1(this.getFirst(), ...args), operator2(this.getSecond(), ...args), operator3(this.getThird(), ...args));\n    }\n    /**\n     * Executes a simple operator with the **first** element of this triple.\n     * **This method is different from `applySimpleOperatorToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    simpleOperatorToFirst(operator) {\n        return new NumberTrio(operator(this.getFirst()), this.getSecond(), this.getThird());\n    }\n    /**\n     * Executes a simple operator with the **second** element of this triple.\n     * **This method is different from `applySimpleOperatorToSecond()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    simpleOperatorToSecond(operator) {\n        return new NumberTrio(this.getFirst(), operator(this.getSecond()), this.getThird());\n    }\n    /**\n     * Executes a simple operator with the **third** element of this triple.\n     * **This method is different from `applySimpleOperatorToThird()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    simpleOperatorToThird(operator) {\n        return new NumberTrio(this.getFirst(), this.getSecond(), operator(this.getThird()));\n    }\n    /**\n     * Executes a simple operator with the element of this triple at the specified position.\n     * **This method is different from `applySimpleOperatorTo()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {TriplePosition} position the position\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    simpleOperatorTo(operator, position) {\n        switch (position) {\n            case triple_1.TriplePosition.FIRST: return new NumberTrio(operator(this.getFirst()), this.getSecond(), this.getThird());\n            case triple_1.TriplePosition.SECOND: return new NumberTrio(this.getFirst(), operator(this.getSecond()), this.getThird());\n            case triple_1.TriplePosition.THIRD: return new NumberTrio(this.getFirst(), this.getSecond(), operator(this.getThird()));\n        }\n    }\n    /**\n     * Executes an operator with the **first** element of this triple.\n     * **This method is different from `applySimpleOperatorToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    operatorToFirst(operator, ...args) {\n        return new NumberTrio(operator(this.getFirst(), ...args), this.getSecond(), this.getThird());\n    }\n    /**\n     * Executes an operator with the **second** element of this triple.\n     * **This method is different from `applySimpleOperatorToFirst()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    operatorToSecond(operator, ...args) {\n        return new NumberTrio(this.getFirst(), operator(this.getSecond(), ...args), this.getThird());\n    }\n    /**\n     * Executes an operator with the **third** element of this triple.\n     * **This method is different from `applySimpleOperatorToThird()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    operatorToThird(operator, ...args) {\n        return new NumberTrio(this.getFirst(), this.getSecond(), operator(this.getThird(), ...args));\n    }\n    /**\n     * Executes an operator with the element of this triple at the specified position.\n     * **This method is different from `applySimpleOperatorTo()` because it does not touch the\n     * internal elements of this trio** but only returns the trio that contains the result\n     * @param {NumericOperator} operator the simple operator function\n     * @param {TriplePosition} position the position\n     * @param {...any} args the arguments to be passed to the operator\n     * @returns {NumberTrio} the trio that contains the result\n     */\n    operatorTo(operator, position, ...args) {\n        switch (position) {\n            case triple_1.TriplePosition.FIRST: return new NumberTrio(operator(this.getFirst(), ...args), this.getSecond(), this.getThird());\n            case triple_1.TriplePosition.SECOND: return new NumberTrio(this.getFirst(), operator(this.getSecond(), ...args), this.getThird());\n            case triple_1.TriplePosition.THIRD: return new NumberTrio(this.getFirst(), this.getSecond(), operator(this.getThird(), ...args));\n        }\n    }\n    clone() {\n        return new NumberTrio(this.getFirst(), this.getSecond(), this.getThird());\n    }\n}\nexports.NumberTrio = NumberTrio;\n/**\n * Creates and returns a new trio of numbers\n * @param {number} number1 the first number\n * @param {number} number2 the second number\n * @param {number} number3 the third number\n */\nfunction numberTrio(number1, number2, number3) {\n    return new NumberTrio(number1, number2, number3);\n}\nexports.numberTrio = numberTrio;\n\n\n//# sourceURL=webpack:///./src/ts/types/numbers/number-trio.ts?");

/***/ }),

/***/ "./src/ts/types/pair.ts":
/*!******************************!*\
  !*** ./src/ts/types/pair.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Pair_first, _Pair_second;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.coupleAsColumnArray = exports.coupleAsRowArray = exports.coupleOf = exports.pairOf = exports.Pair = exports.PairPosition = void 0;\nconst index_out_of_bound_exception_1 = __webpack_require__(/*! ./exceptions/index-out-of-bound-exception */ \"./src/ts/types/exceptions/index-out-of-bound-exception.ts\");\nconst equatable_1 = __webpack_require__(/*! ./equatable */ \"./src/ts/types/equatable.ts\");\nconst cloneable_1 = __webpack_require__(/*! ./cloneable */ \"./src/ts/types/cloneable.ts\");\nconst matrix_1 = __webpack_require__(/*! ../geometry/matrix/matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\nconst triple_1 = __webpack_require__(/*! ./triple */ \"./src/ts/types/triple.ts\");\n/**\n * An enumeration that allow to access the element to a specific position\n * in a `Pair` instance\n */\nvar PairPosition;\n(function (PairPosition) {\n    PairPosition[PairPosition[\"FIRST\"] = 0] = \"FIRST\";\n    PairPosition[PairPosition[\"SECOND\"] = 1] = \"SECOND\";\n})(PairPosition = exports.PairPosition || (exports.PairPosition = {}));\n/**\n * A pair of two elements\n */\nclass Pair {\n    constructor(first, second) {\n        _Pair_first.set(this, null);\n        _Pair_second.set(this, null);\n        __classPrivateFieldSet(this, _Pair_first, first, \"f\");\n        __classPrivateFieldSet(this, _Pair_second, second, \"f\");\n    }\n    /**\n     * Gets the element at the specified position\n     * @param {PairPosition} position the position of the element to get\n     * @return {F|S} the desired element\n     * @throws {IndexOutOfBoundException} if the index is not valid\n     */\n    get(position) {\n        switch (position) {\n            case PairPosition.FIRST || 0: return __classPrivateFieldGet(this, _Pair_first, \"f\");\n            case PairPosition.SECOND || 1: return __classPrivateFieldGet(this, _Pair_second, \"f\");\n            default:\n                throw new index_out_of_bound_exception_1.IndexOutOfBoundException(position);\n        }\n    }\n    /**\n     * Sets the element of this pair at the specified position.\n     * Please notice that **this method is not safe cause it is not possible to check the type** of\n     * the value to be set\n     * @param {F|S} value the value to be set\n     * @param {PairPosition} position the position in which put the new value\n     * @throws {IndexOutOfBoundException} if the index is not valid\n     */\n    set(value, position) {\n        switch (position) {\n            case PairPosition.FIRST: __classPrivateFieldSet(this, _Pair_first, value, \"f\");\n            case PairPosition.SECOND: __classPrivateFieldSet(this, _Pair_second, value, \"f\");\n            default:\n                throw new index_out_of_bound_exception_1.IndexOutOfBoundException(position);\n        }\n    }\n    /**\n     * Returns the **first** element of this pair\n     */\n    getFirst() {\n        return __classPrivateFieldGet(this, _Pair_first, \"f\");\n    }\n    /**\n     * Returns the **second** element of this pair\n     */\n    getSecond() {\n        return __classPrivateFieldGet(this, _Pair_second, \"f\");\n    }\n    /**\n     * Sets the **first** element of this pair\n     * @param {F|null} first the first element\n     */\n    setFirst(first) {\n        __classPrivateFieldSet(this, _Pair_first, first, \"f\");\n    }\n    /**\n     * Sets the **second** element of this pair\n     * @param {S|null} second the first element\n     */\n    setSecond(second) {\n        __classPrivateFieldSet(this, _Pair_second, second, \"f\");\n    }\n    /**\n     * Sets the **first** and the **second** element of this pair\n     * @param {F|null} first the first element\n     * @param {S|null} second the second element\n     */\n    setAll(first, second) {\n        __classPrivateFieldSet(this, _Pair_first, first, \"f\");\n        __classPrivateFieldSet(this, _Pair_second, second, \"f\");\n    }\n    /**\n     * Sets the elements of this pair to the values of the given `pair`\n     * @param {Pair<F, S>} other the pair to take the values from\n     */\n    setFrom(other) {\n        __classPrivateFieldSet(this, _Pair_first, __classPrivateFieldGet(other, _Pair_first, \"f\"), \"f\");\n        __classPrivateFieldSet(this, _Pair_second, __classPrivateFieldGet(other, _Pair_second, \"f\"), \"f\");\n    }\n    /**\n     * Adds an element to this couple producing a `Triple` with the two element of this\n     * couple *plus* the one given as parameter\n     * @param element\n     */\n    plus(element) {\n        return new triple_1.Triple(__classPrivateFieldGet(this, _Pair_first, \"f\"), __classPrivateFieldGet(this, _Pair_second, \"f\"), element);\n    }\n    /**\n     * Check if the given `element` is present in somewhere in this pair.<br>\n     * It is better if the types of the element of the `Pair` implements `Equatable` otherwise\n     * it will be used the `===` equality operator\n     * @param {F|S} element the element to check for the presence\n     * @return {boolean} `true` if the element id present in this pair\n     */\n    contains(element) {\n        return ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Pair_first, \"f\"), element) || (0, equatable_1.equals)(__classPrivateFieldGet(this, _Pair_second, \"f\"), element));\n    }\n    /**\n     * Searches for the given `element` returning its position if present.<br>\n     * If the element is not present, this method returns `null`\n     * @param {F|S} element the element to search for\n     * @return {PairPosition|null} the position of the element of `null` if not present\n     **/\n    search(element) {\n        if ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Pair_first, \"f\"), element))\n            return PairPosition.FIRST;\n        if ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Pair_first, \"f\"), element))\n            return PairPosition.SECOND;\n        return null;\n    }\n    /**\n     * Returns a copy of this pair which contains the same elements in this but with\n     * the **reverse order** (the `first` element of this will become the `second` of the new, the\n     * `second` element of this will become the `first` of the new)\n     */\n    reverted() {\n        return new Pair(__classPrivateFieldGet(this, _Pair_second, \"f\"), __classPrivateFieldGet(this, _Pair_first, \"f\"));\n    }\n    /**\n     * Collects the two element of this pair to produce a single result\n     * @param {(first: F, second: S) => R} collector the function that accepts the two elements of this pair\n     * and returns the result\n     */\n    collect(collector) {\n        return collector(__classPrivateFieldGet(this, _Pair_first, \"f\"), __classPrivateFieldGet(this, _Pair_second, \"f\"));\n    }\n    /**\n     * Applies the `mapper` function on the **first** element of this pair and\n     * returns a new pair which contains the result of this function as the first\n     * element and the second element that is the second one of this pair\n     * @param {(first: F|null) => R} mapper the transformation function for the `first` element\n     * @return {Pair<R, S>} the new pair with the transformed first element\n     */\n    mapFirst(mapper) {\n        return new Pair(mapper(__classPrivateFieldGet(this, _Pair_first, \"f\")), __classPrivateFieldGet(this, _Pair_second, \"f\"));\n    }\n    /**\n     * Applies the `mapper` function on the **second** element of this pair and\n     * returns a new pair which contains the result of this function as the second\n     * element and the first element that is the first one of this pair\n     * @param {(second: S|null) => R} mapper the transformation function for the `second` element\n     * @return {Pair<R, S>} the new pair with the transformed second element\n     */\n    mapSecond(mapper) {\n        return new Pair(__classPrivateFieldGet(this, _Pair_first, \"f\"), mapper(__classPrivateFieldGet(this, _Pair_second, \"f\")));\n    }\n    /**\n     * Returns an array containing the two elements in this pair, preserving the order\n     */\n    toArray() {\n        return [__classPrivateFieldGet(this, _Pair_first, \"f\"), __classPrivateFieldGet(this, _Pair_second, \"f\")];\n    }\n    /**\n     * Returns a clone of this pair. Every changes over the returning value **will not have effects** on\n     * this.\n     * **Notice that the copy will be deep only if the two elements are `Cloneable` themselves**, otherwise\n     * the clone will be a shallow copy equivalent to the result of `copy()`\n     */\n    clone() {\n        return new Pair((0, cloneable_1.tryClone)(__classPrivateFieldGet(this, _Pair_first, \"f\")), (0, cloneable_1.tryClone)(__classPrivateFieldGet(this, _Pair_second, \"f\")));\n    }\n    /**\n     * Returns a shallow copy of this pair.\n     * Every changes over the returning value **will not have effects** on this but changes on the elements\n     * can be propagated (is a *shallow copy*)\n     */\n    copy() {\n        return new Pair(__classPrivateFieldGet(this, _Pair_first, \"f\"), __classPrivateFieldGet(this, _Pair_second, \"f\"));\n    }\n    toString() {\n        return \"Pair(\" + __classPrivateFieldGet(this, _Pair_first, \"f\") + \", \" + __classPrivateFieldGet(this, _Pair_second, \"f\") + \")\";\n    }\n    /**\n     * Returns `true` the `other` object is a `Pair` with the two elements that are\n     * equals (intended as `===`) to the ones in this pair\n     * @param {any} other the other object\n     * @return {boolean} `true` if the `other` is a pair equals to this\n     */\n    equals(other) {\n        if (other != null) {\n            if (other instanceof Pair) {\n                return __classPrivateFieldGet(this, _Pair_first, \"f\") === __classPrivateFieldGet(other, _Pair_first, \"f\") && __classPrivateFieldGet(this, _Pair_second, \"f\") === __classPrivateFieldGet(other, _Pair_second, \"f\");\n            }\n        }\n        return false;\n    }\n    /**\n     * Apply the `mapper` function to this object and returns the result.\n     * This function basically let to *transforms* this object into another thanks to\n     * the `mapper` function\n     * @param {(pair: Pair<F, S>) => R} mapper the transformation function\n     * @return {R} the result of the transformation\n     */\n    map(mapper) {\n        return mapper(this);\n    }\n    /**\n     * Executes the given `block` passing this object to it, then returns this object\n     * @param {Pair<F, S>) => void} block the function to be executed on this object\n     * @return {Pair<F, S>} this object\n     */\n    apply(block) {\n        block(this);\n        return this;\n    }\n}\nexports.Pair = Pair;\n_Pair_first = new WeakMap(), _Pair_second = new WeakMap();\n/**\n * Creates and returns a new **pair** with the two elements given as parameters\n * @param {F|null} first the first element\n * @param {S|null} second the second element\n * @return {Pair<F, S>} the new created pair\n */\nfunction pairOf(first, second) {\n    return new Pair(first, second);\n}\nexports.pairOf = pairOf;\n/**\n * Creates and returns a new **couple** with the two elements given as parameters\n * @param {T|null} first the first element\n * @param {T|null} second the second element\n * @return {Couple<T>} the new created couple\n */\nfunction coupleOf(first, second) {\n    return new Pair(first, second);\n}\nexports.coupleOf = coupleOf;\n/**\n * Creates and returns a row array intended as a *1x2* matrix\n * @param {Couple<T>} couple the couple to be converted\n * @return a *1x2* matrix with the elements of the given pair\n */\nfunction coupleAsRowArray(couple) {\n    let data = couple.toArray();\n    return (0, matrix_1.matrix)(data);\n}\nexports.coupleAsRowArray = coupleAsRowArray;\n/**\n * Creates and returns a column array intended as a *2x1* matrix\n * @param {Couple<T>} couple the couple to be converted\n * @return a *2x1* matrix with the elements of the given pair\n */\nfunction coupleAsColumnArray(couple) {\n    let data = new Array(2);\n    for (let r = 0; r < data.length; r++) {\n        data[r] = [couple.get(r)];\n    }\n    return (0, matrix_1.matrix)(data);\n}\nexports.coupleAsColumnArray = coupleAsColumnArray;\n\n\n//# sourceURL=webpack:///./src/ts/types/pair.ts?");

/***/ }),

/***/ "./src/ts/types/result.ts":
/*!********************************!*\
  !*** ./src/ts/types/result.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _Result_value, _Result_error;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resultOf = exports.Result = void 0;\nconst illegal_argument_exception_1 = __webpack_require__(/*! ./exceptions/illegal-argument-exception */ \"./src/ts/types/exceptions/illegal-argument-exception.ts\");\nconst illegal_state_exception_1 = __webpack_require__(/*! ./exceptions/illegal-state-exception */ \"./src/ts/types/exceptions/illegal-state-exception.ts\");\nclass Result {\n    /**\n     * Creates and returns a new **successful** result which contains\n     * a value\n     * @param {T} value the value of the result\n     * @return {Result<T>} the new successful result\n     */\n    static ofSuccess(value) {\n        return new Result(value, null);\n    }\n    /**\n     * Creates and returns a new **failure**, storing the error which caused it\n     * @param {Error} error the error which caused the failure\n     * @return {Result<void>} the new failed result\n     */\n    static ofFailure(error) {\n        return new Result(null, error);\n    }\n    constructor(value, error) {\n        _Result_value.set(this, void 0);\n        _Result_error.set(this, void 0);\n        if (__classPrivateFieldGet(this, _Result_value, \"f\") != null && __classPrivateFieldGet(this, _Result_error, \"f\") != null) {\n            throw new illegal_argument_exception_1.IllegalArgumentException(\"value and error can NOT be non-null at the same time\");\n        }\n        __classPrivateFieldSet(this, _Result_value, value, \"f\");\n        __classPrivateFieldSet(this, _Result_error, error, \"f\");\n    }\n    /**\n     * Returns the value of this result or `null` if it's a failure (so no result is owned)\n     */\n    getValue() {\n        return __classPrivateFieldGet(this, _Result_value, \"f\");\n    }\n    /**\n     * Returns the error of this result of `null` if it's a success (so no error is present)\n     */\n    getError() {\n        return __classPrivateFieldGet(this, _Result_error, \"f\");\n    }\n    /**\n     * Returns the value of this result, throwing an error if this result is a failure\n     * @return {T} the value of this result\n     * @throws {IllegalStateException} if this result is a failure\n     */\n    getValueOrThrow() {\n        if (__classPrivateFieldGet(this, _Result_value, \"f\") == null)\n            throw new illegal_state_exception_1.IllegalStateException(\"this result is a failure: no value is present\");\n        return __classPrivateFieldGet(this, _Result_value, \"f\");\n    }\n    /**\n     * Returns the error of this result, throwing an error if this result is a success\n     * @return {Error} the error of this result\n     * @throws {IllegalStateException} if this result is a success\n     */\n    getErrorOrThrow() {\n        if (__classPrivateFieldGet(this, _Result_error, \"f\") == null)\n            throw new illegal_state_exception_1.IllegalStateException(\"this result is successful: no error is present\");\n        return __classPrivateFieldGet(this, _Result_error, \"f\");\n    }\n    /**\n     * Returns `true` if this result is a **success** (then it has a value)\n     */\n    isSuccess() {\n        return __classPrivateFieldGet(this, _Result_value, \"f\") != null;\n    }\n    /**\n     * Returns `true` if this result is a **failure** (than it has the cause of the failure)\n     */\n    isFailure() {\n        return __classPrivateFieldGet(this, _Result_error, \"f\") != null;\n    }\n    /**\n     * Executes the given function if this result is a **failure** (then contains the error).\n     * In that case the function will be invoked passing the error that caused the failure,\n     * otherwise nothing is performed\n     * @param {error: Error) => void} onError the function to be invoked in case of failure\n     */\n    withError(onError) {\n        if (this.isFailure()) {\n            onError(__classPrivateFieldGet(this, _Result_error, \"f\"));\n        }\n    }\n    /**\n     * Executes the given function if this result is a **success** (than contains a value).\n     * In that case the function will be invoked passing the value of the result,\n     * otherwise nothing is performed\n     * @param {error: Error) => void} onValue the function to be invoked in case of success\n     */\n    withValue(onValue) {\n        if (this.isSuccess()) {\n            onValue(__classPrivateFieldGet(this, _Result_value, \"f\"));\n        }\n    }\n}\nexports.Result = Result;\n_Result_value = new WeakMap(), _Result_error = new WeakMap();\n/**\n * Executes the given `operation` catching all the errors.\n * The returning result has:\n *\n * - the value returned from `operation` in case all has gone good\n * - the value of the thrown error in case of failure\n * @param {(...args: any) => T} operation the function that produces the value of the result\n * @param {...any} args the parameters of the `operation` function\n */\nfunction resultOf(operation, ...args) {\n    try {\n        return Result.ofSuccess(operation(...args));\n    }\n    catch (e) {\n        return Result.ofFailure(e);\n    }\n}\nexports.resultOf = resultOf;\n\n\n//# sourceURL=webpack:///./src/ts/types/result.ts?");

/***/ }),

/***/ "./src/ts/types/triple.ts":
/*!********************************!*\
  !*** ./src/ts/types/triple.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Triple_first, _Triple_second, _Triple_third;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.trioAsColumnArray = exports.trioAsRowArray = exports.trioOf = exports.tripleOf = exports.Triple = exports.TriplePosition = void 0;\nconst equatable_1 = __webpack_require__(/*! ./equatable */ \"./src/ts/types/equatable.ts\");\nconst index_out_of_bound_exception_1 = __webpack_require__(/*! ./exceptions/index-out-of-bound-exception */ \"./src/ts/types/exceptions/index-out-of-bound-exception.ts\");\nconst cloneable_1 = __webpack_require__(/*! ./cloneable */ \"./src/ts/types/cloneable.ts\");\nconst matrix_1 = __webpack_require__(/*! ../geometry/matrix/matrix */ \"./src/ts/geometry/matrix/matrix.ts\");\n/**\n * An enumeration that allow to access the element to a specific position\n * in a `Pair` instance\n */\nvar TriplePosition;\n(function (TriplePosition) {\n    TriplePosition[TriplePosition[\"FIRST\"] = 0] = \"FIRST\";\n    TriplePosition[TriplePosition[\"SECOND\"] = 1] = \"SECOND\";\n    TriplePosition[TriplePosition[\"THIRD\"] = 2] = \"THIRD\";\n})(TriplePosition = exports.TriplePosition || (exports.TriplePosition = {}));\n/***\n * A set of three objects\n */\nclass Triple {\n    constructor(first, second, third) {\n        _Triple_first.set(this, void 0);\n        _Triple_second.set(this, void 0);\n        _Triple_third.set(this, void 0);\n        __classPrivateFieldSet(this, _Triple_first, first, \"f\");\n        __classPrivateFieldSet(this, _Triple_second, second, \"f\");\n        __classPrivateFieldSet(this, _Triple_third, third, \"f\");\n    }\n    /**\n     * Gets the element at the specified position\n     * @param {TriplePosition} position the position of the element to get\n     * @return {F|S|T} the desired element\n     * @throws {IndexOutOfBoundException} if the index is not valid\n     */\n    get(position) {\n        switch (position) {\n            case TriplePosition.FIRST || 0: return __classPrivateFieldGet(this, _Triple_first, \"f\");\n            case TriplePosition.SECOND || 0: return __classPrivateFieldGet(this, _Triple_second, \"f\");\n            case TriplePosition.THIRD || 0: return __classPrivateFieldGet(this, _Triple_third, \"f\");\n            default:\n                throw new index_out_of_bound_exception_1.IndexOutOfBoundException(position);\n        }\n    }\n    /**\n     * Sets the element of this triple at the specified position.\n     * Please notice that **this method is not safe cause it is not possible to check the type** of\n     * the value to be set\n     * @param {F|S} value the value to be set\n     * @param {PairPosition} position the position in which put the new value\n     * @throws {IndexOutOfBoundException} if the index is not valid\n     */\n    set(value, position) {\n        switch (position) {\n            case TriplePosition.FIRST: __classPrivateFieldSet(this, _Triple_first, value, \"f\");\n            case TriplePosition.SECOND: __classPrivateFieldSet(this, _Triple_second, value, \"f\");\n            case TriplePosition.THIRD: __classPrivateFieldSet(this, _Triple_third, value, \"f\");\n            default:\n                throw new index_out_of_bound_exception_1.IndexOutOfBoundException(position);\n        }\n    }\n    /**\n     * Returns the **first** element of this pair\n     */\n    getFirst() {\n        return __classPrivateFieldGet(this, _Triple_first, \"f\");\n    }\n    /**\n     * Returns the **second** element of this pair\n     */\n    getSecond() {\n        return __classPrivateFieldGet(this, _Triple_second, \"f\");\n    }\n    /**\n     * Returns the **third** element of this pair\n     */\n    getThird() {\n        return __classPrivateFieldGet(this, _Triple_third, \"f\");\n    }\n    /**\n     * Sets the **first** element of this pair\n     * @param {F|null} first the first element\n     */\n    setFirst(first) {\n        __classPrivateFieldSet(this, _Triple_first, first, \"f\");\n    }\n    /**\n     * Sets the **second** element of this pair\n     * @param {S|null} second the second element\n     */\n    setSecond(second) {\n        __classPrivateFieldSet(this, _Triple_second, second, \"f\");\n    }\n    /**\n     * Sets the **third** element of this pair\n     * @param {T|null} third the third element\n     */\n    setThird(third) {\n        __classPrivateFieldSet(this, _Triple_third, third, \"f\");\n    }\n    /**\n     * Sets the elements of this pair to the values of the given `Triple`\n     * @param {Triple<F, S, T>} other the triple to copy\n     */\n    setFrom(other) {\n        __classPrivateFieldSet(this, _Triple_first, __classPrivateFieldGet(other, _Triple_first, \"f\"), \"f\");\n        __classPrivateFieldSet(this, _Triple_second, __classPrivateFieldGet(other, _Triple_second, \"f\"), \"f\");\n        __classPrivateFieldSet(this, _Triple_third, __classPrivateFieldGet(other, _Triple_third, \"f\"), \"f\");\n    }\n    /**\n     * Sets the **first**, the **second** and the **third** element of this triple\n     * @param {F|null} first the first element\n     * @param {S|null} second the second element\n     * @param {T|null} third the third element\n     */\n    setAll(first, second, third) {\n        __classPrivateFieldSet(this, _Triple_first, first, \"f\");\n        __classPrivateFieldSet(this, _Triple_second, second, \"f\");\n        __classPrivateFieldSet(this, _Triple_third, third, \"f\");\n    }\n    /**\n     * Returns a copy of this triple but **switched to right**\n     * (the `first` element of this will become the `second` of the new, the\n     * `second` element of this will become the `third` of the new and the current `third` will\n     * become the new `first`)\n     */\n    switched() {\n        return new Triple(__classPrivateFieldGet(this, _Triple_third, \"f\"), __classPrivateFieldGet(this, _Triple_first, \"f\"), __classPrivateFieldGet(this, _Triple_second, \"f\"));\n    }\n    /**\n     * Check if the given `element` is present in somewhere in this triple.<br>\n     * It is better if the types of the element of the `Triple` implements `Equatable` otherwise\n     * it will be used the `===` equality operator\n     * @param {F|S} element the element to check for the presence\n     * @return {boolean} `true` if the element id present in this pair\n     */\n    contains(element) {\n        return ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Triple_first, \"f\"), element) || (0, equatable_1.equals)(__classPrivateFieldGet(this, _Triple_second, \"f\"), element) || (0, equatable_1.equals)(__classPrivateFieldGet(this, _Triple_third, \"f\"), element));\n    }\n    /**\n     * Searches for the given `element` returning its position if present.\n     * If the element is not present, this method returns `null`.<br>\n     * It is better if the types of the element of the `Triple` implements `Equatable` otherwise\n     * it will be used the `===` equality operator\n     * @param {F|S|T} element the element to search for\n     * @return {PairPosition|null} the position of the element of `null` if not present\n     **/\n    search(element) {\n        if ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Triple_first, \"f\"), element))\n            return TriplePosition.FIRST;\n        if ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Triple_first, \"f\"), element))\n            return TriplePosition.SECOND;\n        if ((0, equatable_1.equals)(__classPrivateFieldGet(this, _Triple_third, \"f\"), element))\n            return TriplePosition.THIRD;\n        return null;\n    }\n    /**\n     * Collects the three element of this triple to produce a single result\n     * @param {(first: F, second: S, third: T) => R} collector the function that accepts the three elements of this\n     * triple and returns the result\n     */\n    collect(collector) {\n        return collector(__classPrivateFieldGet(this, _Triple_first, \"f\"), __classPrivateFieldGet(this, _Triple_second, \"f\"), __classPrivateFieldGet(this, _Triple_third, \"f\"));\n    }\n    /**\n     * Applies the `mapper` function on the **first** element of this triple and\n     * returns a new triple which contains the result of this function as the first\n     * element, the second element and the third that are the second and the third one of this triple\n     * @param {(first: F|null) => R} mapper the transformation function for the `first` element\n     * @return {Triple<R, S, T>} the new pair with the transformed first element\n     */\n    mapFirst(mapper) {\n        return new Triple(mapper(__classPrivateFieldGet(this, _Triple_first, \"f\")), __classPrivateFieldGet(this, _Triple_second, \"f\"), __classPrivateFieldGet(this, _Triple_third, \"f\"));\n    }\n    /**\n     * Applies the `mapper` function on the **second** element of this triple and\n     * returns a new triple which contains the result of this function as the second\n     * element and the first and the third element that are the first and the third ones of this triple\n     * @param {(second: S|null) => R} mapper the transformation function for the `second` element\n     * @return {Triple<F, R, T>} the new triple with the transformed second element\n     */\n    mapSecond(mapper) {\n        return new Triple(__classPrivateFieldGet(this, _Triple_first, \"f\"), mapper(__classPrivateFieldGet(this, _Triple_second, \"f\")), __classPrivateFieldGet(this, _Triple_third, \"f\"));\n    }\n    /**\n     * Applies the `mapper` function on the **third** element of this triple and\n     * returns a new triple which contains the result of this function as the third\n     * element and the first and the second element that are the first and the second ones of this triple\n     * @param {(third: T|null) => R} mapper the transformation function for the `third` element\n     * @return {Triple<F, S, R>} the new triple with the transformed second element\n     */\n    mapThird(mapper) {\n        return new Triple(__classPrivateFieldGet(this, _Triple_first, \"f\"), __classPrivateFieldGet(this, _Triple_second, \"f\"), mapper(__classPrivateFieldGet(this, _Triple_third, \"f\")));\n    }\n    /**\n     * Returns an array containing the two elements in this pair, preserving the order\n     */\n    toArray() {\n        return [__classPrivateFieldGet(this, _Triple_first, \"f\"), __classPrivateFieldGet(this, _Triple_second, \"f\"), __classPrivateFieldGet(this, _Triple_third, \"f\")];\n    }\n    /**\n     * Returns a clone of this pair. Every changes over the returning value **will not have effects** on\n     * this.\n     * **Notice that the copy will be deep only if the two elements are `Cloneable` themselves**, otherwise\n     * the clone will be a shallow copy equivalent to the result of `copy()`\n     */\n    clone() {\n        return new Triple((0, cloneable_1.tryClone)(__classPrivateFieldGet(this, _Triple_first, \"f\")), (0, cloneable_1.tryClone)(__classPrivateFieldGet(this, _Triple_second, \"f\")), (0, cloneable_1.tryClone)(__classPrivateFieldGet(this, _Triple_third, \"f\")));\n    }\n    /**\n     * Returns a shallow copy of this pair.\n     * Every changes over the returning value **will not have effects** on this but changes on the elements\n     * can be propagated (is a *shallow copy*)\n     */\n    copy() {\n        return new Triple(__classPrivateFieldGet(this, _Triple_first, \"f\"), __classPrivateFieldGet(this, _Triple_second, \"f\"), __classPrivateFieldGet(this, _Triple_third, \"f\"));\n    }\n    toString() {\n        return \"Triple(\" + __classPrivateFieldGet(this, _Triple_first, \"f\") + \", \" + __classPrivateFieldGet(this, _Triple_second, \"f\") + \", \" + __classPrivateFieldGet(this, _Triple_third, \"f\") + \")\";\n    }\n    /**\n     * Returns `true` the `other` object is a `Triple` with the two elements that are\n     * equals (intended as `===`) to the ones in this pair\n     * @param {any} other the other object\n     * @return {boolean} `true` if the `other` is a triple equals to this\n     */\n    equals(other) {\n        if (other != null) {\n            if (other instanceof Triple) {\n                return __classPrivateFieldGet(this, _Triple_first, \"f\") === __classPrivateFieldGet(other, _Triple_first, \"f\") && __classPrivateFieldGet(this, _Triple_second, \"f\") === __classPrivateFieldGet(other, _Triple_second, \"f\");\n            }\n        }\n        return false;\n    }\n}\nexports.Triple = Triple;\n_Triple_first = new WeakMap(), _Triple_second = new WeakMap(), _Triple_third = new WeakMap();\n/**\n * Creates and returns a new **triple** with the three elements given as parameters\n * @param {F|null} first the first element\n * @param {S|null} second the second element\n * @param {T|null} third the third element\n * @return {Triple<F, S, T>} the new created triple\n */\nfunction tripleOf(first, second, third) {\n    return new Triple(first, second, third);\n}\nexports.tripleOf = tripleOf;\n/**\n * Creates and returns a new **trio** with the three elements given as parameters\n * @param {F|null} first the first element\n * @param {S|null} second the second element\n * @param {T|null} third the third element\n * @return {Triple<F, S, T>} the new created trio\n */\nfunction trioOf(first, second, third) {\n    return new Triple(first, second, third);\n}\nexports.trioOf = trioOf;\n/**\n * Creates and returns a row array intended as a *1x3* matrix\n * @param {Trio<T>} trio the trio to be converted\n * @return a *1x3* matrix with the elements of the given triple\n */\nfunction trioAsRowArray(trio) {\n    let data = trio.toArray();\n    return (0, matrix_1.matrix)(data);\n}\nexports.trioAsRowArray = trioAsRowArray;\n/**\n * Creates and returns a column array intended as a *3x1* matrix\n * @param {Trio<T>} trio the trio to be converted\n * @return a *3x1* matrix with the elements of the given triple\n */\nfunction trioAsColumnArray(trio) {\n    let data = new Array(2);\n    for (let r = 0; r < data.length; r++) {\n        data[r] = [trio.get(r)];\n    }\n    return (0, matrix_1.matrix)(data);\n}\nexports.trioAsColumnArray = trioAsColumnArray;\n\n\n//# sourceURL=webpack:///./src/ts/types/triple.ts?");

/***/ }),

/***/ "./src/ts/types/types.ts":
/*!*******************************!*\
  !*** ./src/ts/types/types.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getTypeName = void 0;\n/**\n * Returns the name of the type of the object looking for the class name if it's an object\n * or returning the primitive name if not\n * @param {any} obj the object\n * @return the name of the type of the object\n */\nfunction getTypeName(obj) {\n    if (typeof obj == \"object\" || typeof obj == \"function\") {\n        return obj.constructor.name;\n    }\n    return typeof obj;\n}\nexports.getTypeName = getTypeName;\n\n\n//# sourceURL=webpack:///./src/ts/types/types.ts?");

/***/ }),

/***/ "./src/ts/webgl/webgl-application.ts":
/*!*******************************************!*\
  !*** ./src/ts/webgl/webgl-application.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ObjLimitsChecker = exports.ObjScale = exports.ObjRotation = exports.ObjPosition = exports.OnCanvasTouchEvent = exports.OnKeyboardEvent = exports.OnCanvasMouseEvent = exports.WebGLMesh = exports.WebGL = exports.WebGLApplication = void 0;\nconst mesh_object_manager_1 = __webpack_require__(/*! ../obj/mesh-object-manager */ \"./src/ts/obj/mesh-object-manager.ts\");\nconst mesh_object_drawer_1 = __webpack_require__(/*! ../obj/mesh-object-drawer */ \"./src/ts/obj/mesh-object-drawer.ts\");\nconst webgl_environment_1 = __webpack_require__(/*! ./webgl-environment */ \"./src/ts/webgl/webgl-environment.ts\");\nconst flow_1 = __webpack_require__(/*! ../signals/flow */ \"./src/ts/signals/flow.ts\");\nconst illegal_signal_name_exception_1 = __webpack_require__(/*! ../signals/exceptions/illegal-signal-name-exception */ \"./src/ts/signals/exceptions/illegal-signal-name-exception.ts\");\nconst log_1 = __webpack_require__(/*! ../log/log */ \"./src/ts/log/log.ts\");\nconst point_factory_1 = __webpack_require__(/*! ../geometry/point/point-factory */ \"./src/ts/geometry/point/point-factory.ts\");\nconst number_trio_1 = __webpack_require__(/*! ../types/numbers/number-trio */ \"./src/ts/types/numbers/number-trio.ts\");\nconst triple_1 = __webpack_require__(/*! ../types/triple */ \"./src/ts/types/triple.ts\");\nconst ObjToLoad = Symbol(\"ObjToLoad\");\nconst OnCanvasEventSym = Symbol(\"OnCanvasEvent\");\nconst OnKeyboardEventSym = Symbol(\"OnKeyboardEvent\");\nconst OnCanvasTouchEventSym = Symbol(\"OnCanvasTouchEvent\");\nclass WebGLApplication {\n    constructor(applicationName = null, environment = null) {\n        log_1.Log.log(\"creating WebGL application [\" + applicationName + \"]...\");\n        this.applicationName = applicationName;\n        if (environment != null) {\n            this.environment = environment;\n            log_1.Log.log(applicationName + \"| using existing WebGL environment\");\n            this.meshObjectManager = new mesh_object_manager_1.MeshObjectManager(applicationName, this.environment);\n            log_1.Log.log(applicationName + \"| mesh object manager created\");\n            this.meshObjectDrawer = new mesh_object_drawer_1.MeshObjectDrawer(applicationName, this.environment, this.meshObjectManager);\n            log_1.Log.log(applicationName + \"| mesh object drawer created\");\n            this.camera = this.meshObjectDrawer.getCamera();\n            log_1.Log.log(applicationName + \"| retrieved camera\");\n        }\n        log_1.Log.log(\"WebGL application [\" + applicationName + \"] created\");\n    }\n    getCanvas() {\n        return this.environment.getCanvas();\n    }\n    /**\n     * Returns the mesh object manager\n     * @protected\n     */\n    getMeshObjectManager() {\n        return this.meshObjectManager;\n    }\n    /**\n     * Returns the mesh object drawer\n     * @protected\n     */\n    getMeshObjectDrawer() {\n        return this.meshObjectDrawer;\n    }\n    /**\n     * Returns the camera\n     * @protected\n     */\n    getCamera() {\n        return this.camera;\n    }\n    /**\n     * Loads an object from a given url associating it to the given name\n     * @param {string} name the name of the object\n     * @param {string} url the url of the object\n     * @return {MeshObject} the loaded object\n     * @protected\n     */\n    loadObj(name, url) {\n        log_1.Log.log(this.applicationName + \" | loading object [\" + name + \"] from þ\" + url + \"]...\");\n        let res = this.meshObjectManager.loadObj(name, url);\n        log_1.Log.log(this.applicationName + \" | object [\" + name + \"] loaded!\");\n        return res;\n    }\n    /**\n     * Returns the object associated to the given name if already loaded, otherwise returns `undefined`\n     * @param {string} name the name of the object\n     * @returns {MeshObject | undefined} the object associated to the given name if already loaded,\n     * otherwise returns `undefined`\n     * @protected\n     */\n    getObj(name) {\n        return this.meshObjectManager.get(name);\n    }\n    /**\n     * Draws the scene\n     * @protected\n     */\n    drawScene() {\n        log_1.Log.log(this.applicationName + \" | drawing scene...\");\n        this.meshObjectDrawer.drawScene();\n        log_1.Log.log(this.applicationName + \" | scene drawn!\");\n    }\n    subscribeTo(signalName, options) {\n        log_1.Log.log(this.applicationName + \" | subscribing to signal [\" + signalName + \"]...\");\n        let receipt;\n        if (typeof signalName === \"string\") {\n            receipt = flow_1.default.getSubscriber(signalName).subscribe(options);\n        }\n        receipt = flow_1.default.getSubscriber(signalName).subscribe(options);\n        log_1.Log.log(this.applicationName + \" | subscribed to signal [\" + signalName + \"] with subscription id [\" +\n            receipt.subscriptionId + \"]!\");\n        return receipt;\n    }\n    /**\n     * Unsubscribes from a signal using the given subscription receipt.\n     * @param {SubscriptionReceipt<S, D, R>} subscriptionReceipt the subscription receipt\n     * @returns {SubscriptionReceipt<S, D, R>} the unsubscription receipt\n     */\n    unsubscribeFrom(subscriptionReceipt) {\n        log_1.Log.log(this.applicationName + \" | unsubscribing from signal [\" + subscriptionReceipt.signalName + \"] \");\n        let receipt = flow_1.default\n            .getSubscriber(subscriptionReceipt.signalName)\n            .unsubscribe(subscriptionReceipt);\n        log_1.Log.log(this.applicationName + \" | unsubscribed from signal [\" + subscriptionReceipt.signalName + \"]!\");\n        return receipt;\n    }\n    /**\n     * Creates a new custom signal with the given name, returning the flow associated to it.\n     * If the signal already exists, an error is thrown.\n     * @param {string} name the name of the new signal\n     * @returns {SingleSignalFlow<S, D, R>} the flow associated to the new signal\n     * @throws {IllegalSignalNameException} if the signal name is not valid (a signal with the same name\n     * already exists)\n     */\n    createSignal(name) {\n        log_1.Log.log(this.applicationName + \" | creating signal [\" + name + \"]...\");\n        if (flow_1.default.getSignalName(name) !== undefined) {\n            log_1.Log.log(this.applicationName + \" | signal [\" + name + \"] already exists!\");\n            alert(\"Unable to crete signal [\" + name + \"]: already exists!\");\n            throw new illegal_signal_name_exception_1.IllegalSignalNameException(name, \"signal already exists\");\n        }\n        let res = flow_1.default.newSingleFlow(name);\n        log_1.Log.log(this.applicationName + \" | signal [\" + name + \"] created!\");\n        return res;\n    }\n    getPositionInCanvas(event) {\n        let rect = this.getCanvas().getBoundingClientRect();\n        if (event instanceof TouchEvent) {\n            return {\n                x: event.touches[0].clientX - rect.left,\n                y: event.touches[0].clientY - rect.top\n            };\n        }\n        else if (event instanceof MouseEvent) {\n            return {\n                x: event.clientX - rect.left,\n                y: event.clientY - rect.top\n            };\n        }\n    }\n    /**\n     * The method that is called before the application starts.\n     * At the points all the mesh objects are loaded and the scene is ready to be drawn\n     */\n    beforeStart() {\n    }\n    start(args) {\n        log_1.Log.log(this.applicationName + \" | starting application...\");\n        this.main(args);\n    }\n}\nexports.WebGLApplication = WebGLApplication;\nfunction mapShaders(shaders) {\n    let res = new Map();\n    Object.entries(shaders).forEach(([key, value]) => {\n        res.set(key, value);\n    });\n    return res;\n}\n/**\n * Creates a new webgl application injecting all the required dependencies or the fields that are\n * necessary to create them\n * @param {string} applicationName the name of the application\n * @param {string} canvasHtmlElementName the name of the canvas html element\n * @param {string[]} webGLShaders the names of the webgl shaders\n * @constructor\n */\nfunction WebGL(applicationName, canvasHtmlElementName, webGLShaders) {\n    // @ts-ignore\n    window[\"APPLICATIONS\"] = window[\"APPLICATIONS\"] || new Map();\n    // @ts-ignore\n    window[\"SIGNALS\"] = window[\"SIGNALS\"] || flow_1.default;\n    return function (clazz) {\n        let appSignalFlow = flow_1.default.newSingleFlow(\"application.\" + applicationName + \".started\");\n        try {\n            let instance = new clazz();\n            // @ts-ignore\n            window[\"APPLICATIONS\"].set(applicationName, instance);\n            log_1.Log.log(\"creating webgl environment for \" + applicationName + \" ...\");\n            let webGLEnvironment = (0, webgl_environment_1.createWebglEnvironment)(canvasHtmlElementName, mapShaders(webGLShaders));\n            log_1.Log.log(\"creating mesh object manager for \" + applicationName + \" ...\");\n            let meshObjectManager = new mesh_object_manager_1.MeshObjectManager(applicationName, webGLEnvironment);\n            log_1.Log.log(\"creating mesh object drawer for \" + applicationName + \" ...\");\n            let meshObjectDrawer = new mesh_object_drawer_1.MeshObjectDrawer(applicationName, webGLEnvironment, meshObjectManager);\n            log_1.Log.log(\"injecting application variables for \" + applicationName + \" ...\");\n            instance[\"environment\"] = webGLEnvironment;\n            instance[\"meshObjectManager\"] = meshObjectManager;\n            instance[\"meshObjectDrawer\"] = meshObjectDrawer;\n            instance[\"camera\"] = meshObjectDrawer.getCamera();\n            instance[\"applicationName\"] = applicationName;\n            // Loading mesh objects\n            log_1.Log.log(\"loading objects for \" + applicationName + \" ...\");\n            for (let objToLoad of clazz.prototype[ObjToLoad]) {\n                let continuation = objToLoad[1];\n                log_1.Log.log(\"loading object [\" + continuation.name + \"] for \" + applicationName + \" ...\");\n                let obj = meshObjectManager.loadObj(continuation.name, continuation.path);\n                if (continuation.position != null) {\n                    obj.setPosition(continuation.position);\n                }\n                if (continuation.rotation != null) {\n                    obj.setPolarRotation(continuation.rotation.getFirst(), continuation.rotation.getSecond(), continuation.rotation.getThird());\n                }\n                if (continuation.scale != null) {\n                    obj.setScale(continuation.scale);\n                }\n                if (continuation.limitsChecker != null) {\n                    obj.setLimitsChecker(continuation.limitsChecker);\n                }\n                instance[continuation.propertyKey] = obj;\n                log_1.Log.log(\"object [\" + continuation.name + \"] loaded for \" + applicationName +\n                    \" into property [\" + continuation.propertyKey + \"]!\");\n            }\n            // Attach canvas mouse events\n            const onCanvasMouseEventMethods = clazz.prototype[OnCanvasEventSym];\n            if (onCanvasMouseEventMethods != undefined) {\n                onCanvasMouseEventMethods.forEach((event, method) => {\n                    log_1.Log.log(\"subscribing to event [\" + event + \"] for \" + applicationName +\n                        \" with method [\" + method + \"] ...\");\n                    webGLEnvironment.getCanvas().addEventListener(event, (e) => {\n                        instance[method](e);\n                    });\n                });\n            }\n            // Attach keyboard events\n            const onKeyboardEventMethods = clazz.prototype[OnKeyboardEventSym];\n            if (onKeyboardEventMethods != undefined) {\n                onKeyboardEventMethods.forEach((event, method) => {\n                    log_1.Log.log(\"subscribing to event [\" + event + \"] for \" + applicationName +\n                        \" with method [\" + method + \"] ...\");\n                    document.addEventListener(event, (e) => {\n                        instance[method](e);\n                    });\n                });\n            }\n            // Attaching canvas touch events\n            const onCanvasTouchEventMethods = clazz.prototype[OnCanvasTouchEventSym];\n            if (onCanvasTouchEventMethods != undefined) {\n                onCanvasTouchEventMethods.forEach((event, method) => {\n                    log_1.Log.log(\"subscribing to event [\" + event + \"] for \" + applicationName +\n                        \" with method [\" + method + \"] ...\");\n                    document.addEventListener(event, (e) => {\n                        instance[method](e);\n                    }, false);\n                });\n            }\n            log_1.Log.log(\"initializing application \" + applicationName + \" ...\");\n            instance.beforeStart();\n            log_1.Log.log(\"starting application \" + applicationName + \" ...\");\n            //CameraControls.init(instance)\n            appSignalFlow.fire(instance, \"STARTED\");\n            instance.start();\n        }\n        catch (e) {\n            alert(e);\n            throw e;\n        }\n    };\n}\nexports.WebGL = WebGL;\nclass ObjInitializationContinuation {\n    constructor() {\n        this.propertyKey = null;\n        this.name = null;\n        this.path = null;\n        this.position = null;\n        this.rotation = null;\n        this.scale = null;\n        this.limitsChecker = null;\n    }\n}\nfunction getOrCreateObjInitializationContinuation(target, propertyKey) {\n    target[ObjToLoad] = target[ObjToLoad] || new Map();\n    let objInitializationContinuation = target[ObjToLoad].get(propertyKey);\n    if (objInitializationContinuation == undefined) {\n        objInitializationContinuation = new ObjInitializationContinuation();\n        objInitializationContinuation.propertyKey = propertyKey;\n        target[ObjToLoad].set(propertyKey, objInitializationContinuation);\n    }\n    return objInitializationContinuation;\n}\n/**\n * Annotates a field to be loaded as a webgl mesh\n * @param {string} url the url of the mesh\n * @param {string} name the name of the field (optional, if absent the name of the field is used)\n * @param {Point3D} position the position of the mesh (optional, if absent the mesh is not translated)\n * @param {Couple<Angle>} rotation the rotation of the mesh (optional, if absent the mesh is not rotated)\n * @param {NumberTrio} scale the scale of the mesh (optional, if absent the mesh is not scaled)\n * @param {LimitsChecker} limitsChecker the limits checker of the mesh (optional, if absent the mesh is not limited)\n * @constructor\n */\nfunction WebGLMesh(url, name = null, position = null, rotation = null, scale = null, limitsChecker = null) {\n    return function (target, propertyKey) {\n        if (name == null) {\n            name = propertyKey;\n        }\n        let continuation = getOrCreateObjInitializationContinuation(target, propertyKey);\n        continuation.path = url;\n        continuation.name = name;\n        if (position != null)\n            continuation.position = position;\n        if (rotation != null)\n            continuation.rotation = rotation;\n        if (scale != null)\n            continuation.scale = scale;\n        if (limitsChecker != null)\n            continuation.limitsChecker = limitsChecker;\n    };\n}\nexports.WebGLMesh = WebGLMesh;\nfunction OnCanvasMouseEvent(eventName) {\n    return function (target, propertyKey, descriptor) {\n        log_1.Log.log(\"OnCanvasMouseEvent \" + eventName + \" on \" + propertyKey);\n        target[OnCanvasEventSym] = target[OnCanvasEventSym] || new Map();\n        target[OnCanvasEventSym].set(propertyKey, eventName);\n    };\n}\nexports.OnCanvasMouseEvent = OnCanvasMouseEvent;\nfunction OnKeyboardEvent(eventName) {\n    return function (target, propertyKey, descriptor) {\n        log_1.Log.log(\"OnKeyboardEvent \" + eventName + \" on \" + propertyKey);\n        target[OnKeyboardEventSym] = target[OnKeyboardEventSym] || new Map();\n        target[OnKeyboardEventSym].set(propertyKey, eventName);\n    };\n}\nexports.OnKeyboardEvent = OnKeyboardEvent;\nfunction OnCanvasTouchEvent(eventName) {\n    return function (target, propertyKey, descriptor) {\n        log_1.Log.log(\"OnKeyboardEvent \" + eventName + \" on \" + propertyKey);\n        target[OnCanvasTouchEventSym] = target[OnCanvasTouchEventSym] || new Map();\n        target[OnCanvasTouchEventSym].set(propertyKey, eventName);\n    };\n}\nexports.OnCanvasTouchEvent = OnCanvasTouchEvent;\n/**\n * Sets the position the mesh object will have when loaded\n * @param {number} x the x coordinate of the position\n * @param {number} y the y coordinate of the position\n * @param {number} z the z coordinate of the position\n * @constructor\n */\nfunction ObjPosition(x, y, z) {\n    return function (target, propertyKey) {\n        getOrCreateObjInitializationContinuation(target, propertyKey)\n            .position = (0, point_factory_1.point3D)(x, y, z);\n    };\n}\nexports.ObjPosition = ObjPosition;\n/**\n * Sets the scale the mesh object will have when loaded\n * @param {number} psi the psi angle of the rotation (around the `x` axis)\n * @param {number} theta the theta angle of the rotation (around the `y` axis)\n * @param {number} phi the phi angle of the rotation (around the `z` axis)\n * @constructor\n */\nfunction ObjRotation(psi, theta, phi) {\n    return function (target, propertyKey) {\n        getOrCreateObjInitializationContinuation(target, propertyKey)\n            .rotation = (0, triple_1.trioOf)(psi, theta, phi);\n    };\n}\nexports.ObjRotation = ObjRotation;\n/**\n * Sets the scale the mesh object will have when loaded\n * @param {number} x the scale of the x coordinate\n * @param {number} y the scale of the y coordinate\n * @param {number} z the scale of the z coordinate\n * @constructor\n */\nfunction ObjScale(x, y, z) {\n    return function (target, propertyKey) {\n        getOrCreateObjInitializationContinuation(target, propertyKey)\n            .scale = (0, number_trio_1.numberTrio)(x, y, z);\n    };\n}\nexports.ObjScale = ObjScale;\n/**\n * Sets the limits checker the mesh object will have when loaded\n * @param {LimitsChecker} limitsChecker the limits checker\n * @constructor\n */\nfunction ObjLimitsChecker(limitsChecker) {\n    return function (target, propertyKey) {\n        getOrCreateObjInitializationContinuation(target, propertyKey)\n            .limitsChecker = limitsChecker;\n    };\n}\nexports.ObjLimitsChecker = ObjLimitsChecker;\n\n\n//# sourceURL=webpack:///./src/ts/webgl/webgl-application.ts?");

/***/ }),

/***/ "./src/ts/webgl/webgl-environment.ts":
/*!*******************************************!*\
  !*** ./src/ts/webgl/webgl-environment.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _WebGLEnvironment_canvas, _WebGLEnvironment_gl, _WebGLEnvironment_programInfo;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createWebglEnvironment = exports.WebGLEnvironment = void 0;\nclass WebGLEnvironment {\n    constructor(canvas, webGLShaders) {\n        _WebGLEnvironment_canvas.set(this, void 0);\n        _WebGLEnvironment_gl.set(this, void 0);\n        _WebGLEnvironment_programInfo.set(this, void 0);\n        if (!('getContext' in canvas)) {\n            alert(\"The given HTML element is not a canvas\");\n            throw new Error(\"The given HTML element is not a canvas\");\n        }\n        __classPrivateFieldSet(this, _WebGLEnvironment_canvas, canvas, \"f\");\n        __classPrivateFieldSet(this, _WebGLEnvironment_gl, __classPrivateFieldGet(this, _WebGLEnvironment_canvas, \"f\").getContext(\"webgl\"), \"f\");\n        if (__classPrivateFieldGet(this, _WebGLEnvironment_gl, \"f\") == null) {\n            alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n            throw new Error(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n        }\n        const ext = __classPrivateFieldGet(this, _WebGLEnvironment_gl, \"f\").getExtension('WEBGL_depth_texture');\n        if (!ext) {\n            alert('WEBGL_depth_texture is required to work');\n        }\n        __classPrivateFieldSet(this, _WebGLEnvironment_programInfo, new Map(), \"f\");\n        webGLShaders.forEach((value, key) => {\n            __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\").set(key, WebGLUtils.createProgramInfo(__classPrivateFieldGet(this, _WebGLEnvironment_gl, \"f\"), value));\n        });\n    }\n    /**\n     * Returns the `HtmlCanvasElement` associated to this environment\n     */\n    getCanvas() {\n        return __classPrivateFieldGet(this, _WebGLEnvironment_canvas, \"f\");\n    }\n    /**\n     * Returns the `WebGLRenderingContext` associated to this environment\n     */\n    getContext() {\n        return __classPrivateFieldGet(this, _WebGLEnvironment_gl, \"f\");\n    }\n    /**\n     * Returns the `WebGLProgram` associated to this environment\n     */\n    getProgramInfo(programName = null) {\n        if (programName == null) {\n            return __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\").values().next().value;\n        }\n        return __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\").get(programName);\n    }\n    getProgramInfos() {\n        return __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\");\n    }\n    getPrograms() {\n        let programs = new Map();\n        __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\").forEach((value, key) => {\n            programs.set(key, value.program);\n        });\n        return programs;\n    }\n    /**\n     * Returns the `WebGLProgram` associated to this environment\n     */\n    getProgram(programName = null) {\n        var _a;\n        if (programName == null) {\n            return __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\").values().next().value.program;\n        }\n        return (_a = __classPrivateFieldGet(this, _WebGLEnvironment_programInfo, \"f\").get(programName)) === null || _a === void 0 ? void 0 : _a.program;\n    }\n    /**\n     * Returns the aspect ratio of the canvas\n     */\n    calculateAspectRatio() {\n        return __classPrivateFieldGet(this, _WebGLEnvironment_canvas, \"f\").clientWidth / __classPrivateFieldGet(this, _WebGLEnvironment_canvas, \"f\").clientHeight;\n    }\n}\nexports.WebGLEnvironment = WebGLEnvironment;\n_WebGLEnvironment_canvas = new WeakMap(), _WebGLEnvironment_gl = new WeakMap(), _WebGLEnvironment_programInfo = new WeakMap();\n/**\n * Creates a new `WebglEnvironment` using the `canvasHtmlName` to find the `HtmlElement` of the canvas\n * and the `webGLShaders` to create the `WebGLProgram`\n * @param {string} canvasHtmlName the name of the `HtmlElement` of the canvas\n * @param {string[]} webGLShaders the names of the shaders to create the `WebGLProgram`\n */\nfunction createWebglEnvironment(canvasHtmlName, webGLShaders) {\n    let canvas = document.getElementById(canvasHtmlName);\n    if (canvas == null) {\n        alert(\"Unable to find the canvas with id: \" + canvas);\n        throw new Error(\"Unable to find the canvas with id: \" + canvas);\n    }\n    return new WebGLEnvironment(canvas, webGLShaders);\n}\nexports.createWebglEnvironment = createWebglEnvironment;\n\n\n//# sourceURL=webpack:///./src/ts/webgl/webgl-environment.ts?");

/***/ }),

/***/ "./src/ts/webgl/webgl-wrappers.ts":
/*!****************************************!*\
  !*** ./src/ts/webgl/webgl-wrappers.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SharedUniforms = void 0;\nclass SharedUniforms {\n    constructor() {\n        this.u_ambientLight = [0.2, 0.2, 0.2];\n        this.u_colorLight = [1.0, 1.0, 1.0];\n        this.u_view = M4.identity();\n        this.u_projection = M4.identity();\n        this.u_lightDirection = [2, 2, 2];\n        this.u_bias = 0.001;\n        this.texture_matrix = M4.identity();\n        this.u_projectedTexture = null;\n        this.u_colorMult = [1, 1, 1, 1];\n    }\n}\nexports.SharedUniforms = SharedUniforms;\n\n\n//# sourceURL=webpack:///./src/ts/webgl/webgl-wrappers.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/AntonioFranzeseApp.ts");
/******/ 	
/******/ })()
;