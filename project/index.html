<!doctype html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <link rel="stylesheet" href="resources/styles/index.css">

      <title>Computer Graphics 2021/22</title>
    </head>

<body>

<!-- SHADERS -------------------------------------->
<!-- vertex shader -->
<script  id="color-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

void main() {
  gl_Position = u_projection * u_view * u_world * a_position;
}
</script>
<!-- fragment shader -->
<script  id="color-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

uniform vec4 u_color;
void main() {
  gl_FragColor = u_color;
}
</script>


<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec2 a_texcoord;
attribute vec3 a_normal;

uniform vec3 u_lightWorldPosition;
uniform vec3 u_viewWorldPosition;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

varying vec2 v_texcoord;
varying vec4 v_projectedTexcoord;
varying vec3 v_normal;

varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

void main() {
  // Multiply the position by the matrix.
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // Pass the texture coord to the fragment shader.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;

  // orient the normals and pass to the fragment shader
  v_normal = mat3(u_world) * a_normal;

  // compute the world position of the surface
  vec3 surfaceWorldPosition = (u_world * a_position).xyz;

  // compute the vector of the surface to the light
  // and pass it to the fragment shader
  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;

  // compute the vector of the surface to the view/camera
  // and pass it to the fragment shader
  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec2 v_texcoord;
varying vec4 v_projectedTexcoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;
uniform float u_bias;
uniform float u_shininess;
uniform vec3 u_lightDirection;
uniform float u_innerLimit;          // in dot space
uniform float u_outerLimit;          // in dot space

void main() {
  // because v_normal is a varying it's interpolated
  // so it will not be a unit vector. Normalizing it
  // will make it a unit vector again
  vec3 normal = normalize(v_normal);

  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

  float dotFromDirection = dot(surfaceToLightDirection,
                               -u_lightDirection);
  float limitRange = u_innerLimit - u_outerLimit;
  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);

  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange =
      projectedTexcoord.x >= 0.0 &&
      projectedTexcoord.x <= 1.0 &&
      projectedTexcoord.y >= 0.0 &&
      projectedTexcoord.y <= 1.0;

  // the 'r' channel has the depth values
  float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
  gl_FragColor = vec4(
      texColor.rgb * light * shadowLight +
      specular * shadowLight,
      texColor.a);
}
</script>

<div id="parent_div">

  <canvas width="1500" height="600" id="my_Canvas" class="canvas"></canvas>
  <div class="container">
    <div id="uiContainer" class="menu menuInv">
      <div id="ui">
      </div>
    </div>
    <span class="menuButton" onclick="toggleMenu()">Menu</span>
  </div>

</div>

<!-- JS SCRIPT -->
<script type="text/javascript" src="https://unpkg.com/mathjs@11.0.1/lib/browser/math.js"></script>
<script type="text/javascript" src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script type="text/javascript" src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
<script type="text/javascript" src="lib/js/mesh_utils.js"></script>
<script type="text/javascript" src="lib/js/glm_utils.js"></script>
<script type="text/javascript" src="lib/js/load_mesh.js"></script>
<script type="text/javascript" src="lib/js/load_objx.js"></script>
<script type="text/javascript" src="lib/js/webgl-lessons-ui-modified.js"></script>
<script type="text/javascript" src="lib/js/lib-master.js"></script>

<script type="text/javascript" src="dist/bundle.js"></script>
<!--<script type="text/javascript" src="movement.js"></script>!-->

<script>
  function toggleMenu(){
    let menu = document.getElementById("uiContainer");
    if(menu.className==="menu menuInv")
      menuVisible(true);
    else
      menuVisible(false);
  }
  function menuVisible(bool) {
    let menu = document.getElementById("uiContainer");
    if(bool)
      menu.className = "menu";
    else
      menu.className = "menu menuInv";
  }
</script>
</body>

</html>
